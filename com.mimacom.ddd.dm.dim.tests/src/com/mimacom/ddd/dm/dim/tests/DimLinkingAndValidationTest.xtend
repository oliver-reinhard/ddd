/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dim.tests

import com.google.inject.Inject
import com.google.inject.Provider
import com.mimacom.ddd.dm.base.base.DDetailType
import com.mimacom.ddd.dm.base.base.DEnumeration
import com.mimacom.ddd.dm.base.base.DNamespace
import com.mimacom.ddd.dm.dim.DimPackage
import com.mimacom.ddd.dm.dim.DimPrimitive
import com.mimacom.ddd.dm.dim.DomainInformationModel
import com.mimacom.ddd.dm.dmx.DmxModel
import com.mimacom.ddd.dm.dmx.DmxPackage
import com.mimacom.ddd.dm.dmx.DmxStandaloneSetup
import com.mimacom.ddd.dm.dmx.impl.DmxArchetypeImpl
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.util.Diagnostician
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.*

@ExtendWith(InjectionExtension)
@InjectWith(DimInjectorProvider)
class DimLinkingAndValidationTest {
	
	protected static val DMX = DmxPackage.eINSTANCE
	protected static val DIM = DimPackage.eINSTANCE
	
	@Inject Provider<ResourceSet> resourceSetProvider
	@Inject ParseHelper<DNamespace> dimParseHelper
	final ParseHelper<DNamespace> dmxParseHelper
	
	new() {
		val dmxInjector = new DmxStandaloneSetup().createInjectorAndDoEMFRegistration()
		dmxParseHelper = dmxInjector.getInstance(ParseHelper)
	}
	
	protected def DomainInformationModel parse(CharSequence dimSourceText) {
		val resourceSet = resourceSetProvider.get
		
		// Provide SystemTypes:
		val systemTypes = dmxParseHelper.parse('''
			namespace dm.types
			archetype Boolean		is BOOLEAN
			archetype Natural 		is NUMBER	
			archetype Text			is TEXT
			archetype Timepoint		is TIMEPOINT
			''', resourceSet)
		assertNotNull(systemTypes)
		val stErrors = systemTypes.eResource.errors
		assertTrue(stErrors.isEmpty, '''Parse errors in system types: «stErrors.join(", ")»''')
		val systemTypesModel = systemTypes.model as DmxModel
		assertNotNull(systemTypesModel)
		assertNoValidationErrors(systemTypesModel)
		assertEquals(DmxArchetypeImpl, systemTypesModel.types.get(0).class)
		
		// Parse actual expression
		val dimNamespace = dimParseHelper.parse(dimSourceText, resourceSet)
		assertNotNull(dimNamespace)
		val errors = dimNamespace.eResource.errors
		assertTrue(errors.isEmpty, '''Parse errors DIM: «errors.join("; ")»''')
		val dimModel = dimNamespace.model as DomainInformationModel
		assertNotNull(dimModel)
		assertNoValidationErrors(dimModel)
		return dimModel
	}
	
	@Test
	def void testSystemTypeResolution() {
		val dimModel = parse('''
			domain D
			information model SystemTypes {
				detail A {
					a0 : Boolean
					a1 : Natural
					a2 : Text
					a3 : Timepoint
				}
			}
		''')
		assertEquals(DIM.dimDetailType, dimModel.types.get(0).eClass)
		val detailA = dimModel.types.get(0) as DDetailType
		
		val a0 = detailA.features.get(0)
		assertNotNull(a0.type)
		assertEquals("Boolean", a0.type.name)
		assertFalse(a0.type.eIsProxy)
		assertEquals(DMX.dmxArchetype, a0.type.eClass)
		
		val a1 = detailA.features.get(1)
		assertNotNull(a1.type)
		assertEquals("Natural", a1.type.name)
		assertFalse(a1.type.eIsProxy)
		assertEquals(DMX.dmxArchetype, a1.type.eClass)
	}
	
	@Test
	def void testPrimitiveWithContstraint() {
		val dimModel = parse('''
			domain D
			information model CustomTypes {
				primitive P1 redefines Natural {
					constraint Range: self | self > 10 AND self < 100
				}
			}
		''')
		assertEquals(DIM.dimPrimitive, dimModel.types.get(0).eClass)
		val p1 = dimModel.types.get(0) as DimPrimitive
		assertEquals("P1", p1.name)
		assertEquals(1, p1.constraints.size)
		val c1 = p1.constraints.get(0)
		assertEquals("Range", c1.name)
	}
	
	@Test
	def void testEnumeration() {
		val dimModel = parse('''
			domain D
			information model CustomTypes {
				enumeration E1 { L1, L2 }
			}
		''')
		assertEquals(DIM.dimEnumeration, dimModel.types.get(0).eClass)
		val e1 = dimModel.types.get(0) as DEnumeration
		assertEquals(2, e1.literals.size)
		val l1 = e1.literals.get(0)
		assertEquals("L1", l1.name)
		val l2 = e1.literals.get(1)
		assertEquals("L2", l2.name)
	}
	
	@Test
	def void testComplexTypeWithCustomTypes() {
		val dimModel = parse('''
			domain D
			information model CustomTypes {
				primitive P1 redefines Natural
				enumeration E1 { L1, L2 }
				detail A {
					a0 : Boolean
					a1 : P1
					a3 : E1
					q1(p:P1) : Natural
					q2(left:P1, right:P1) : Natural
					q3() : B
				}
				detail B {
					b1 : Natural
					q5(p:P1) : Natural
				}
			}
		''')
		assertEquals(DIM.dimPrimitive, dimModel.types.get(0).eClass)
		assertEquals(DIM.dimEnumeration, dimModel.types.get(1).eClass)
		
		assertEquals(DIM.dimDetailType, dimModel.types.get(2).eClass)
		val detailA = dimModel.types.get(2) as DDetailType
		val a1 = (detailA as DDetailType).features.get(1)
		assertNotNull(a1.type)
		assertEquals("P1", a1.type.name)
		assertFalse(a1.type.eIsProxy)
		assertEquals(DIM.dimPrimitive, a1.type.eClass)
	}
	
	protected def assertNoValidationErrors(EObject obj) {
//		val result = Diagnostician.INSTANCE.validate(EcoreUtil.getRootContainer(obj)).children
		val result = Diagnostician.INSTANCE.validate(obj).children
		assertTrue(result.isEmpty, '''No validation errors expected: «result.join("; ")»''')
	}
	
	protected def assertHasValidationERRORS(EObject obj) {
		val result = Diagnostician.INSTANCE.validate(obj).children
		assertTrue(result.size >= 1, "Has validation errors")
	}
}
