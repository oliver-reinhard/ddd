/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sms.serializer;

import com.google.inject.Inject;
import com.mimacom.ddd.sm.sms.SAggregate;
import com.mimacom.ddd.sm.sms.SAssociation;
import com.mimacom.ddd.sm.sms.SAttribute;
import com.mimacom.ddd.sm.sms.SCondition;
import com.mimacom.ddd.sm.sms.SDeductionRule;
import com.mimacom.ddd.sm.sms.SDetailType;
import com.mimacom.ddd.sm.sms.SDomain;
import com.mimacom.ddd.sm.sms.SEnumeration;
import com.mimacom.ddd.sm.sms.SExpression;
import com.mimacom.ddd.sm.sms.SImport;
import com.mimacom.ddd.sm.sms.SLiteral;
import com.mimacom.ddd.sm.sms.SMemberDeductionRule;
import com.mimacom.ddd.sm.sms.SMorphTransform;
import com.mimacom.ddd.sm.sms.SMultiplicity;
import com.mimacom.ddd.sm.sms.SPrimitive;
import com.mimacom.ddd.sm.sms.SQuery;
import com.mimacom.ddd.sm.sms.SQueryParameter;
import com.mimacom.ddd.sm.sms.SRootType;
import com.mimacom.ddd.sm.sms.SSpoofTransform;
import com.mimacom.ddd.sm.sms.SmsPackage;
import com.mimacom.ddd.sm.sms.services.SmsGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SmsSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SmsGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmsPackage.SAGGREGATE:
				sequence_SAggregate(context, (SAggregate) semanticObject); 
				return; 
			case SmsPackage.SASSOCIATION:
				sequence_SAssociation(context, (SAssociation) semanticObject); 
				return; 
			case SmsPackage.SATTRIBUTE:
				sequence_SAttribute(context, (SAttribute) semanticObject); 
				return; 
			case SmsPackage.SCONDITION:
				sequence_SConstraint(context, (SCondition) semanticObject); 
				return; 
			case SmsPackage.SDEDUCTION_RULE:
				sequence_SDeductionRule(context, (SDeductionRule) semanticObject); 
				return; 
			case SmsPackage.SDETAIL_TYPE:
				sequence_SComplexType_SDetailType(context, (SDetailType) semanticObject); 
				return; 
			case SmsPackage.SDOMAIN:
				sequence_SDomain(context, (SDomain) semanticObject); 
				return; 
			case SmsPackage.SENUMERATION:
				sequence_SEnumeration(context, (SEnumeration) semanticObject); 
				return; 
			case SmsPackage.SEXPRESSION:
				sequence_SExpression(context, (SExpression) semanticObject); 
				return; 
			case SmsPackage.SIMPORT:
				sequence_SImport(context, (SImport) semanticObject); 
				return; 
			case SmsPackage.SLITERAL:
				sequence_SLiteral(context, (SLiteral) semanticObject); 
				return; 
			case SmsPackage.SMEMBER_DEDUCTION_RULE:
				sequence_SMemberDeductionRule(context, (SMemberDeductionRule) semanticObject); 
				return; 
			case SmsPackage.SMORPH_TRANSFORM:
				sequence_SMorphTransform(context, (SMorphTransform) semanticObject); 
				return; 
			case SmsPackage.SMULTIPLICITY:
				sequence_SMultiplicity(context, (SMultiplicity) semanticObject); 
				return; 
			case SmsPackage.SPRIMITIVE:
				sequence_SPrimitive(context, (SPrimitive) semanticObject); 
				return; 
			case SmsPackage.SQUERY:
				sequence_SQuery(context, (SQuery) semanticObject); 
				return; 
			case SmsPackage.SQUERY_PARAMETER:
				sequence_SQueryParameter(context, (SQueryParameter) semanticObject); 
				return; 
			case SmsPackage.SROOT_TYPE:
				sequence_SComplexType_SRootType(context, (SRootType) semanticObject); 
				return; 
			case SmsPackage.SSPOOF_TRANSFORM:
				sequence_SSpoofTransform(context, (SSpoofTransform) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     SAggregate returns SAggregate
	 *
	 * Constraint:
	 *     types+=SType*
	 */
	protected void sequence_SAggregate(ISerializationContext context, SAggregate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SFeature returns SAssociation
	 *     SAssociation returns SAssociation
	 *
	 * Constraint:
	 *     (derived?='derived'? (kind=SAssociationKind | kind=SAssociationKindInverse) name=ID type=[SRootType|ID] multiplicity=SMultiplicity?)
	 */
	protected void sequence_SAssociation(ISerializationContext context, SAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SFeature returns SAttribute
	 *     SAttribute returns SAttribute
	 *
	 * Constraint:
	 *     (
	 *         (detail?='detail'? deductionRule=SMemberDeductionRule) | 
	 *         (detail?='detail'? name=ID type=[SSimpleType|ID] multiplicity=SMultiplicity? key?='key'?)
	 *     )
	 */
	protected void sequence_SAttribute(ISerializationContext context, SAttribute semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SType returns SDetailType
	 *     SDetailType returns SDetailType
	 *
	 * Constraint:
	 *     (
	 *         ((abstract?='abstract'? deductionRule=SDeductionRule) | (abstract?='abstract'? name=ID)) 
	 *         superType=[SComplexType|ID]? 
	 *         (features+=SFeature | constraints+=SConstraint)*
	 *     )
	 */
	protected void sequence_SComplexType_SDetailType(ISerializationContext context, SDetailType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SType returns SRootType
	 *     SRootType returns SRootType
	 *
	 * Constraint:
	 *     (
	 *         ((abstract?='abstract'? deductionRule=SDeductionRule) | (abstract?='abstract'? name=ID)) 
	 *         superType=[SComplexType|ID]? 
	 *         (features+=SFeature | constraints+=SConstraint)*
	 *     )
	 */
	protected void sequence_SComplexType_SRootType(ISerializationContext context, SRootType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SConstraint returns SCondition
	 *
	 * Constraint:
	 *     (name=ID condition=SExpression)
	 */
	protected void sequence_SConstraint(ISerializationContext context, SCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SCONDITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SCONDITION__NAME));
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SCONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SCONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSConstraintAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSConstraintAccess().getConditionSExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SDeductionRule returns SDeductionRule
	 *
	 * Constraint:
	 *     (source=[DNamedElement|SQualifiedName] transform=STransform)
	 */
	protected void sequence_SDeductionRule(ISerializationContext context, SDeductionRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SDEDUCTION_RULE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SDEDUCTION_RULE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SDEDUCTION_RULE__TRANSFORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SDEDUCTION_RULE__TRANSFORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSDeductionRuleAccess().getSourceDNamedElementSQualifiedNameParserRuleCall_0_0_1(), semanticObject.eGet(SmsPackage.Literals.SDEDUCTION_RULE__SOURCE, false));
		feeder.accept(grammarAccess.getSDeductionRuleAccess().getTransformSTransformParserRuleCall_1_0(), semanticObject.getTransform());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SDomain returns SDomain
	 *
	 * Constraint:
	 *     (name=SQualifiedName imports+=SImport* (types+=SType | aggregates+=SAggregate)*)
	 */
	protected void sequence_SDomain(ISerializationContext context, SDomain semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SType returns SEnumeration
	 *     SEnumeration returns SEnumeration
	 *
	 * Constraint:
	 *     (name=ID (literals+=SLiteral literals+=SLiteral*)? constraints+=SConstraint*)
	 */
	protected void sequence_SEnumeration(ISerializationContext context, SEnumeration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SExpression returns SExpression
	 *
	 * Constraint:
	 *     expr=STRING
	 */
	protected void sequence_SExpression(ISerializationContext context, SExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SEXPRESSION__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SEXPRESSION__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSExpressionAccess().getExprSTRINGTerminalRuleCall_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SImport returns SImport
	 *
	 * Constraint:
	 *     importedNamespace=SQualifiedNameWithWildcard
	 */
	protected void sequence_SImport(ISerializationContext context, SImport semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SIMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SIMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSImportAccess().getImportedNamespaceSQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SLiteral returns SLiteral
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SLiteral(ISerializationContext context, SLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SNAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SNAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSLiteralAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SMemberDeductionRule returns SMemberDeductionRule
	 *
	 * Constraint:
	 *     (source=[DNamedElement|ID] transform=STransform)
	 */
	protected void sequence_SMemberDeductionRule(ISerializationContext context, SMemberDeductionRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SMEMBER_DEDUCTION_RULE__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SMEMBER_DEDUCTION_RULE__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SMEMBER_DEDUCTION_RULE__TRANSFORM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SMEMBER_DEDUCTION_RULE__TRANSFORM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSMemberDeductionRuleAccess().getSourceDNamedElementIDTerminalRuleCall_0_0_1(), semanticObject.eGet(SmsPackage.Literals.SMEMBER_DEDUCTION_RULE__SOURCE, false));
		feeder.accept(grammarAccess.getSMemberDeductionRuleAccess().getTransformSTransformParserRuleCall_1_0(), semanticObject.getTransform());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     STransform returns SMorphTransform
	 *     SMorphTransform returns SMorphTransform
	 *
	 * Constraint:
	 *     (renameTo=ID? (retypeTo=[SType|ID] remultiplyTo=SMultiplicity?)?)
	 */
	protected void sequence_SMorphTransform(ISerializationContext context, SMorphTransform semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SMultiplicity returns SMultiplicity
	 *
	 * Constraint:
	 *     (minOccurs=INT maxOccurs=MULTIPLICITY)
	 */
	protected void sequence_SMultiplicity(ISerializationContext context, SMultiplicity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SMULTIPLICITY__MIN_OCCURS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SMULTIPLICITY__MIN_OCCURS));
			if (transientValues.isValueTransient(semanticObject, SmsPackage.Literals.SMULTIPLICITY__MAX_OCCURS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmsPackage.Literals.SMULTIPLICITY__MAX_OCCURS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSMultiplicityAccess().getMinOccursINTTerminalRuleCall_1_0(), semanticObject.getMinOccurs());
		feeder.accept(grammarAccess.getSMultiplicityAccess().getMaxOccursMULTIPLICITYParserRuleCall_3_0(), semanticObject.getMaxOccurs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SType returns SPrimitive
	 *     SPrimitive returns SPrimitive
	 *
	 * Constraint:
	 *     (deductionRule=SDeductionRule | (name=ID (redefines=[SPrimitive|ID] | realizes=[DPrimitive|SQualifiedName])* constraints+=SConstraint*))
	 */
	protected void sequence_SPrimitive(ISerializationContext context, SPrimitive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SQueryParameter returns SQueryParameter
	 *
	 * Constraint:
	 *     (name=ID type=[SType|ID] multiplicity=SMultiplicity?)
	 */
	protected void sequence_SQueryParameter(ISerializationContext context, SQueryParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SFeature returns SQuery
	 *     SQuery returns SQuery
	 *
	 * Constraint:
	 *     (name=ID (parameters+=SQueryParameter parameters+=SQueryParameter*)? type=[SType|ID] multiplicity=SMultiplicity? returns=SExpression?)
	 */
	protected void sequence_SQuery(ISerializationContext context, SQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     STransform returns SSpoofTransform
	 *     SSpoofTransform returns SSpoofTransform
	 *
	 * Constraint:
	 *     {SSpoofTransform}
	 */
	protected void sequence_SSpoofTransform(ISerializationContext context, SSpoofTransform semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
