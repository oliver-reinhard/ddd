grammar com.mimacom.ddd.sm.sms.Sms with org.eclipse.xtext.common.Terminals

import "http://www.mimacom.com/ddd/sm/sms/Sms"
import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SDomain:
	'domain'
	name=SQualifiedName
//	(description=DRichText)?
	(imports+=SImport)*
	(types+=SType |	aggregates+=SAggregate)*;

SImport:
	'import' importedNamespace=SQualifiedNameWithWildcard;
	
SDeductionRule:
	source=[DNamedElement|SQualifiedName]
	transform=STransform
;

SMemberDeductionRule:
	source=[DNamedElement|ID] //SQualifiedName]
	transform=STransform
;

STransform:
	SSpoofTransform | SMorphTransform;
	
SSpoofTransform:
	{SSpoofTransform}
	'spoof';
	
SMorphTransform:
	{SMorphTransform} 
	'morph'
	('name' '=' renameTo=ID)? 
	('type' '=' retypeTo=[SType|ID] (remultiplyTo=SMultiplicity)?)?;	

SAggregate:
	{SAggregate}
	'aggregate'
//	(description=DRichText)?
	'{'
		( types+=SType)*
	'}';

/*
 * TYPES
 */
SType:
	SPrimitive | SEnumeration | SRootType | SDetailType;
	
	
SConstraint returns SCondition:
	'constraint'
	name=ID
	':'
	condition=SExpression;
//	(description=DRichText)?;

SPrimitive:
	(	'deduced' 'primitive'
		deductionRule=SDeductionRule
	|	'primitive'
		name=ID
		//(description=DRichText)?
		'{'
			('redefines' redefines=[SPrimitive])? & ('realizes' realizes=[DPrimitive|SQualifiedName])?
			(constraints+=SConstraint)*
		'}'
	);

SEnumeration:
	'enumeration'
	name=ID
//	(description=DRichText)?
	'{'
	 	(literals+=SLiteral (',' literals+=SLiteral)*)?
		(constraints+=SConstraint)*
	 '}';

SLiteral:
	name=ID;
//	(description=DRichText)?;

SRootType:
	(	'deduced' (abstract?='abstract')? 'root' 
		deductionRule=SDeductionRule
	|
		(abstract?='abstract')? 	'root'
		name=ID
	)
	SComplexType;

SDetailType:
	(	'deduced' (abstract?='abstract')? 'detail' 
		deductionRule=SDeductionRule
	|
		(abstract?='abstract')? 'detail'
		name=ID
	)
	SComplexType;

fragment SComplexType:
	('extends' superType=[SComplexType|ID])?
//	(description=DRichText)?
	'{'
		(features+=SFeature | constraints+=SConstraint)*
	'}';
	
SFeature:
	SAssociation |  SAttribute | SQuery;

SAssociation:
	(derived?='derived')? 
	(kind=SAssociationKind | (kind=SAssociationKindInverse "composite"))
	name=ID
	':'
	type=[SRootType|ID]  (multiplicity=SMultiplicity)?;
//	(description=DRichText)?;

enum SAssociationKind:
	REFERENCE="reference" | COMPOSITE="composite";

enum SAssociationKindInverse returns SAssociationKind:	
	 INVERSE_COMPOSITE="inverse";
	
SAttribute:
	(	'deduced' (detail?='detail')? 
		deductionRule=SMemberDeductionRule
	|
		(detail?='detail')?
		name=ID
		':'
		type=[SSimpleType|ID] 
		(multiplicity=SMultiplicity)?
		(key?='key')?
	);
//	(description=DRichText)?;

SQuery:
	name=ID
	'(' (parameters+=SQueryParameter ( "," parameters+=SQueryParameter)*)? ')'
	':' 
	type=[SType|ID]  (multiplicity=SMultiplicity)?
	('returns' ^returns=SExpression)?;
//	(description=DRichText)?;

SQueryParameter:
	name=ID 
	':' 
	type=[SType|ID]  (multiplicity=SMultiplicity)?;
//	(description=SRichText)?;

SExpression:
	expr=STRING;

SQualifiedNameWithWildcard: 
	SQualifiedName '.*'?;

SQualifiedName:
	ID ('.' ID)*;
	
SMultiplicity:
	'(' minOccurs=INT '..' maxOccurs=MULTIPLICITY ')';
	
MULTIPLICITY returns ecore::EInt:
	INT | '*';
	