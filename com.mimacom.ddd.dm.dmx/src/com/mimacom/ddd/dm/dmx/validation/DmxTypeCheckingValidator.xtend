/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.validation

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.BasePackage
import com.mimacom.ddd.dm.base.base.DExpression
import com.mimacom.ddd.dm.base.base.DFeature
import com.mimacom.ddd.dm.base.base.DQuery
import com.mimacom.ddd.dm.base.base.DType
import com.mimacom.ddd.dm.dmx.DmxAssignment
import com.mimacom.ddd.dm.dmx.DmxBinaryOperation
import com.mimacom.ddd.dm.dmx.DmxCallArguments
import com.mimacom.ddd.dm.dmx.DmxField
import com.mimacom.ddd.dm.dmx.DmxFilter
import com.mimacom.ddd.dm.dmx.DmxFunctionCall
import com.mimacom.ddd.dm.dmx.DmxListExpression
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation
import com.mimacom.ddd.dm.dmx.DmxPackage
import com.mimacom.ddd.dm.dmx.DmxPredicateWithCorrelationVariable
import com.mimacom.ddd.dm.dmx.DmxStringLiteral
import com.mimacom.ddd.dm.dmx.DmxTestContext
import com.mimacom.ddd.dm.dmx.DmxUnaryOperation
import com.mimacom.ddd.dm.dmx.DmxUtil
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check

import static com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DmxTypeCheckingValidator extends AbstractDmxValidator {

	@Inject extension DmxUtil
	@Inject extension DmxTypeDescriptorProvider
	@Inject extension DmxTypeComputer

	protected static val BASE = BasePackage.eINSTANCE
	protected static val DMX = DmxPackage.eINSTANCE

	protected static val TYPE_MISMATCH = "Type Mismatch"
	protected static val NO_EXPRESSION = "No Expression"
	protected static val COMPARABLE_TYPES = (Lists.newArrayList(NUMBER, TEXT,
		TIMEPOINT) as Object) as List<AbstractDmxTypeDescriptor<?>>
	protected static val NO_INDEX = -1

	@Check
	def checkFeatureNavigationOfCollection(DmxMemberNavigation nav) {
		val member = nav.member
		if (member instanceof DFeature) {
			val preceding = nav.precedingNavigationSegment
			val type = getTypeAndCheckNotNull(preceding, DMX.dmxMemberNavigation_PrecedingNavigationSegment)
			if (type.isCollection) {
				error("Cannot navigate a feature of a collection of objects.", nav, DMX.dmxMemberNavigation_Member)
			}
		}
	}

	@Check
	def checkQueryParameters(DmxMemberNavigation actual) {
		val formal = actual.member
		if (formal instanceof DQuery) {
			val actualParameters = actual.nullSafeCallArguments

			for (var fIndex = 0; fIndex < formal.parameters.size; fIndex++) {
				val aIndex = fIndex
				if (aIndex < actualParameters.size) {
					val formalParamType = formal.parameters.get(fIndex).type
					val expectedType = if (formalParamType !== null) {
							formalParamType.getTypeDescriptor(formal.parameters.get(fIndex).collection)
						} else {
							UNDEFINED_TYPE
						}
					expectType(actualParameters.get(aIndex), expectedType, DMX.dmxMemberNavigation_CallArguments)

				} else if (aIndex == actualParameters.size) {
					errorParameterValuesMissing(actual, actual.callArguments, aIndex)
				}
			}
			checkTooManyActualParameters(formal.parameters.size, actual.callArguments)
		}
	}

	@Check
	def checkFilterParameters(DmxMemberNavigation actual) {
		val formal = actual.member
		if (formal instanceof DmxFilter) {
			val actualParameters = actual.nullSafeCallArguments
			// the first formal parameter (index 0) is not passed as a value but is the preceding segment in the navigation.
			// => match formal(1) with actual(0), formal(2) with actual(1), etc.
			for (var fIndex = 1; fIndex < formal.parameters.size; fIndex++) {
				val aIndex = fIndex - 1
				if (aIndex < actualParameters.size) {
					expectFilterParameterType(formal, fIndex, actualParameters, aIndex,
						DMX.dmxMemberNavigation_CallArguments)

				} else if (aIndex == actualParameters.size) {
					errorParameterValuesMissing(actual, actual.callArguments, aIndex)
				}
			}
			checkTooManyActualParameters(formal.parameters.size - 1, actual.callArguments)
		}
	}

	@Check
	def checkFunctionParameters(DmxFunctionCall actual) {
		val DmxFilter formal = actual.function
		if (formal !== null) {
			val actualParameters = actual.nullSafeCallArguments
			for (var fIndex = 0; fIndex < formal.parameters.size; fIndex++) {
				val aIndex = fIndex
				if (fIndex < actualParameters.size) {
					expectFilterParameterType(formal, fIndex, actualParameters, aIndex,
						DMX.dmxFunctionCall_CallArguments)

				} else if (fIndex == actualParameters.size) {
					errorParameterValuesMissing(actual, actual.callArguments, aIndex)
				}
			}
			checkTooManyActualParameters(formal.parameters.size, actual.callArguments)
		}
	}

	protected def boolean expectFilterParameterType(DmxFilter formal, int fIndex, List<DExpression> actualParameters,
		int aIndex, EReference ref) {
		val formalParamTypeDesc = formal.parameters.get(fIndex).typeDesc
		val actualType = getTypeAndCheckNotNull(actualParameters.get(aIndex), ref)
		expectType(actualType, formalParamTypeDesc.typeDescriptors, ref)
	}

	protected def void errorParameterValuesMissing(EObject context, DmxCallArguments actualParameters, int aIndex) {
		val message = "Mandatory parameter values missing."
		if (actualParameters === null || actualParameters.arguments.empty) {
			switch context {
				DmxMemberNavigation: error(message, context, DMX.dmxMemberNavigation_Member)
				DmxFunctionCall: error(message, context, DMX.dmxFunctionCall_Function)
				default: throw new IllegalArgumentException(context.eClass.name)
			}

		} else {
			error(message, actualParameters, DMX.dmxCallArguments_Arguments, aIndex - 1)
		}
	}

	protected def void checkTooManyActualParameters(int formalParametersSize, DmxCallArguments actualParameters) {
		if (actualParameters !== null) {
			for (var aIndex = formalParametersSize; aIndex < actualParameters.arguments.size; aIndex++) {
				error("More actual parameters than formal parameters.", actualParameters,
					DMX.dmxCallArguments_Arguments, aIndex)
			}
		}
	}

	def checkType(DmxPredicateWithCorrelationVariable expr) {
		expectBoolean(expr.predicate, DMX.dmxPredicateWithCorrelationVariable_Predicate)
	}

	@Check
	def checkType(DmxBinaryOperation expr) {
		val leftType = getTypeAndCheckNotNull(expr.leftOperand, DMX.dmxBinaryOperation_LeftOperand)
		val rightType = getTypeAndCheckNotNull(expr.rightOperand, DMX.dmxBinaryOperation_RightOperand)
		if (leftType == UNDEFINED_TYPE || rightType == UNDEFINED_TYPE) {
			// don't compare, it's useless and will only generate more validation errors
			return
		}
		switch expr.operator {
			case OR,
			case XOR,
			case AND,
			case DOUBLE_ARROW /* logical "implies" */ : {
				expectBoolean(leftType, DMX.dmxBinaryOperation_LeftOperand)
				expectBoolean(rightType, DMX.dmxBinaryOperation_RightOperand)
			}
			case EQUAL,
			case NOT_EQUAL: {
				if (leftType.isCompatibleWith(TIMEPOINT)) {
					// allow string literals as Timepoints 
					expectTimepointValue(expr.rightOperand, rightType, leftType, DMX.dmxBinaryOperation_RightOperand)
				} else if (leftType.collection && rightType == UNDEFINED_TYPE_COLLECTION) {
					// support empty list as a comparison value; type compatibility not applicable (empty list has no type)
				} else {
					// left and right types have to be compatible but no restriction on what kind of type
					expectType(rightType, leftType, DMX.dmxBinaryOperation_RightOperand)
				}
			}
			case LESS,
			case LESS_OR_EQUAL,
			case GREATER_OR_EQUAL,
			case GREATER: {
				if (leftType.isCompatibleWith(TIMEPOINT)) {
					// allow string literals as Timepoints 
					expectTimepointValue(expr.rightOperand, rightType, leftType, DMX.dmxBinaryOperation_RightOperand)
				} else if (expectType(leftType, COMPARABLE_TYPES, DMX.dmxBinaryOperation_LeftOperand)) {
					expectType(rightType, leftType, DMX.dmxBinaryOperation_RightOperand)
				} else {
					expectType(rightType, COMPARABLE_TYPES, DMX.dmxBinaryOperation_LeftOperand)
				}
			}
			case ADD: {
				if (isTimepointValue(expr.leftOperand, leftType)) {
					// TIMEPOINT + NUMBER => TIMEPOINT
					expectNumber(rightType, DMX.dmxBinaryOperation_RightOperand)
				} else if (leftType == TEXT) {
					expectType(rightType, COMPARABLE_TYPES, DMX.dmxBinaryOperation_LeftOperand)
				} else {
					expectNumber(leftType, DMX.dmxBinaryOperation_LeftOperand)
					expectNumber(rightType, DMX.dmxBinaryOperation_RightOperand)
				}
			}
			case SUBTRACT: {
				if (isTimepointValue(expr.leftOperand, leftType)) {
					// TIMEPOINT - TIMEPOINT => NUMBER
					if (! isTimepointValue(expr.rightOperand, rightType)) {
						// TIMEPOINT - NUMBER => TIMEPOINT
						expectNumber(rightType, DMX.dmxBinaryOperation_RightOperand)
					}
				} else {
					expectNumber(leftType, DMX.dmxBinaryOperation_LeftOperand)
					expectNumber(rightType, DMX.dmxBinaryOperation_RightOperand)
				}
			}
			case MULTIPLY,
			case DIVIDE,
			case POWER,
			case MODULO: {
				expectNumber(leftType, DMX.dmxBinaryOperation_LeftOperand)
				expectNumber(rightType, DMX.dmxBinaryOperation_RightOperand)
			}
			case IN: {
				var hasError = false
				if (leftType.collection) {
					error("Cannot be a collection", expr, DMX.dmxBinaryOperation_LeftOperand)
					hasError = true
				}
				if (! rightType.collection) {
					error("Must be a collection", expr, DMX.dmxBinaryOperation_RightOperand)
					hasError = true
				}
				if (! hasError) {
					expectType(rightType, leftType.toFromCollection(true), DMX.dmxBinaryOperation_RightOperand)
				}
			}
			case UNTIL: {
				expectType(rightType, leftType, DMX.dmxBinaryOperation_RightOperand)
			}
			case SINGLE_ARROW: {
				throw new UnsupportedOperationException(expr.operator.literal) // TODO no semantics yet
			}
		}
	}

	@Check
	def checkType(DmxUnaryOperation expr) {
		val expectedType = getTypeAndCheckNotNull(expr, DMX.dmxUnaryOperation_Operand)
		expectType(expr.operand, expectedType, DMX.dmxUnaryOperation_Operand) // Note: unary operator: not applicable to STRING
	}

	@Check
	def checkType(DmxListExpression expr) {
		if (expr.elements.size <= 1) return // this is an empty list or a list with just one element
		val expectedType = getTypeDescAndCheckNotNull(expr.elements.head, DMX.dmxListExpression_Elements, 0)
		for (var i = 1; i < expr.elements.size; i++) {
			expectType(expr.elements.get(i), expectedType, DMX.dmxListExpression_Elements, i)
		}
	}

	@Check
	def checkType(DmxTestContext expr) {
		if (expr.value !== null) {
			val expectedType = getTypeDescAndCheckNotNull(expr.type, expr.collection, BASE.DNavigableMember_Type)
			if (expectedType == UNDEFINED_TYPE) {
				// don't look at value, it's useless and will only generate more validation errors
				return
			}
			expectType(expr.value, expectedType, DMX.dmxTestContext_Value)
		}
	}

	@Check
	def checkType(DmxAssignment expr) {
		val target = expr.assignToMember
		val targetType = getTypeDescAndCheckNotNull(target.type, target.collection, BASE.DNavigableMember_Type)
		if (targetType == UNDEFINED_TYPE) {
			// don't look at value, it's useless and will only generate more validation errors
			return
		}
		if (targetType.isCompatibleWith(TIMEPOINT)) {
			// allow string literals as Timepoints 
			val actualType = getTypeAndCheckNotNull(expr.value, DMX.dmxAssignment_Value)
			expectTimepointValue(expr.value, actualType, targetType, DMX.dmxAssignment_Value)
		} else if (expr.value instanceof DmxListExpression && (expr.value as DmxListExpression).elements.isEmpty) {
			// support empty list as a value
		} else {
			// left and right types have to be compatible but no restriction on what kind of type
			expectType(expr.value, targetType, DMX.dmxAssignment_Value)
		}
	}

	@Check
	def checkType(DmxField expr) {
		val featureType = typeFor(expr)
		val valueType = getTypeAndCheckNotNull(expr.value, DMX.dmxField_Value)
		if (featureType.isCompatibleWith(TIMEPOINT)) {
			// allow string literals as Timepoints 
			val actualType = getTypeAndCheckNotNull(expr.value, DMX.dmxField_Value)
			expectTimepointValue(expr.value, actualType, featureType, DMX.dmxField_Value)
		} else if (featureType.isCompatibleWith(IDENTIFIER)) {
			// allow number literals as identifiers 
			expectType(expr.value, NUMBER, DMX.dmxField_Value)
		} else if (featureType.collection && valueType == UNDEFINED_TYPE_COLLECTION) {
			// support empty list as field value; type compatibility not applicable (empty list has no type)
		} else {
			expectType(expr.value, featureType, DMX.dmxField_Value)
		}
	}

	@Check
	def checkFieldKind(DmxField f) {
		if (f.feature !== null && f.feature instanceof DQuery) {
			error("Cannot assign a value to a query", f, DMX.dmxField_Feature)
		}
	}

	//
	// Check type conformance:
	//
	protected def AbstractDmxTypeDescriptor<?> getTypeDescAndCheckNotNull(DExpression expr, EReference ref, int index) {
		if (expr === null) {
			error("Expression is null", expr, ref, NO_EXPRESSION)
			return UNDEFINED_TYPE
		}
		val typeDesc = expr.typeFor
		if (typeDesc === null) {
			val errorText = "Type is null"
			if (index == NO_INDEX) {
				error(errorText, expr, ref, TYPE_MISMATCH)
			} else {
				error(errorText, expr, ref, index, TYPE_MISMATCH)
			}
			return UNDEFINED_TYPE
		}
		return typeDesc
	}

	protected def AbstractDmxTypeDescriptor<?> getTypeDescAndCheckNotNull(DType type, boolean collection,
		EReference ref) {
		if (type === null || type.eIsProxy) {
			error("Unresolved type reference", ref, TYPE_MISMATCH)
			return UNDEFINED_TYPE
		}
		val typeDesc = getTypeDescriptor(type, collection)
		if (typeDesc === null) {
			error("Undefined type", ref, TYPE_MISMATCH)
			return UNDEFINED_TYPE
		}
		return typeDesc
	}

	protected def expectBoolean(DExpression expr, EReference ref) {
		return expectType(expr, BOOLEAN, ref)
	}

	protected def expectBoolean(AbstractDmxTypeDescriptor<?> actualType, EReference ref) {
		return expectType(actualType, BOOLEAN, ref)
	}

	protected def expectNumber(DExpression expr, EReference ref) {
		return expectType(expr, NUMBER, ref)
	}

	protected def expectNumber(AbstractDmxTypeDescriptor<?> actualType, EReference ref) {
		return expectType(actualType, NUMBER, ref)
	}

	protected def expectTimepointValue(DExpression actualExpression, AbstractDmxTypeDescriptor<?> actualType,
		AbstractDmxTypeDescriptor<?> expectedType, EReference ref) {
		if (actualExpression instanceof DmxStringLiteral) {
			if (parseTimepoint(actualExpression.value) === null) {
				error("Invalid Timepoint format, should be: " + DmxUtil::TIMEPOINT_SYNTAX, actualExpression,
					DMX.dmxStringLiteral_Value)
			}
		} else {
			expectType(actualType, expectedType, ref)
		}
	}

	protected def expectType(DExpression expr, AbstractDmxTypeDescriptor<?> expectedType, EReference ref, int index) {
		val actualType = getTypeDescAndCheckNotNull(expr, ref, index)
		return expectType(actualType, expectedType, ref, index)
	}

	// Convenience method:
	protected def expectType(DExpression expr, AbstractDmxTypeDescriptor<?> expectedType, EReference ref) {
		return expectType(expr, expectedType, ref, NO_INDEX)
	}

	protected def expectType(AbstractDmxTypeDescriptor<?> actualType, AbstractDmxTypeDescriptor<?> expectedType,
		EReference ref, int index) {
		if (actualType.isCompatibleWith(expectedType)) {
			return true
		}
		val errorText = "Expected " + expectedType.displayName + " type, but was " + actualType.displayName
		if (index == NO_INDEX) {
			error(errorText, ref, TYPE_MISMATCH)
		} else {
			error(errorText, ref, index, TYPE_MISMATCH)
		}
		return false
	}

	// Convenience method:
	protected def expectType(AbstractDmxTypeDescriptor<?> actualType, AbstractDmxTypeDescriptor<?> expectedType,
		EReference ref) {
		expectType(actualType, expectedType, ref, NO_INDEX)
	}

	protected def expectType(AbstractDmxTypeDescriptor<?> actualType, List<AbstractDmxTypeDescriptor<?>> expectedTypes,
		EReference ref) {
		for (e : expectedTypes) {
			if (e.isCompatibleWith(actualType)) {
				return true
			}
		}
		error("Expected one of " + expectedTypes.map[displayName] + " types, but was " + actualType.displayName, ref,
			TYPE_MISMATCH)
		return false
	}

	// Convenience method:
	protected def AbstractDmxTypeDescriptor<?> getTypeAndCheckNotNull(DExpression expr, EReference ref) {
		return getTypeDescAndCheckNotNull(expr, ref, NO_INDEX)
	}
}
