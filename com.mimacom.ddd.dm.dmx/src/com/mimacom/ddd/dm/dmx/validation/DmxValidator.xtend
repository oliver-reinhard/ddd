/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.validation

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DEntityType
import com.mimacom.ddd.dm.base.DFeature
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DRichText
import com.mimacom.ddd.dm.dmx.DmxAssignment
import com.mimacom.ddd.dm.dmx.DmxContextReference
import com.mimacom.ddd.dm.dmx.DmxFilter
import com.mimacom.ddd.dm.dmx.DmxListExpression
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation
import com.mimacom.ddd.dm.dmx.DmxUtil
import com.mimacom.ddd.dm.styledText.parser.ErrorMessageAcceptor
import org.eclipse.xtext.validation.Check
import com.mimacom.ddd.dm.dmx.DmxRichTextUtil

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DmxValidator extends DmxTypeCheckingValidator implements ErrorMessageAcceptor {

	@Inject extension DmxUtil 
	@Inject extension DmxRichTextUtil

	@Check
	def checkAssignmentTarget(DmxAssignment a) {
		if (a.precedingNavigationSegment === null) {
			error("Assignment target must be an attribute of a complex type.", a, DMX.dmxAssignment_AssignToMember)
		} else if (a.assignToMember instanceof DQuery) {
			error("Cannot assign a value to a query.", a, DMX.dmxAssignment_AssignToMember)
		}
	}

	@Check
	def checkFilterParameters(DmxFilter f) {
		if (f.typeDesc.isMultiTyped && ! f.parameters.exists[t|t.typeDesc !== null && t.typeDesc.isMultiTyped]) {
			error("For a multi-typed return type, there must be a parameter supporting the same types.", f, BASE.DNamedElement_Name, 0)
		}
	}

	@Check
	def checkUseOfAllQualifier(DmxContextReference ref) {
		if (ref.all && !(ref.target instanceof DComplexType)) {
			error("'all' qualifier is only supported after a static type reference.", ref, DMX.dmxContextReference_All)
		}
	}

	@Check
	def checkNavigationOfStaticTypeReference(DmxMemberNavigation nav) {
		if (nav.member instanceof DFeature) {
			val preceding = nav.precedingNavigationSegment
			if (preceding instanceof DmxContextReference && (preceding as DmxContextReference).target instanceof DComplexType) {
				error("Cannot navigate a feature from a static type reference. Use [[Type#feature]] syntax inside RichStrings.", nav, DMX.dmxMemberNavigation_Member)
			}
		}
	}

	@Check
	def checkNoStateFeature(DEntityType e) {
		val superTypes = e.typeHierarchy
		if (! e.states.empty || superTypes.exists(t|t instanceof DEntityType && ! (t as DEntityType).states.empty)) {
			for (f : e.features) {
				if (f.name == DmxUtil::ENTITY_TYPE_STATE_FILTER_NAME) {
					error("Cannot declare a 'state' feature while states are declared for this type or for one of its super types.", f, BASE.DNamedElement_Name)
				}
			}
			if (e.superType !== null && e.superType.allFeatures.exists[name == DmxUtil::ENTITY_TYPE_STATE_FILTER_NAME]) {
				error("Cannot have an inherited 'state' feature while states are declared for this type.", e, BASE.DNamedElement_Name)
			}
		}
	}

	@Check
	def checkNestedLists(DmxListExpression expr) {
		for (e : expr.elements) {
			if (e instanceof DmxListExpression) {
				error("Cannot nest lists", expr, DMX.dmxListExpression_Elements)
			}
		}
	}
	
	@Check
	def checkRichTextFormatting(DRichText rt) {
		rt.parse(this)
	}
	
	override acceptError(String message, int offset, int length) {
		val current = getCurrentObject()
		messageAcceptor.acceptError(message, current, offset, length, null);
	}
	
}
