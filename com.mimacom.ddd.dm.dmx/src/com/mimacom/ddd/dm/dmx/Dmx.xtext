grammar com.mimacom.ddd.dm.dmx.Dmx hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.mimacom.com/ddd/dm/base"
import "http://www.mimacom.com/ddd/dm/dmx" 

DmxNamespace:
	(imports+=DImport)*
	'namespace'
	name=DQualifiedName
	(types+=DmxArchetype)*
	(filters+=DmxFilter)* 
	// For unit-testing purposes:
	(tests+=DmxTest)*;
	
DImport:
	'import' importedNamespace=DQualifiedNameWithWildcard;	

/* 
 * Testing
 */
DmxTest:
	'test'
	name=ID
	(	'context'	
		context+=DmxTestContext (',' context+=DmxTestContext)*
	)?
	'{'
	expr=DExpression
	'}';

DmxTestContext returns DContext:
	name=ID
	':'
	type=[DType|ID] (multiplicity=DMultiplicity)?;	
	
/* 
 * Language base: archetypes & filters
 */
enum DmxBaseType:
	VOID | BOOLEAN | NUMBER | TEXT | IDENTIFIER | TIMEPOINT | COMPLEX | ACTOR /*notified */ | SERVICE /*invoked* */;
	
DmxArchetype:
	'archetype'
	name=ID
	'is'
	baseType=DmxBaseType
	(description=DRichText)?;
	
DmxFilter:
	DmxFunction | DmxIterator;

DmxFunction:
	'function' name=ID 
	'(' (parameters+=DmxFunctionParameter (','  parameters+=DmxFunctionParameter)*)? ')'
	':'
	baseType=DmxBaseType
	(baseTypeCollection?='*')?;

DmxFunctionParameter:
	name=ID
	':'
	baseType=DmxBaseType
	(baseTypeCollection?='*')?;

DmxIterator:
	'iterator' name=ID
	':'
	baseType=DmxBaseType
	(baseTypeCollection?='*')?;

/*
 * Expressions
 */

DExpression returns DExpression :
	DAssignment | DPredicate | DRichText;
	
DRichText:
	segments+=DTextOnly
	|
	(	segments+= DTextStart
		segments+= DExpression 
		(segments+=DTextMiddle  segments+=DExpression)* 
		segments+= DTextEnd
	);

DTextOnly returns DTextSegment:		value=PLAIN_TEXT_ONLY;
DTextStart returns DTextSegment:		value=PLAIN_TEXT_START;
DTextMiddle returns DTextSegment:	value=PLAIN_TEXT_MIDDLE;
DTextEnd returns DTextSegment:		value=PLAIN_TEXT_END;

DNavigableMemberReference returns DExpression:
	DPrimaryExpression
	(	=> ({DAssignment.memberContainer=current} '.' assignToMember=[DNavigableMember|ID] OpSingleAssign) value=DOrExpression
	| 	=> ({DmxMemberNavigation.precedingNavigationSegment=current} '.')
		member=[DNavigableMember|ID] 
		(
			(	=> explicitOperationCall?='(' // => boolean => has 0.n explicit arguments
				(
					memberCallArguments+=DPredicate (',' memberCallArguments+=DPredicate)*
				)?
				')'
			)
			|
			before?="@before"
		)?
	)*;

DAssignment returns DExpression :
	{DAssignment}
	assignToMember=[DNavigableMember|ID] OpSingleAssign value=DOrExpression;

OpSingleAssign:
	':=';

DPredicate returns DExpression :
	(	{DPredicate} 
		var=DPredicateContext
		'|'
		value=DOrExpression
	|	DOrExpression
	);

DPredicateContext returns DContext:
	name=ID
	(':' type=[DType])?;
	
DOrExpression returns DExpression:
	DAndExpression
	(=> ({DBinaryOperation.leftOperand=current} operator=OpOr) rightOperand=DAndExpression)*;

enum OpOr returns DBinaryOperator:
	OR='OR' | OR='or' | XOR='XOR' | XOR='xor';

DAndExpression returns DExpression:
	DEqualityExpression
	(=>({DBinaryOperation.leftOperand=current} operator=OpAnd) rightOperand=DEqualityExpression)*;

enum OpAnd returns DBinaryOperator:
	AND='AND' | AND='and';

DEqualityExpression returns DExpression:
	DRelationalExpression 
	(=> ({DBinaryOperation.leftOperand=current} operator=OpEquality)	rightOperand=DRelationalExpression)*;

enum OpEquality returns DBinaryOperator:
	EQUAL='=' | NOT_EQUAL='!=' | NOT_EQUAL='<>';

DRelationalExpression returns DExpression:
	DOtherOperatorExpression
	(	=> ({DInstanceOfExpression.expression=current} OpInstanceOf) type=[DType]
	|	=> ({DBinaryOperation.leftOperand=current} operator=OpCompare) rightOperand=DOtherOperatorExpression
	)*;

OpInstanceOf:
	'ISA' | 'isa';
	
enum OpCompare returns DBinaryOperator:
	LESS= '<' | LESS_OR_EQUAL= '<=' | LESS_OR_EQUAL='≤' | GREATER_OR_EQUAL='>=' | GREATER_OR_EQUAL='≥' | GREATER='>';

DOtherOperatorExpression returns DExpression:
	DAdditiveExpression
	(=>({DBinaryOperation.leftOperand=current} operator=OpOther) rightOperand=DAdditiveExpression)*;

enum OpOther returns DBinaryOperator:
	UNTIL='..' | SINGLE_ARROW= '->' | DOUBLE_ARROW='=>';

DAdditiveExpression returns DExpression:
	DMultiplicativeExpression
	(=>({DBinaryOperation.leftOperand=current} operator=OpAdd) rightOperand=DMultiplicativeExpression)*;

enum OpAdd returns DBinaryOperator:
	ADD='+' | SUBTRACT='-';

DMultiplicativeExpression returns DExpression:
	DUnaryOperation
	(=>({DBinaryOperation.leftOperand=current} operator=OpMulti) rightOperand=DUnaryOperation)*;

enum OpMulti returns DBinaryOperator:
	MULTIPLY='*' | DIVIDE='/' | POWER='**' | MODULO='%';

DUnaryOperation returns DExpression:
	{DUnaryOperation}
	operator=OpUnary operand=DUnaryOperation
	| DCastExpression;

enum OpUnary returns DUnaryOperator:
	PLUS='+' | MINUS='-' | NOT='!' | NOT='NOT' | NOT='not' ;

DCastExpression returns DExpression:
	DNavigableMemberReference (=>({DCastExpression.target=current} OpCast) type=[DType])?;
	
OpCast:
	'AS' | 'as';
	
DPrimaryExpression returns DExpression:
	DLiteralExpression |
	DSelfExpression |
	DReturnExpression |
	DRaiseExpression |
	DParenthesizedExpression |
	DFunctionCall |
	DConstructorCall |
	DmxStaticReference |
	DmxContextReference |
	DIfExpression |
	DForLoopExpression;
	
DLiteralExpression returns DExpression:
	DBooleanLiteral |
	DStringLiteral |
	DNaturalLiteral |
	DDecimalLiteral |
	DUndefinedLiteral;
	
DSelfExpression returns DExpression :
	{DSelfExpression}
	('SELF' | 'self');
		
DReturnExpression returns DExpression :
	{DReturnExpression}
	('RETURN' | 'return') (->expression=DExpression)?;
	
DRaiseExpression returns DExpression :
	{DRaiseExpression}
	('RAISE' | 'raise') expression=DExpression;
	
DParenthesizedExpression returns DExpression:
	'(' DExpression ')';

//
// TODO remove or rename to DQueryCall and change reference
//
DFunctionCall returns DExpression:
	{DFunctionCall}
	function=[DmxFunction|ID]
	'('
		(
			functionCallArguments+=DExpression (',' functionCallArguments+=DExpression)*
		)?
	')';
	
DConstructorCall returns DExpression:
	{DConstructorCall}
	OpConstructor constructor=[DComplexType|ID]
	(=> explicitConstructorCall?='(' // => boolean => has 0.n explicit arguments
		(
			arguments+=DExpression (',' arguments+=DExpression)*
		)?
	')')?;

OpConstructor:
	'NEW' | 'new';
		
DmxStaticReference returns DExpression:
	{DmxStaticReference}
	'['
	target=[IStaticReferenceTarget|DQualifiedName]
	('#' member=[DNavigableMember|ID])?
	("|" (displayName=ID | plural?="*"))?
	(-> ']') ; // '->' gives precedence to this ']' over PLAIN_TEXT_MIDDLE ('=>' works too but generates more lookahead overhead)
		
DmxContextReference returns DExpression:
	{DmxContextReference}
	target=[DNamedElement|ID] 
	(	before?="@before"
	|	'.' all?='all'
	)?;
	
DIfExpression returns DExpression:
	{DIfExpression}
	'if' if=DExpression
	'then' then=DExpression
	(=> 'else' else=DExpression)?
	'end';
	
DForLoopExpression returns DExpression:
	=>({DForLoopExpression}
	'for' declaredParam=ID ':') forExpression=DExpression 'do'
	eachExpression=DExpression
	'end';
	
DMultiplicity:
	'(' minOccurs=NATURAL '..' maxOccurs=MULTIPLICITY ')';
	
MULTIPLICITY returns ecore::EInt:
	NATURAL | '*';
	
DBooleanLiteral returns DExpression: {DBooleanLiteral} (value?='TRUE' | value?='true' | 'FALSE' | 'false');
DNaturalLiteral returns DExpression: {DNaturalLiteral} value=NATURAL;
DDecimalLiteral returns DExpression: {DDecimalLiteral} value=DECIMAL;
DStringLiteral returns DExpression: {DStringLiteral} value=STRING;
DUndefinedLiteral returns DExpression: {DUndefinedLiteral} ('UNDEFINED' | 'undefined');

DECIMAL returns ecore::EString: NATURAL '.' NATURAL (('E'|'e')  ('+'|'-')? NATURAL)?;

DQualifiedNameWithWildcard: 
	DQualifiedName '.*'?;

DQualifiedName:
	ID ('.' ID)*;
	
terminal ID: '^'?(LETTER|'_') (LETTER|'_'|'0'..'9')*;
terminal STRING:	'"' ( '\\' . | !('\\'|'"') )* '"';
terminal NATURAL returns ecore::EInt: '0'..'9'+;
terminal fragment LETTER:'a'..'z'|'A'..'Z'|'\u00c0'..'\u00d6'|'\u00d8'..'\u00f6'|'\u00f8'..'\u00ff'; // Latin characters '\uc380'..'\uc396'|'\uc398'..'\uc3b6'|'\uc3b8'..'\uc3bf'

terminal fragment PLAIN_TEXT:	!('»' | ']' | '[');
terminal PLAIN_TEXT_ONLY:		'«' PLAIN_TEXT* '»';
terminal PLAIN_TEXT_START:		'«' PLAIN_TEXT* '[';
terminal PLAIN_TEXT_MIDDLE:	']'  PLAIN_TEXT* '[';
terminal PLAIN_TEXT_END:			']'  PLAIN_TEXT* '»';

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;

terminal ANY_OTHER: .;