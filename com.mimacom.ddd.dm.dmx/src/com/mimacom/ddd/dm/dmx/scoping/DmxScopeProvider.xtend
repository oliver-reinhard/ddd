/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.scoping

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DDomainEvent
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DService
import com.mimacom.ddd.dm.base.INavigableMemberContainer
import com.mimacom.ddd.dm.dmx.DmxAssignment
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation
import com.mimacom.ddd.dm.dmx.DmxPackage
import com.mimacom.ddd.dm.dmx.DmxPredicateWithCorrelationVariable
import com.mimacom.ddd.dm.dmx.DmxStaticReference
import com.mimacom.ddd.dm.dmx.DmxTest
import com.mimacom.ddd.dm.dmx.DmxUtil
import com.mimacom.ddd.dm.dmx.indexing.DmxIndex
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import com.mimacom.ddd.dm.base.DAggregate

/**
 * This class contains custom scoping for expressions and {@link DComplexType} feature inheritance.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DmxScopeProvider extends AbstractDmxScopeProvider {
	
	@Inject extension DmxUtil
	@Inject extension DmxTypeComputer
	@Inject DmxIndex index

	static val BASE = BasePackage.eINSTANCE
	static val DMX = DmxPackage.eINSTANCE

	override IScope getScope(EObject context, EReference reference) {

		 if (reference == DMX.dmxContextReference_Target) {
		 	// This is classic scoping along the eContainer CONTAINMENT hiearchy:
			val outer = getDefaultScopeForType(context, BASE.IStaticReferenceTarget)
			val scope = getEContainersNavigableMembersScopes(context, outer)	
			return scope
		
		} else if (reference == DMX.dmxMemberNavigation_Member) {
			// This is a scoping along (the types of) a NAVIGATION expression tree:
			if (context instanceof DmxMemberNavigation) {
				val preceding = context.precedingNavigationSegment
				val typeDescriptor = preceding.typeFor
				val scope = typeDescriptor.getNavigableMembersAndIteratorsScope(context, index)
				return scope
			}

		} else if (reference == DMX.dmxAssignment_AssignToMember) {
			if (context instanceof DmxAssignment) {
				val preceding = context.precedingNavigationSegment
				val typeDescriptor = preceding.typeFor
				val scope = typeDescriptor.getNavigableMembersScope()  // exclude iterators
				return scope
			} else if (context instanceof DmxMemberNavigation) {
				val preceding = context.precedingNavigationSegment
				val typeDescriptor = preceding.typeFor
				val scope = typeDescriptor.getNavigableMembersScope() // exclude iterators
				return scope
			}
			
		} else if (reference == DMX.dmxStaticReference_Target) {
			val scope = getDefaultScopeForType(context, BASE.IStaticReferenceTarget)
			return scope

		} else if (reference == DMX.dmxStaticReference_Member) {
			if (context instanceof DmxStaticReference) {
				val target = context.target
				if (target instanceof INavigableMemberContainer ) {
					val scope = getEContainerNavigableMembersScopeSwitch(target, IScope.NULLSCOPE)
					return scope
				}
			}

		} else if (reference == DMX.dmxFunctionCall_Function) {
			val allFilters = index.allVisibleFilters(context)
			val scope = Scopes.scopeFor(allFilters, super.getScope(context, reference))
			return scope
		}

		return super.getScope(context, reference)
	}
	
	/*
	 * Obtains the default scope for the given reference, then narrows the result down to the given type.
	 */
	def IScope getDefaultScopeForType(EObject context, EClass type) {
		val reference = EcoreFactory.eINSTANCE.createEReference
		// Default scoping only uses the EType field of the reference:
		reference.EType = type
		val scope = super.getScope(context, reference)
		return scope
	}
	
	/* Returns all DNavigableMember elements of the given navigation member element along the MODEL eContainer hierarchy. */
	final protected def IScope getEContainersNavigableMembersScopes(EObject context, IScope outerScope) {
		var scope = outerScope
		var container = context.eContainer
		
		if (container === null) {
			return scope
		
		} else if (container instanceof INavigableMemberContainer) {
			scope = getEContainerNavigableMembersScopeSwitch(container, outerScope)
			
		} else if (container instanceof DmxMemberNavigation) {
			// a function or iterator call opens a new scope where the navigable members are in the precedingNavigationStep:
			if (container.memberCallArguments.contains(context)) {
				val typeDescriptor = container.precedingNavigationSegment.typeFor
				scope = typeDescriptor.getNavigableMembersScope(outerScope)
			}
		}
		return getEContainersNavigableMembersScopes(container, scope) // recursion
	}
	
	/**
	 * Overriders must ensure, that each type used as a discriminator in the switch statement implements  @INavigableMemberContainer, 
	 * otherwise this method will never be invoked.<p>
	 * Also, the elements included in the scope must implement @DNavigableMember.
	 */
	protected def IScope getEContainerNavigableMembersScopeSwitch(INavigableMemberContainer container, IScope outerScope) {
		val scope = switch container {
			DEnumeration: Scopes.scopeFor(container.literals, outerScope)
			DComplexType: Scopes.scopeFor(container.allFeatures(), outerScope)
			DQuery: Scopes.scopeFor(container.parameters, outerScope)
			DAggregate: Scopes.scopeFor(container.staticQueries, outerScope)
			DService: Scopes.scopeFor(container.parameters, outerScope)
			DDomainEvent: getDomainEventNavigableMemberScope(container, outerScope)
			DmxPredicateWithCorrelationVariable: Scopes.scopeFor(Lists.newArrayList(container.correlationVariable), outerScope)
			DmxTest: Scopes.scopeFor(container.context,  outerScope)
			default: outerScope
		}
		return scope
	}

	protected def IScope getDomainEventNavigableMemberScope(DDomainEvent event, IScope outerScope) {
		val list = Lists.newArrayList()
		list.addAll(event.context)
		
		if (event.trigger !== null) {
			list.add(event.trigger)
		}
		list.addAll(event.notifications)
		return Scopes.scopeFor(list, outerScope)
	}
	
	/*
	 * Obsolete
	 */
	/* Returns all DNavigableMember elements of the given navigation member element along the semantic EXPRESSION eContainer hierarchy. */
//	final protected def IScope getPrecedingNavigableMembersScopes(EObject member, IScope outerScope) {
//		val preceding = EcoreUtil2.getContainerOfType(member.eContainer, INavigableMemberContainer)
//		if (preceding === null) return outerScope
//		getEContainerNavigableMembersScopeSwitch(preceding, outerScope)
//	}

//	protected def IScope getNavigableMemberReferencesScope(EObject precedingNavigationStep) {
//		// NOTE: memberContainerReference is the predecessor in a NAVIGATION, i.e. the object that OWNS the member that shall be
//		// nagivated in this step, NOT the eContainer that owns the expression!
//	
//		if (precedingNavigationStep instanceof DmxContextReference) {
//			if (precedingNavigationStep.all) {
//				return getDefaultScopeForType(precedingNavigationStep, DMX.dmxIterator)
//			}
//			val memberContainer = precedingNavigationStep.target
//			val targetType = switch memberContainer {
//				DNavigableMember: memberContainer.getType 
//				DEnumeration: memberContainer // memberContainer.type is always null !
//				default: null
//			}
//			val scope = switch targetType {
//				DEnumeration: Scopes.scopeFor(targetType.literals) // type is null
//				DComplexType: getOwnAndInheritedFeaturesScope(targetType)
//				DQuery: Scopes.scopeFor(targetType.parameters)
//				DService: Scopes.scopeFor(targetType.parameters)
//				DDomainEvent: getDomainEventNavigableMemberScope(targetType, IScope.NULLSCOPE)
//				default: IScope.NULLSCOPE
//			}
//			return scope
//
//		} else if (precedingNavigationStep instanceof DSelfExpression) {
//			return getEContainersNavigableMembersScopes(precedingNavigationStep, IScope.NULLSCOPE)
//
//		} else if (precedingNavigationStep instanceof DmxMemberNavigation) {
//			val member = precedingNavigationStep.getMember
//			if (member instanceof DNavigableMember) {
//				val type = member.getType
//				if (type instanceof DComplexType) {
//					return getOwnAndInheritedFeaturesScope(type)
//				}
//			}
//
//		//
//		// TODO still needed?
//		//
//		} else if (precedingNavigationStep instanceof DFunctionCall) {
//			val filter = precedingNavigationStep.function
//			if (filter instanceof DmxFunction) {
//				val type = filter.getType
//				if (type instanceof DComplexType) {
//					return getOwnAndInheritedFeaturesScope(type)
//				}
//			} 
//		}
//		return IScope.NULLSCOPE
//	}
}
