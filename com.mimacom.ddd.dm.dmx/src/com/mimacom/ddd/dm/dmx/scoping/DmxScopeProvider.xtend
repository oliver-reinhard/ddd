/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.scoping

import com.google.common.collect.Lists
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DDomainEvent
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DFunction
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DService
import com.mimacom.ddd.dm.base.DTypedMember
import com.mimacom.ddd.dm.base.ITypedMemberContainer
import com.mimacom.ddd.dm.dmx.DAssignment
import com.mimacom.ddd.dm.dmx.DContextReference
import com.mimacom.ddd.dm.dmx.DFunctionCall
import com.mimacom.ddd.dm.dmx.DSelfExpression
import com.mimacom.ddd.dm.dmx.DTypedMemberReference
import com.mimacom.ddd.dm.dmx.DmxPackage
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping for expressions and {@link DComplexType} feature inheritance.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DmxScopeProvider extends AbstractDmxScopeProvider {

	static val bpackage = BasePackage.eINSTANCE
	static val xpackage = DmxPackage.eINSTANCE

	override IScope getScope(EObject context, EReference reference) {

		if (reference == xpackage.DContextReference_Target) {
			val outer = getDefaultScopeForType(context, bpackage.IPrimaryNavigationTarget)
			val scope = getExpressionContainerMemberScope(context, outer)
			return scope

		} else if (reference == xpackage.DTypedMemberReference_Member) {
			if (context instanceof DTypedMemberReference) {
				if (context.explicitOperationCall) {
					getDefaultScopeForType(context, bpackage.DFunction)
				} else {
					return getMemberReferenceScope(context.memberContainerReference)
				}
			}

		} else if (reference == xpackage.DAssignment_Member) {
			if (context instanceof DAssignment) {
				return getAssignmentMemberScope(context, reference)
			}
		}

		return super.getScope(context, reference)
	}
	
	/*
	 * Obtains the default scope for the given reference, then narrows the result down to the given type.
	 */
	def IScope getDefaultScopeForType(EObject context, EClass type) {
		val reference = EcoreFactory.eINSTANCE.createEReference
		// Default scoping only uses the EType field of the reference:
		reference.EType = type
		val scope = super.getScope(context, reference)
		return scope
	}

	protected def IScope getMemberReferenceScope(EObject memberContainerReference) {
	// NOTE: memberContainer is the predecessor in a NAVIGATION, i.e. the object that OWNS the member that shall be
	// nagivated in this step, NOT the eContainer that owns the expression!
	
		if (memberContainerReference instanceof DContextReference) {
			val memberContainer = memberContainerReference.target
			val targetType = switch memberContainer {
				DEnumeration: memberContainer // memberContainer.type is always null !
				DTypedMember: memberContainer.type 
				ITypedMemberContainer: memberContainer
				default: null
			}
			return switch targetType {
				DEnumeration: Scopes.scopeFor(targetType.literals) // type is null
				DComplexType: getInheritedFeaturesScope(targetType)
				DQuery: Scopes.scopeFor(targetType.parameters)
				DService: Scopes.scopeFor(targetType.parameters)
				DDomainEvent: getDomainEventMemberScope(targetType, IScope.NULLSCOPE)
				default: IScope.NULLSCOPE
			}

		} else if (memberContainerReference instanceof DSelfExpression) {
			return getExpressionContainerMemberScope(memberContainerReference, IScope.NULLSCOPE)

		} else if (memberContainerReference instanceof DTypedMemberReference) {
			val member = memberContainerReference.member
			if (member instanceof DTypedMember) {
				val type = member.type
				if (type instanceof DComplexType) {
					return getInheritedFeaturesScope(type)
				}
			}

		} else if (memberContainerReference instanceof DFunctionCall) {
			val function = memberContainerReference.function
			if (function instanceof DFunction) {
				val type = function.type
				if (type instanceof DComplexType) {
					return getInheritedFeaturesScope(type)
				}
			}
		}
		return IScope.NULLSCOPE
	}

	protected def IScope getAssignmentMemberScope(DAssignment assignment, EReference reference) {
		val memberContainer = assignment.memberContainer  // member container NOT eContainer
		if (memberContainer !== null) {
			// expression starts with "self", with a type name, etc.
			return getMemberReferenceScope(memberContainer)
		} else {
			// provide members found via the parent member container closest to the expression, i.e. provide the parameters of a DQuery
			val outerScope = getDefaultScopeForType(assignment, bpackage.IPrimaryNavigationTarget)
			return getExpressionContainerMemberScope(assignment, outerScope)
		}
	}
	
	/* Do not override this method, override the switch */
	final protected def IScope getExpressionContainerMemberScope(EObject context, IScope outerScope) {
		var container = context.eContainer
		getExpressionContainerMemberSwitch(container, outerScope)
	}
	
	protected def IScope getExpressionContainerMemberSwitch(EObject container, IScope outerScope) {
		return switch container {
			DEnumeration: Scopes.scopeFor(container.literals, outerScope)
			DComplexType: getInheritedFeaturesScope(container, outerScope)
			DQuery: Scopes.scopeFor(container.parameters, getExpressionContainerMemberScope(container, outerScope)) // recursion
			DService: Scopes.scopeFor(container.parameters, outerScope)
			DDomainEvent: getDomainEventMemberScope(container, outerScope)
			case null: outerScope
			default: getExpressionContainerMemberScope(container, outerScope) // recursion
		}
	}

	protected def IScope getInheritedFeaturesScope(DComplexType type) {
		getInheritedFeaturesScope(type, IScope.NULLSCOPE)
	}

	protected def IScope getInheritedFeaturesScope(DComplexType type, IScope outerScope) {
		if (type.superType !== null) {
			return Scopes.scopeFor(type.features, getInheritedFeaturesScope(type.superType, outerScope)) // recursion
		} else {
			return Scopes.scopeFor(type.features, outerScope)
		}
	}

	protected def IScope getDomainEventMemberScope(DDomainEvent event, IScope outerScope) {
		val list = Lists.newArrayList()
		list.addAll(event.context)
		
		if (event.trigger !== null) {
			list.add(event.trigger)
		}
		list.addAll(event.notifications)
		return Scopes.scopeFor(list, outerScope)
	}
}
