/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.scoping

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DAggregate
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DDomainEvent
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.INavigableMemberContainer
import com.mimacom.ddd.dm.dmx.DmxAssignment
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation
import com.mimacom.ddd.dm.dmx.DmxPackage
import com.mimacom.ddd.dm.dmx.DmxPredicateWithCorrelationVariable
import com.mimacom.ddd.dm.dmx.DmxStaticReference
import com.mimacom.ddd.dm.dmx.DmxTest
import com.mimacom.ddd.dm.dmx.DmxUtil
import com.mimacom.ddd.dm.dmx.indexing.DmxIndex
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import com.mimacom.ddd.dm.dmx.DmxCallArguments
import com.mimacom.ddd.dm.dmx.DmxSelfExpression

/**
 * This class contains custom scoping for expressions and {@link DComplexType} feature inheritance.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DmxScopeProvider extends AbstractDmxScopeProvider {
	
	@Inject extension DmxUtil
	@Inject extension DmxTypeComputer
	@Inject DmxIndex index

	static val BASE = BasePackage.eINSTANCE
	static val DMX = DmxPackage.eINSTANCE

	override IScope getScope(EObject context, EReference reference) {

		 if (reference == DMX.dmxContextReference_Target) {
		 	// This is classic scoping along the eContainer CONTAINMENT hiearchy:
			val outer = getDefaultScopeForType(context, BASE.IStaticReferenceTarget)
			val scope = getEContainersNavigableMembersScopes(context, outer)	
			return scope
		
		} else if (reference == DMX.dmxMemberNavigation_Member) {
			// This is scoping along (the types of) a NAVIGATION expression tree: the members in scope are those
			// of the preceding navigation segment:
			if (context instanceof DmxMemberNavigation) {
				val preceding = context.precedingNavigationSegment
				if (preceding instanceof DmxSelfExpression) {
				 	// Resort to classic scoping along the eContainer CONTAINMENT hiearchy:
					val outer = getDefaultScopeForType(context, BASE.IStaticReferenceTarget)
					val scope = getEContainersNavigableMembersScopes(context, outer)	
					return scope
				} else {
					val typeDescriptor = preceding.typeFor
					val scope = typeDescriptor.getNavigableMembersAndIteratorsScope(context, index)
					return scope
				}
			}

		} else if (reference == DMX.dmxAssignment_AssignToMember) {
			if (context instanceof DmxAssignment) {
				val preceding = context.precedingNavigationSegment
				val typeDescriptor = preceding.typeFor
				val scope = typeDescriptor.getNavigableMembersScope()  // exclude iterators
				return scope
			} else if (context instanceof DmxMemberNavigation) {
				val preceding = context.precedingNavigationSegment
				val typeDescriptor = preceding.typeFor
				val scope = typeDescriptor.getNavigableMembersScope() // exclude iterators
				return scope
			}
			
		} else if (reference == DMX.dmxStaticReference_Target) {
			val scope = getDefaultScopeForType(context, BASE.IStaticReferenceTarget)
			return scope

		} else if (reference == DMX.dmxStaticReference_Member) {
			if (context instanceof DmxStaticReference) {
				val target = context.target
				if (target instanceof INavigableMemberContainer ) {
					val scope = getEContainerNavigableMembersScopeSwitch(target, IScope.NULLSCOPE)
					return scope
				}
			}

		} else if (reference == DMX.dmxFunctionCall_Function) {
			val allFilters = index.allVisibleFilters(context)
			val scope = Scopes.scopeFor(allFilters, super.getScope(context, reference))
			return scope
		}

		return super.getScope(context, reference)
	}
	
	/*
	 * Obtains the default scope for the given reference, then narrows the result down to the given type.
	 */
	def IScope getDefaultScopeForType(EObject context, EClass type) {
		val reference = EcoreFactory.eINSTANCE.createEReference
		// Default scoping only uses the EType field of the reference:
		reference.EType = type
		val scope = super.getScope(context, reference)
		return scope
	}
	
	/* Returns all DNavigableMember elements of the given navigation member element along the MODEL eContainer hierarchy. */
	final protected def IScope getEContainersNavigableMembersScopes(EObject context, IScope outerScope) {
		var scope = outerScope
		var container = context.eContainer
		
		if (container === null) {
			return scope
		
		} else if (container instanceof INavigableMemberContainer) {
			scope = getEContainerNavigableMembersScopeSwitch(container, outerScope)
		
		} else if (container instanceof DmxCallArguments) {
			if (container.arguments.contains(context)) {
				// "move up" directly to the containing DmxMemberNavigation, don't use recursion:
				container = container.eContainer
				if (container instanceof DmxMemberNavigation) {
					val typeDescriptor = container.precedingNavigationSegment.typeFor
					scope = typeDescriptor.getNavigableMembersScope(outerScope)
				}
			}
		}
		return getEContainersNavigableMembersScopes(container, scope) // recursion
	}
	
	/**
	 * Overriders must ensure, that each type used as a discriminator in the switch statement implements  @INavigableMemberContainer, 
	 * otherwise this method will never be invoked.<p>
	 * Also, the elements included in the scope must implement @DNavigableMember.
	 */
	protected def IScope getEContainerNavigableMembersScopeSwitch(INavigableMemberContainer container, IScope outerScope) {
		val scope = switch container {
			DEnumeration: Scopes.scopeFor(container.literals, outerScope)
			DComplexType: Scopes.scopeFor(container.allFeatures(), outerScope)
			DQuery: Scopes.scopeFor(container.parameters, outerScope)
			DAggregate: Scopes.scopeFor(container.staticQueries, outerScope)
			DDomainEvent: getDomainEventNavigableMemberScope(container, outerScope)
			DmxPredicateWithCorrelationVariable: Scopes.scopeFor(Lists.newArrayList(container.correlationVariable), outerScope)
			DmxTest: Scopes.scopeFor(container.context,  outerScope)
			default: outerScope
		}
		return scope
	}

	protected def IScope getDomainEventNavigableMemberScope(DDomainEvent event, IScope outerScope) {
		val list = Lists.newArrayList()
		list.addAll(event.context)
		
		if (event.trigger !== null) {
			list.add(event.trigger)
		}
		list.addAll(event.notifications)
		return Scopes.scopeFor(list, outerScope)
	}
}
