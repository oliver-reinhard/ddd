/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.validation;

import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.BasePackage;
import com.mimacom.ddd.dm.base.DComplexType;
import com.mimacom.ddd.dm.base.DExpression;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DNavigableMember;
import com.mimacom.ddd.dm.dmx.DmxContextReference;
import com.mimacom.ddd.dm.dmx.DmxFilter;
import com.mimacom.ddd.dm.dmx.DmxFilterParameter;
import com.mimacom.ddd.dm.dmx.DmxFilterTypeDescriptor;
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation;
import com.mimacom.ddd.dm.dmx.DmxPackage;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer;
import com.mimacom.ddd.dm.dmx.validation.AbstractDmxValidator;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DmxValidator extends AbstractDmxValidator {
  @Inject
  @Extension
  private DmxTypeComputer _dmxTypeComputer;
  
  private static final BasePackage BASE = BasePackage.eINSTANCE;
  
  private static final DmxPackage DMX = DmxPackage.eINSTANCE;
  
  @Check
  public void checkFilterParameters(final DmxFilter f) {
    boolean _isMultiTyped = f.getTypeDesc().isMultiTyped();
    if (_isMultiTyped) {
      int _size = f.getParameters().size();
      boolean _equals = (_size == 0);
      if (_equals) {
        this.error("For a multi-typed return type, there must be a matching first parameter.", f, DmxValidator.BASE.getDNamedElement_Name(), 0);
      } else {
        DmxFilterParameter _get = f.getParameters().get(0);
        DmxFilterTypeDescriptor _typeDesc = null;
        if (_get!=null) {
          _typeDesc=_get.getTypeDesc();
        }
        boolean _isMultiTyped_1 = _typeDesc.isMultiTyped();
        boolean _not = (!_isMultiTyped_1);
        if (_not) {
          this.error("For a multi-typed return type, the first parameter must have the same type.", f, DmxValidator.DMX.getDmxFilter_Parameters(), 0);
        }
      }
    }
  }
  
  @Check
  public void checkUseOfAllQualifier(final DmxContextReference ref) {
    if ((ref.isAll() && (!(ref.getTarget() instanceof DComplexType)))) {
      this.error("\'all\' qualifier is only supported after a static type reference.", ref, DmxValidator.DMX.getDmxContextReference_All());
    }
  }
  
  @Check
  public void checkNavigationOfStaticTypeReference(final DmxMemberNavigation nav) {
    DNavigableMember _member = nav.getMember();
    if ((_member instanceof DFeature)) {
      final DExpression preceding = nav.getPrecedingNavigationSegment();
      if (((preceding instanceof DmxContextReference) && (((DmxContextReference) preceding).getTarget() instanceof DComplexType))) {
        this.error("Cannot navigate a feature from a static type reference. Use [[Type#feature]] syntax inside a RichString.", nav, 
          DmxValidator.DMX.getDmxMemberNavigation_Member());
      }
    }
  }
  
  @Check
  public void checkFeatureNavigationOfCollection(final DmxMemberNavigation nav) {
    final DNavigableMember member = nav.getMember();
    if ((member instanceof DFeature)) {
      final DExpression preceding = nav.getPrecedingNavigationSegment();
      if (((preceding != null) && this._dmxTypeComputer.typeFor(preceding).isCollection())) {
        this.error("Cannot navigate a feature of a collection of objects.", nav, DmxValidator.DMX.getDmxMemberNavigation_Member());
      }
    }
  }
}
