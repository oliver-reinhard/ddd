/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.base.BasePackage;
import com.mimacom.ddd.dm.base.base.DExpression;
import com.mimacom.ddd.dm.base.base.DFeature;
import com.mimacom.ddd.dm.base.base.DNavigableMember;
import com.mimacom.ddd.dm.base.base.DQuery;
import com.mimacom.ddd.dm.base.base.DType;
import com.mimacom.ddd.dm.dmx.DmxAssignment;
import com.mimacom.ddd.dm.dmx.DmxBinaryOperation;
import com.mimacom.ddd.dm.dmx.DmxBinaryOperator;
import com.mimacom.ddd.dm.dmx.DmxCallArguments;
import com.mimacom.ddd.dm.dmx.DmxField;
import com.mimacom.ddd.dm.dmx.DmxFilter;
import com.mimacom.ddd.dm.dmx.DmxFilterTypeDescriptor;
import com.mimacom.ddd.dm.dmx.DmxFunctionCall;
import com.mimacom.ddd.dm.dmx.DmxListExpression;
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation;
import com.mimacom.ddd.dm.dmx.DmxPackage;
import com.mimacom.ddd.dm.dmx.DmxPredicateWithCorrelationVariable;
import com.mimacom.ddd.dm.dmx.DmxStringLiteral;
import com.mimacom.ddd.dm.dmx.DmxTestContext;
import com.mimacom.ddd.dm.dmx.DmxUnaryOperation;
import com.mimacom.ddd.dm.dmx.DmxUtil;
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxBaseTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider;
import com.mimacom.ddd.dm.dmx.validation.AbstractDmxValidator;
import java.util.Date;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DmxTypeCheckingValidator extends AbstractDmxValidator {
  @Inject
  @Extension
  private DmxUtil _dmxUtil;
  
  @Inject
  @Extension
  private DmxTypeDescriptorProvider _dmxTypeDescriptorProvider;
  
  @Inject
  @Extension
  private DmxTypeComputer _dmxTypeComputer;
  
  protected static final BasePackage BASE = BasePackage.eINSTANCE;
  
  protected static final DmxPackage DMX = DmxPackage.eINSTANCE;
  
  protected static final String TYPE_MISMATCH = "Type Mismatch";
  
  protected static final String NO_EXPRESSION = "No Expression";
  
  protected static final List<AbstractDmxTypeDescriptor<?>> COMPARABLE_TYPES = ((List<AbstractDmxTypeDescriptor<?>>) ((Object) Lists.<DmxBaseTypeDescriptor>newArrayList(DmxTypeDescriptorProvider.NUMBER, DmxTypeDescriptorProvider.TEXT, 
    DmxTypeDescriptorProvider.TIMEPOINT)));
  
  protected static final int NO_INDEX = (-1);
  
  @Check
  public void checkFeatureNavigationOfCollection(final DmxMemberNavigation nav) {
    final DNavigableMember member = nav.getMember();
    if ((member instanceof DFeature)) {
      final DExpression preceding = nav.getPrecedingNavigationSegment();
      final AbstractDmxTypeDescriptor<?> type = this.getTypeAndCheckNotNull(nav, preceding, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_PrecedingNavigationSegment());
      boolean _isCollection = type.isCollection();
      if (_isCollection) {
        this.error("Cannot navigate a feature of a collection of objects.", nav, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_Member());
      }
    }
  }
  
  @Check
  public void checkQueryParameters(final DmxMemberNavigation actual) {
    final DNavigableMember formal = actual.getMember();
    if ((formal instanceof DQuery)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 0; (fIndex < ((DQuery)formal).getParameters().size()); fIndex++) {
        {
          final int aIndex = fIndex;
          int _size = actualParameters.size();
          boolean _lessThan = (aIndex < _size);
          if (_lessThan) {
            final DType formalParamType = ((DQuery)formal).getParameters().get(fIndex).getType();
            AbstractDmxTypeDescriptor<?> _xifexpression = null;
            if ((formalParamType != null)) {
              _xifexpression = this._dmxTypeDescriptorProvider.getTypeDescriptor(formalParamType, ((DQuery)formal).getParameters().get(fIndex).isCollection());
            } else {
              _xifexpression = DmxTypeDescriptorProvider.UNDEFINED_TYPE;
            }
            final AbstractDmxTypeDescriptor<?> expectedType = _xifexpression;
            this.expectType(actual, actualParameters.get(aIndex), expectedType, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_CallArguments());
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (aIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      this.checkTooManyActualParameters(((DQuery)formal).getParameters().size(), actual.getCallArguments());
    }
  }
  
  @Check
  public void checkFilterParameters(final DmxMemberNavigation actual) {
    final DNavigableMember formal = actual.getMember();
    if ((formal instanceof DmxFilter)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 1; (fIndex < ((DmxFilter)formal).getParameters().size()); fIndex++) {
        {
          final int aIndex = (fIndex - 1);
          int _size = actualParameters.size();
          boolean _lessThan = (aIndex < _size);
          if (_lessThan) {
            this.expectFilterParameterType(actual, ((DmxFilter)formal), fIndex, actualParameters, aIndex, 
              DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_CallArguments());
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (aIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      int _size = ((DmxFilter)formal).getParameters().size();
      int _minus = (_size - 1);
      this.checkTooManyActualParameters(_minus, actual.getCallArguments());
    }
  }
  
  @Check
  public void checkFunctionParameters(final DmxFunctionCall actual) {
    final DmxFilter formal = actual.getFunction();
    if ((formal != null)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 0; (fIndex < formal.getParameters().size()); fIndex++) {
        {
          final int aIndex = fIndex;
          int _size = actualParameters.size();
          boolean _lessThan = (fIndex < _size);
          if (_lessThan) {
            this.expectFilterParameterType(actual, formal, fIndex, actualParameters, aIndex, 
              DmxTypeCheckingValidator.DMX.getDmxFunctionCall_CallArguments());
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (fIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      this.checkTooManyActualParameters(formal.getParameters().size(), actual.getCallArguments());
    }
  }
  
  protected boolean expectFilterParameterType(final DExpression actual, final DmxFilter formal, final int fIndex, final List<DExpression> actualParameters, final int aIndex, final EReference ref) {
    boolean _xblockexpression = false;
    {
      final DmxFilterTypeDescriptor formalParamTypeDesc = formal.getParameters().get(fIndex).getTypeDesc();
      final AbstractDmxTypeDescriptor<?> actualType = this.getTypeAndCheckNotNull(actual, actualParameters.get(aIndex), ref);
      _xblockexpression = this.expectType(actual, actualType, this._dmxTypeDescriptorProvider.getTypeDescriptors(formalParamTypeDesc), ref);
    }
    return _xblockexpression;
  }
  
  protected void errorParameterValuesMissing(final EObject context, final DmxCallArguments actualParameters, final int aIndex) {
    final String message = "Mandatory parameter values missing.";
    if (((actualParameters == null) || actualParameters.getArguments().isEmpty())) {
      boolean _matched = false;
      if (context instanceof DmxMemberNavigation) {
        _matched=true;
        this.error(message, context, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_Member());
      }
      if (!_matched) {
        if (context instanceof DmxFunctionCall) {
          _matched=true;
          this.error(message, context, DmxTypeCheckingValidator.DMX.getDmxFunctionCall_Function());
        }
      }
      if (!_matched) {
        String _name = context.eClass().getName();
        throw new IllegalArgumentException(_name);
      }
    } else {
      this.error(message, actualParameters, DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments(), (aIndex - 1));
    }
  }
  
  protected void checkTooManyActualParameters(final int formalParametersSize, final DmxCallArguments actualParameters) {
    if ((actualParameters != null)) {
      for (int aIndex = formalParametersSize; (aIndex < actualParameters.getArguments().size()); aIndex++) {
        this.error("More actual parameters than formal parameters.", actualParameters, 
          DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments(), aIndex);
      }
    }
  }
  
  public boolean checkType(final DmxPredicateWithCorrelationVariable expr) {
    return this.expectBoolean(expr, expr.getPredicate(), DmxTypeCheckingValidator.DMX.getDmxPredicateWithCorrelationVariable_Predicate());
  }
  
  @Check
  public void checkType(final DmxBinaryOperation expr) {
    final AbstractDmxTypeDescriptor<?> leftType = this.getTypeAndCheckNotNull(expr, expr.getLeftOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
    final AbstractDmxTypeDescriptor<?> rightType = this.getTypeAndCheckNotNull(expr, expr.getRightOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
    if ((Objects.equal(leftType, DmxTypeDescriptorProvider.UNDEFINED_TYPE) || Objects.equal(rightType, DmxTypeDescriptorProvider.UNDEFINED_TYPE))) {
      return;
    }
    DmxBinaryOperator _operator = expr.getOperator();
    if (_operator != null) {
      switch (_operator) {
        case OR:
        case XOR:
        case AND:
        case DOUBLE_ARROW:
          this.expectBoolean(expr, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
          this.expectBoolean(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          break;
        case EQUAL:
        case NOT_EQUAL:
          boolean _isCompatibleWith = leftType.isCompatibleWith(DmxTypeDescriptorProvider.TIMEPOINT);
          if (_isCompatibleWith) {
            this.expectTimepointValue(expr, expr.getRightOperand(), rightType, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          } else {
            if ((leftType.isCollection() && Objects.equal(rightType, DmxTypeDescriptorProvider.UNDEFINED_TYPE_COLLECTION))) {
            } else {
              this.expectType(expr, rightType, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
          }
          break;
        case LESS:
        case LESS_OR_EQUAL:
        case GREATER_OR_EQUAL:
        case GREATER:
          boolean _isCompatibleWith_1 = leftType.isCompatibleWith(DmxTypeDescriptorProvider.TIMEPOINT);
          if (_isCompatibleWith_1) {
            this.expectTimepointValue(expr, expr.getRightOperand(), rightType, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          } else {
            boolean _expectType = this.expectType(expr, leftType, DmxTypeCheckingValidator.COMPARABLE_TYPES, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            if (_expectType) {
              this.expectType(expr, rightType, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            } else {
              this.expectType(expr, rightType, DmxTypeCheckingValidator.COMPARABLE_TYPES, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            }
          }
          break;
        case ADD:
          boolean _isTimepointValue = this._dmxTypeComputer.isTimepointValue(expr.getLeftOperand(), leftType);
          if (_isTimepointValue) {
            this.expectNumber(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          } else {
            boolean _equals = Objects.equal(leftType, DmxTypeDescriptorProvider.TEXT);
            if (_equals) {
              this.expectType(expr, rightType, DmxTypeCheckingValidator.COMPARABLE_TYPES, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            } else {
              this.expectNumber(expr, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
              this.expectNumber(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
          }
          break;
        case SUBTRACT:
          boolean _isTimepointValue_1 = this._dmxTypeComputer.isTimepointValue(expr.getLeftOperand(), leftType);
          if (_isTimepointValue_1) {
            boolean _isTimepointValue_2 = this._dmxTypeComputer.isTimepointValue(expr.getRightOperand(), rightType);
            boolean _not = (!_isTimepointValue_2);
            if (_not) {
              this.expectNumber(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
          } else {
            this.expectNumber(expr, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            this.expectNumber(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          }
          break;
        case MULTIPLY:
        case DIVIDE:
        case POWER:
        case MODULO:
          this.expectNumber(expr, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
          this.expectNumber(expr, rightType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          break;
        case IN:
          boolean hasError = false;
          boolean _isCollection = leftType.isCollection();
          if (_isCollection) {
            this.error("Cannot be a collection", expr, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            hasError = true;
          }
          boolean _isCollection_1 = rightType.isCollection();
          boolean _not_1 = (!_isCollection_1);
          if (_not_1) {
            this.error("Must be a collection", expr, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            hasError = true;
          }
          if ((!hasError)) {
            this.expectType(expr, rightType, this._dmxTypeDescriptorProvider.toFromCollection(leftType, true), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          }
          break;
        case UNTIL:
          this.expectType(expr, rightType, leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
          break;
        case SINGLE_ARROW:
          String _literal = expr.getOperator().getLiteral();
          throw new UnsupportedOperationException(_literal);
        default:
          break;
      }
    }
  }
  
  @Check
  public boolean checkType(final DmxUnaryOperation expr) {
    boolean _xblockexpression = false;
    {
      final AbstractDmxTypeDescriptor<?> expectedType = this.getTypeAndCheckNotNull(expr, expr, DmxTypeCheckingValidator.DMX.getDmxUnaryOperation_Operand());
      _xblockexpression = this.expectType(expr, expr.getOperand(), expectedType, DmxTypeCheckingValidator.DMX.getDmxUnaryOperation_Operand());
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkType(final DmxListExpression expr) {
    int _size = expr.getElements().size();
    boolean _lessEqualsThan = (_size <= 1);
    if (_lessEqualsThan) {
      return;
    }
    final AbstractDmxTypeDescriptor<?> expectedType = this.getTypeDescAndCheckNotNull(expr, IterableExtensions.<DExpression>head(expr.getElements()), DmxTypeCheckingValidator.DMX.getDmxListExpression_Elements(), 0);
    for (int i = 1; (i < expr.getElements().size()); i++) {
      this.expectType(expr, expr.getElements().get(i), expectedType, DmxTypeCheckingValidator.DMX.getDmxListExpression_Elements(), i);
    }
  }
  
  @Check
  public void checkType(final DmxTestContext expr) {
    DExpression _value = expr.getValue();
    boolean _tripleNotEquals = (_value != null);
    if (_tripleNotEquals) {
      final AbstractDmxTypeDescriptor<?> expectedType = this.getTypeDescAndCheckNotNull(expr.getType(), expr.isCollection(), DmxTypeCheckingValidator.DMX.getDmxTest_Expr());
      boolean _equals = Objects.equal(expectedType, DmxTypeDescriptorProvider.UNDEFINED_TYPE);
      if (_equals) {
        return;
      }
      this.expectType(expr, expr.getValue(), expectedType, DmxTypeCheckingValidator.DMX.getDmxTestContext_Value());
    }
  }
  
  @Check
  public void checkType(final DmxAssignment expr) {
    final DNavigableMember target = expr.getAssignToMember();
    final AbstractDmxTypeDescriptor<?> targetType = this.getTypeDescAndCheckNotNull(target.getType(), target.isCollection(), DmxTypeCheckingValidator.DMX.getDmxAssignment_AssignToMember());
    boolean _equals = Objects.equal(targetType, DmxTypeDescriptorProvider.UNDEFINED_TYPE);
    if (_equals) {
      return;
    }
    boolean _isCompatibleWith = targetType.isCompatibleWith(DmxTypeDescriptorProvider.TIMEPOINT);
    if (_isCompatibleWith) {
      final AbstractDmxTypeDescriptor<?> actualType = this.getTypeAndCheckNotNull(expr, expr.getValue(), DmxTypeCheckingValidator.DMX.getDmxAssignment_Value());
      this.expectTimepointValue(expr, expr.getValue(), actualType, targetType, DmxTypeCheckingValidator.DMX.getDmxAssignment_Value());
    } else {
      if (((expr.getValue() instanceof DmxListExpression) && ((DmxListExpression) expr.getValue()).getElements().isEmpty())) {
      } else {
        this.expectType(expr, expr.getValue(), targetType, DmxTypeCheckingValidator.DMX.getDmxAssignment_Value());
      }
    }
  }
  
  @Check
  public Boolean checkType(final DmxField expr) {
    Boolean _xblockexpression = null;
    {
      final AbstractDmxTypeDescriptor<?> featureType = this._dmxTypeComputer.typeFor(expr);
      final AbstractDmxTypeDescriptor<?> valueType = this.getTypeAndCheckNotNull(expr, expr.getValue(), DmxTypeCheckingValidator.DMX.getDmxField_Value());
      Boolean _xifexpression = null;
      boolean _isCompatibleWith = featureType.isCompatibleWith(DmxTypeDescriptorProvider.TIMEPOINT);
      if (_isCompatibleWith) {
        Boolean _xblockexpression_1 = null;
        {
          final AbstractDmxTypeDescriptor<?> actualType = this.getTypeAndCheckNotNull(expr, expr.getValue(), DmxTypeCheckingValidator.DMX.getDmxField_Value());
          _xblockexpression_1 = this.expectTimepointValue(expr, expr.getValue(), actualType, featureType, DmxTypeCheckingValidator.DMX.getDmxField_Value());
        }
        _xifexpression = _xblockexpression_1;
      } else {
        Boolean _xifexpression_1 = null;
        boolean _isCompatibleWith_1 = featureType.isCompatibleWith(DmxTypeDescriptorProvider.IDENTIFIER);
        if (_isCompatibleWith_1) {
          _xifexpression_1 = Boolean.valueOf(this.expectType(expr, expr.getValue(), DmxTypeDescriptorProvider.NUMBER, DmxTypeCheckingValidator.DMX.getDmxField_Value()));
        } else {
          Boolean _xifexpression_2 = null;
          if ((featureType.isCollection() && Objects.equal(valueType, DmxTypeDescriptorProvider.UNDEFINED_TYPE_COLLECTION))) {
            _xifexpression_2 = null;
          } else {
            _xifexpression_2 = Boolean.valueOf(this.expectType(expr, expr.getValue(), featureType, DmxTypeCheckingValidator.DMX.getDmxField_Value()));
          }
          _xifexpression_1 = _xifexpression_2;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  @Check
  public void checkFieldKind(final DmxField f) {
    if (((f.getFeature() != null) && (f.getFeature() instanceof DQuery))) {
      this.error("Cannot assign a value to a query", f, DmxTypeCheckingValidator.DMX.getDmxField_Feature());
    }
  }
  
  protected AbstractDmxTypeDescriptor<?> getTypeDescAndCheckNotNull(final EObject context, final DExpression typedExpression, final EReference ref, final int index) {
    if ((typedExpression == null)) {
      this.error("Expression is null", typedExpression, ref, DmxTypeCheckingValidator.NO_EXPRESSION);
      return DmxTypeDescriptorProvider.UNDEFINED_TYPE;
    }
    final AbstractDmxTypeDescriptor<?> typeDesc = this._dmxTypeComputer.typeFor(typedExpression);
    if ((typeDesc == null)) {
      final String errorText = "Type is null";
      if ((index == DmxTypeCheckingValidator.NO_INDEX)) {
        this.error(errorText, context, ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
      } else {
        this.error(errorText, context, ref, index, DmxTypeCheckingValidator.TYPE_MISMATCH);
      }
      return DmxTypeDescriptorProvider.UNDEFINED_TYPE;
    }
    return typeDesc;
  }
  
  protected AbstractDmxTypeDescriptor<?> getTypeAndCheckNotNull(final EObject context, final DExpression typedExpression, final EReference ref) {
    return this.getTypeDescAndCheckNotNull(context, typedExpression, ref, DmxTypeCheckingValidator.NO_INDEX);
  }
  
  protected AbstractDmxTypeDescriptor<?> getTypeDescAndCheckNotNull(final DType type, final boolean collection, final EReference ref) {
    if (((type == null) || type.eIsProxy())) {
      this.error("Unresolved type reference", ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
      return DmxTypeDescriptorProvider.UNDEFINED_TYPE;
    }
    final AbstractDmxTypeDescriptor<?> typeDesc = this._dmxTypeDescriptorProvider.getTypeDescriptor(type, collection);
    if ((typeDesc == null)) {
      this.error("Undefined type", ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
      return DmxTypeDescriptorProvider.UNDEFINED_TYPE;
    }
    return typeDesc;
  }
  
  protected boolean expectBoolean(final EObject context, final DExpression expr, final EReference ref) {
    return this.expectType(context, expr, DmxTypeDescriptorProvider.BOOLEAN, ref);
  }
  
  protected boolean expectBoolean(final EObject context, final AbstractDmxTypeDescriptor<?> actualType, final EReference ref) {
    return this.expectType(context, actualType, DmxTypeDescriptorProvider.BOOLEAN, ref);
  }
  
  protected boolean expectNumber(final EObject context, final DExpression expr, final EReference ref) {
    return this.expectType(context, expr, DmxTypeDescriptorProvider.NUMBER, ref);
  }
  
  protected boolean expectNumber(final EObject context, final AbstractDmxTypeDescriptor<?> actualType, final EReference ref) {
    return this.expectType(context, actualType, DmxTypeDescriptorProvider.NUMBER, ref);
  }
  
  protected Boolean expectTimepointValue(final EObject context, final DExpression actualExpression, final AbstractDmxTypeDescriptor<?> actualType, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref) {
    boolean _xifexpression = false;
    if ((actualExpression instanceof DmxStringLiteral)) {
      Date _parseTimepoint = this._dmxUtil.parseTimepoint(((DmxStringLiteral)actualExpression).getValue());
      boolean _tripleEquals = (_parseTimepoint == null);
      if (_tripleEquals) {
        this.error(("Invalid Timepoint format, should be: " + DmxUtil.TIMEPOINT_SYNTAX), actualExpression, 
          DmxTypeCheckingValidator.DMX.getDmxStringLiteral_Value());
      }
    } else {
      _xifexpression = this.expectType(context, actualType, expectedType, ref);
    }
    return Boolean.valueOf(_xifexpression);
  }
  
  protected boolean expectType(final EObject context, final DExpression typedExpression, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref, final int index) {
    final AbstractDmxTypeDescriptor<?> actualType = this.getTypeDescAndCheckNotNull(context, typedExpression, ref, index);
    return this.expectType(context, actualType, expectedType, ref, index);
  }
  
  protected boolean expectType(final EObject context, final DExpression typedExpression, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref) {
    return this.expectType(context, typedExpression, expectedType, ref, DmxTypeCheckingValidator.NO_INDEX);
  }
  
  protected boolean expectType(final EObject context, final AbstractDmxTypeDescriptor<?> actualType, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref, final int index) {
    boolean _isCompatibleWith = actualType.isCompatibleWith(expectedType);
    if (_isCompatibleWith) {
      return true;
    }
    String _displayName = expectedType.displayName();
    String _plus = ("Expected " + _displayName);
    String _plus_1 = (_plus + " type, but is ");
    String _displayName_1 = actualType.displayName();
    final String errorText = (_plus_1 + _displayName_1);
    if ((index == DmxTypeCheckingValidator.NO_INDEX)) {
      this.error(errorText, ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
    } else {
      this.error(errorText, ref, index, DmxTypeCheckingValidator.TYPE_MISMATCH);
    }
    return false;
  }
  
  protected boolean expectType(final EObject context, final AbstractDmxTypeDescriptor<?> actualType, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref) {
    return this.expectType(context, actualType, expectedType, ref, DmxTypeCheckingValidator.NO_INDEX);
  }
  
  protected boolean expectType(final EObject context, final AbstractDmxTypeDescriptor<?> actualType, final List<AbstractDmxTypeDescriptor<?>> expectedTypes, final EReference ref) {
    for (final AbstractDmxTypeDescriptor<?> e : expectedTypes) {
      boolean _isCompatibleWith = e.isCompatibleWith(actualType);
      if (_isCompatibleWith) {
        return true;
      }
    }
    final Function1<AbstractDmxTypeDescriptor<?>, String> _function = (AbstractDmxTypeDescriptor<?> it) -> {
      return it.displayName();
    };
    List<String> _map = ListExtensions.<AbstractDmxTypeDescriptor<?>, String>map(expectedTypes, _function);
    String _plus = ("Expected one of " + _map);
    String _plus_1 = (_plus + " types, but is ");
    String _displayName = actualType.displayName();
    String _plus_2 = (_plus_1 + _displayName);
    this.error(_plus_2, ref, 
      DmxTypeCheckingValidator.TYPE_MISMATCH);
    return false;
  }
}
