/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.validation;

import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.BasePackage;
import com.mimacom.ddd.dm.base.DExpression;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DNavigableMember;
import com.mimacom.ddd.dm.base.DQuery;
import com.mimacom.ddd.dm.base.DType;
import com.mimacom.ddd.dm.dmx.DmxBinaryOperation;
import com.mimacom.ddd.dm.dmx.DmxBinaryOperator;
import com.mimacom.ddd.dm.dmx.DmxCallArguments;
import com.mimacom.ddd.dm.dmx.DmxFilter;
import com.mimacom.ddd.dm.dmx.DmxFilterTypeDescriptor;
import com.mimacom.ddd.dm.dmx.DmxFunctionCall;
import com.mimacom.ddd.dm.dmx.DmxMemberNavigation;
import com.mimacom.ddd.dm.dmx.DmxPackage;
import com.mimacom.ddd.dm.dmx.DmxPredicateWithCorrelationVariable;
import com.mimacom.ddd.dm.dmx.DmxUnaryOperation;
import com.mimacom.ddd.dm.dmx.DmxUtil;
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxBaseTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer;
import com.mimacom.ddd.dm.dmx.validation.AbstractDmxValidator;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DmxTypeCheckingValidator extends AbstractDmxValidator {
  @Inject
  @Extension
  private DmxTypeComputer _dmxTypeComputer;
  
  @Inject
  @Extension
  private DmxUtil _dmxUtil;
  
  protected static final BasePackage BASE = BasePackage.eINSTANCE;
  
  protected static final DmxPackage DMX = DmxPackage.eINSTANCE;
  
  private static final String TYPE_MISMATCH = "Type Mismatch";
  
  private static final List<AbstractDmxTypeDescriptor<?>> COMPARABLE_TYPES = ((List<AbstractDmxTypeDescriptor<?>>) ((Object) Lists.<DmxBaseTypeDescriptor>newArrayList(DmxTypeComputer.NUMBER, DmxTypeComputer.TEXT, DmxTypeComputer.TIMEPOINT)));
  
  @Check
  public void checkFeatureNavigationOfCollection(final DmxMemberNavigation nav) {
    final DNavigableMember member = nav.getMember();
    if ((member instanceof DFeature)) {
      final DExpression preceding = nav.getPrecedingNavigationSegment();
      final AbstractDmxTypeDescriptor<?> type = this.getTypeAndCheckNotNull(preceding, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_PrecedingNavigationSegment());
      boolean _isCollection = type.isCollection();
      if (_isCollection) {
        this.error("Cannot navigate a feature of a collection of objects.", nav, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_Member());
      }
    }
  }
  
  @Check
  public void checkQueryParameters(final DmxMemberNavigation actual) {
    final DNavigableMember formal = actual.getMember();
    if ((formal instanceof DQuery)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 0; (fIndex < ((DQuery)formal).getParameters().size()); fIndex++) {
        {
          final int aIndex = fIndex;
          int _size = actualParameters.size();
          boolean _lessThan = (aIndex < _size);
          if (_lessThan) {
            final DType formalParamType = ((DQuery)formal).getParameters().get(fIndex).getType();
            AbstractDmxTypeDescriptor<?> _xifexpression = null;
            if ((formalParamType != null)) {
              _xifexpression = this._dmxTypeComputer.getTypeDescriptor(formalParamType, ((DQuery)formal).getParameters().get(fIndex).isCollection());
            } else {
              _xifexpression = DmxTypeComputer.UNDEFINED;
            }
            final AbstractDmxTypeDescriptor<?> expectedType = _xifexpression;
            this.expectType(actualParameters.get(aIndex), expectedType, DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments());
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (aIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      this.checkTooManyActualParameters(((DQuery)formal).getParameters().size(), actual.getCallArguments());
    }
  }
  
  @Check
  public void checkFilterParameters(final DmxMemberNavigation actual) {
    final DNavigableMember formal = actual.getMember();
    if ((formal instanceof DmxFilter)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 1; (fIndex < ((DmxFilter)formal).getParameters().size()); fIndex++) {
        {
          final int aIndex = (fIndex - 1);
          int _size = actualParameters.size();
          boolean _lessThan = (aIndex < _size);
          if (_lessThan) {
            this.expectFilterParameterType(((DmxFilter)formal), fIndex, actualParameters, aIndex);
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (aIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      int _size = ((DmxFilter)formal).getParameters().size();
      int _minus = (_size - 1);
      this.checkTooManyActualParameters(_minus, actual.getCallArguments());
    }
  }
  
  @Check
  public void checkFunctionParameters(final DmxFunctionCall actual) {
    final DmxFilter formal = actual.getFunction();
    if ((formal != null)) {
      final List<DExpression> actualParameters = this._dmxUtil.nullSafeCallArguments(actual);
      for (int fIndex = 0; (fIndex < formal.getParameters().size()); fIndex++) {
        {
          final int aIndex = fIndex;
          int _size = actualParameters.size();
          boolean _lessThan = (fIndex < _size);
          if (_lessThan) {
            this.expectFilterParameterType(formal, fIndex, actualParameters, aIndex);
          } else {
            int _size_1 = actualParameters.size();
            boolean _equals = (fIndex == _size_1);
            if (_equals) {
              this.errorParameterValuesMissing(actual, actual.getCallArguments(), aIndex);
            }
          }
        }
      }
      this.checkTooManyActualParameters(formal.getParameters().size(), actual.getCallArguments());
    }
  }
  
  protected boolean expectFilterParameterType(final DmxFilter formal, final int fIndex, final List<DExpression> actualParameters, final int aIndex) {
    boolean _xblockexpression = false;
    {
      final DmxFilterTypeDescriptor formalParamTypeDesc = formal.getParameters().get(fIndex).getTypeDesc();
      final AbstractDmxTypeDescriptor<?> actualType = this.getTypeAndCheckNotNull(actualParameters.get(aIndex), DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments());
      _xblockexpression = this.expectType(actualType, this._dmxTypeComputer.getTypeDescriptors(formalParamTypeDesc), DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments());
    }
    return _xblockexpression;
  }
  
  protected void errorParameterValuesMissing(final EObject context, final DmxCallArguments actualParameters, final int aIndex) {
    final String message = "Mandatory parameter values missing.";
    if (((actualParameters == null) || actualParameters.getArguments().isEmpty())) {
      boolean _matched = false;
      if (context instanceof DmxMemberNavigation) {
        _matched=true;
        this.error(message, context, DmxTypeCheckingValidator.DMX.getDmxMemberNavigation_Member());
      }
      if (!_matched) {
        if (context instanceof DmxFunctionCall) {
          _matched=true;
          this.error(message, context, DmxTypeCheckingValidator.DMX.getDmxFunctionCall_Function());
        }
      }
      if (!_matched) {
        String _name = context.eClass().getName();
        throw new IllegalArgumentException(_name);
      }
    } else {
      this.error(message, actualParameters, DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments(), (aIndex - 1));
    }
  }
  
  protected void checkTooManyActualParameters(final int formalParametersSize, final DmxCallArguments actualParameters) {
    if ((actualParameters != null)) {
      for (int aIndex = formalParametersSize; (aIndex < actualParameters.getArguments().size()); aIndex++) {
        this.error("More actual parameters than formal parameters.", actualParameters, DmxTypeCheckingValidator.DMX.getDmxCallArguments_Arguments(), aIndex);
      }
    }
  }
  
  public boolean checkType(final DmxPredicateWithCorrelationVariable expr) {
    return this.expectBoolean(expr.getPredicate(), DmxTypeCheckingValidator.DMX.getDmxPredicateWithCorrelationVariable_Predicate());
  }
  
  @Check
  public boolean checkType(final DmxBinaryOperation expr) {
    boolean _xblockexpression = false;
    {
      final AbstractDmxTypeDescriptor<?> leftType = this.getTypeAndCheckNotNull(expr.getLeftOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
      boolean _switchResult = false;
      DmxBinaryOperator _operator = expr.getOperator();
      if (_operator != null) {
        switch (_operator) {
          case OR:
          case XOR:
          case AND:
          case DOUBLE_ARROW:
            boolean _xblockexpression_1 = false;
            {
              this.expectBoolean(expr.getLeftOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
              _xblockexpression_1 = this.expectBoolean(expr.getRightOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
            _switchResult = _xblockexpression_1;
            break;
          case EQUAL:
          case NOT_EQUAL:
            _switchResult = this.expectType(expr.getRightOperand(), leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            break;
          case LESS:
          case LESS_OR_EQUAL:
          case GREATER_OR_EQUAL:
          case GREATER:
            boolean _xifexpression = false;
            boolean _expectType = this.expectType(leftType, DmxTypeCheckingValidator.COMPARABLE_TYPES, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
            if (_expectType) {
              _xifexpression = this.expectType(expr.getRightOperand(), leftType, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            } else {
              boolean _xblockexpression_2 = false;
              {
                final AbstractDmxTypeDescriptor<?> rightType = this.getTypeAndCheckNotNull(expr.getRightOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
                _xblockexpression_2 = this.expectType(rightType, DmxTypeCheckingValidator.COMPARABLE_TYPES, DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
              }
              _xifexpression = _xblockexpression_2;
            }
            _switchResult = _xifexpression;
            break;
          case ADD:
            boolean _xblockexpression_3 = false;
            {
              this.expectNumber(expr.getLeftOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
              _xblockexpression_3 = this.expectNumber(expr.getRightOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
            _switchResult = _xblockexpression_3;
            break;
          case SUBTRACT:
          case MULTIPLY:
          case DIVIDE:
          case POWER:
          case MODULO:
            boolean _xblockexpression_4 = false;
            {
              this.expectNumber(expr.getLeftOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_LeftOperand());
              _xblockexpression_4 = this.expectNumber(expr.getRightOperand(), DmxTypeCheckingValidator.DMX.getDmxBinaryOperation_RightOperand());
            }
            _switchResult = _xblockexpression_4;
            break;
          case SINGLE_ARROW:
            String _literal = expr.getOperator().getLiteral();
            throw new UnsupportedOperationException(_literal);
          case UNTIL:
            String _literal_1 = expr.getOperator().getLiteral();
            throw new UnsupportedOperationException(_literal_1);
          default:
            break;
        }
      }
      _xblockexpression = _switchResult;
    }
    return _xblockexpression;
  }
  
  @Check
  public boolean checkType(final DmxUnaryOperation expr) {
    boolean _xblockexpression = false;
    {
      final AbstractDmxTypeDescriptor<?> expectedType = this.getTypeAndCheckNotNull(expr, DmxTypeCheckingValidator.DMX.getDmxUnaryOperation_Operand());
      _xblockexpression = this.expectType(expr.getOperand(), expectedType, DmxTypeCheckingValidator.DMX.getDmxUnaryOperation_Operand());
    }
    return _xblockexpression;
  }
  
  private boolean expectBoolean(final DExpression expr, final EReference ref) {
    return this.expectType(expr, DmxTypeComputer.BOOLEAN, ref);
  }
  
  private boolean expectNumber(final DExpression expr, final EReference ref) {
    return this.expectType(expr, DmxTypeComputer.NUMBER, ref);
  }
  
  private boolean expectType(final DExpression expr, final AbstractDmxTypeDescriptor<?> expectedType, final EReference ref) {
    final AbstractDmxTypeDescriptor<?> actualType = this.getTypeAndCheckNotNull(expr, ref);
    boolean _isCompatibleWith = expectedType.isCompatibleWith(actualType);
    if (_isCompatibleWith) {
      return true;
    }
    String _displayName = expectedType.displayName();
    String _plus = ("Expected " + _displayName);
    String _plus_1 = (_plus + " type, but was ");
    String _displayName_1 = actualType.displayName();
    String _plus_2 = (_plus_1 + _displayName_1);
    this.error(_plus_2, ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
    return false;
  }
  
  private boolean expectType(final AbstractDmxTypeDescriptor<?> actualType, final List<AbstractDmxTypeDescriptor<?>> expectedTypes, final EReference ref) {
    for (final AbstractDmxTypeDescriptor<?> e : expectedTypes) {
      boolean _isCompatibleWith = e.isCompatibleWith(actualType);
      if (_isCompatibleWith) {
        return true;
      }
    }
    final Function1<AbstractDmxTypeDescriptor<?>, String> _function = (AbstractDmxTypeDescriptor<?> it) -> {
      return it.displayName();
    };
    List<String> _map = ListExtensions.<AbstractDmxTypeDescriptor<?>, String>map(expectedTypes, _function);
    String _plus = ("Expected one of " + _map);
    String _plus_1 = (_plus + " types, but was ");
    String _displayName = actualType.displayName();
    String _plus_2 = (_plus_1 + _displayName);
    this.error(_plus_2, ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
    return false;
  }
  
  private AbstractDmxTypeDescriptor<?> getTypeAndCheckNotNull(final DExpression expr, final EReference ref) {
    AbstractDmxTypeDescriptor<?> _typeFor = null;
    if (expr!=null) {
      _typeFor=this._dmxTypeComputer.typeFor(expr);
    }
    final AbstractDmxTypeDescriptor<?> type = _typeFor;
    if ((type == null)) {
      this.error("Undefined type", ref, DmxTypeCheckingValidator.TYPE_MISMATCH);
      return DmxTypeComputer.UNDEFINED;
    }
    return type;
  }
}
