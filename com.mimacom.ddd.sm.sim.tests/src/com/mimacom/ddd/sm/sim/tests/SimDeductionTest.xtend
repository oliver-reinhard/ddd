/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.tests

import com.google.inject.Inject
import com.google.inject.Provider
import com.mimacom.ddd.dm.base.DAggregate
import com.mimacom.ddd.dm.base.DAttribute
import com.mimacom.ddd.dm.base.DEntityType
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DImplicitDeduction
import com.mimacom.ddd.dm.base.DInformationModel
import com.mimacom.ddd.dm.base.DNamespace
import com.mimacom.ddd.dm.base.DPrimitive
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DQueryParameter
import com.mimacom.ddd.dm.dim.DimStandaloneSetup
import com.mimacom.ddd.dm.dmx.DmxArchetype
import com.mimacom.ddd.dm.dmx.DmxModel
import com.mimacom.ddd.dm.dmx.DmxStandaloneSetup
import com.mimacom.ddd.sm.sim.SAggregateDeduction
import com.mimacom.ddd.sm.sim.SEntityTypeDeduction
import com.mimacom.ddd.sm.sim.SEnumerationDeduction
import com.mimacom.ddd.sm.sim.SFeatureDeduction
import com.mimacom.ddd.sm.sim.SGrabAggregateRule
import com.mimacom.ddd.sm.sim.SGrabRule
import com.mimacom.ddd.sm.sim.SInformationModel
import com.mimacom.ddd.sm.sim.SLiteralDeduction
import com.mimacom.ddd.sm.sim.SPrimitiveDeduction
import com.mimacom.ddd.sm.sim.SQueryDeduction
import com.mimacom.ddd.sm.sim.SQueryParameterDeduction
import com.mimacom.ddd.sm.sim.indexing.SimIndex
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.jupiter.api.Assertions.*
import com.mimacom.ddd.dm.base.modelDeduction.DeductionUtil

@ExtendWith(InjectionExtension)
@InjectWith(SimInjectorProvider)
class SimDeductionTest {
	
	static val DM_TYPES_AT = QualifiedName.create("dm", "types", "AT")
	
	static val DM_DT = QualifiedName.create("DM", "DT")
	static val DM_EN = QualifiedName.create("DM", "En")
	
	static val SM_SM1_ST = QualifiedName.create("SM", "SM1", "ST")
	
	@Inject
	ParseHelper<DNamespace> simParseHelper

	final ParseHelper<DNamespace> dmxParseHelper
	final ParseHelper<DNamespace> dimParseHelper

	@Inject
	Provider<ResourceSet> resourceSetProvider
	@Inject SimIndex index

	new() {
		val dimInjector = new DimStandaloneSetup().createInjectorAndDoEMFRegistration()
		dimParseHelper = dimInjector.getInstance(ParseHelper)
		val dmxInjector = new DmxStandaloneSetup().createInjectorAndDoEMFRegistration()
		dmxParseHelper = dmxInjector.getInstance(ParseHelper)
	}

	protected def DmxModel loadDmx(ResourceSet rs) {
		val dmxNS = dmxParseHelper.parse('''
			namespace dm.types
			archetype AT is NUMBER
		''', rs)
		assertNoParseErrors(dmxNS, "dmx")
		val dmx = dmxNS.model as DmxModel
		assertNotNull(dmx)
		assertEquals(1, dmx.types.size)
		val at = dmx.types.head
		assertTrue(at instanceof DmxArchetype)
		
		// Check the index:
		val descs = index.getExportedDTypeDescriptions(at).toList
		assertEquals(1, descs.size)
		assertEquals(SimDeductionTest.DM_TYPES_AT, descs.head.qualifiedName)
		val visibleDescs = index.getVisibleDTypeDescriptions(at).toList
		assertEquals(1, visibleDescs.size)
		assertEquals(SimDeductionTest.DM_TYPES_AT, visibleDescs.head.qualifiedName)
		return dmx
	}

	protected def DInformationModel loadSimpleDim(ResourceSet rs, DmxArchetype at) {
		val dmNS = dimParseHelper.parse('''
			domain DM
			information model DIM {
				primitive DT redefines AT
				enumeration En { L1, L2 }
			}
		''', rs)
		assertNoParseErrors(dmNS, "dm")
		val dim = dmNS.model as DInformationModel
		assertNotNull(dim)
		//
		assertEquals(2, dim.types.size)
		val dt = dim.types.get(0) as DPrimitive
		assertFalse(dt.synthetic)
		assertEquals("DT", dt.name)
		assertEquals(at, dt.redefines)
		//
		val en = dim.types.get(1) as DEnumeration
		assertFalse(dt.synthetic)
		assertEquals("En", en.name)
		assertEquals(2, en.literals.size)
		assertEquals("L1", en.literals.get(0).name)
		assertEquals("L2", en.literals.get(1).name)
		
		// Check the index:
		val descs = index.getExportedDTypeDescriptions(dt).toList
		assertEquals(2, descs.size)
		assertEquals(DM_DT, descs.get(0).qualifiedName)
		assertEquals(DM_EN, descs.get(1).qualifiedName)
		val visibleDescs = index.getVisibleDTypeDescriptions(dt).toList
		assertEquals(3, visibleDescs.size)
		assertEquals(DM_TYPES_AT, visibleDescs.get(0).qualifiedName)
		assertEquals(DM_DT, visibleDescs.get(1).qualifiedName)
		assertEquals(DM_EN, visibleDescs.get(2).qualifiedName)
		return dim
	}

	protected def DInformationModel loadComponentDim(ResourceSet rs, DmxArchetype at) {
		val dimNS = dimParseHelper.parse('''
			domain DM
			information model DIM {
				component AComp {
					query q(p1 : AT) : AT
					main entity A {
						x : AT
					}
				}
			}
		''', rs)
		assertNoParseErrors(dimNS, "dm")
		val dim = dimNS.model as DInformationModel
		assertNotNull(dim)
		//
		assertEquals(1, dim.aggregates.size)
		val acomp = dim.aggregates.get(0)
		assertFalse(acomp.synthetic)
		assertEquals("AComp", acomp.name)
		//
		assertEquals(1, acomp.features.size)
		val q = acomp.features.get(0) as DQuery
		assertFalse(q.synthetic)
		assertEquals("q", q.name)
		assertEquals(at, q.type)
		{
			assertEquals(1, q.parameters.size)
			val p1 = q.parameters.get(0) as DQueryParameter
			assertFalse(p1.synthetic)
			assertEquals("p1", p1.name)
			assertEquals(at, p1.type)
		}
		//
		assertEquals(1, acomp.types.size)
		val a = acomp.types.get(0) as DEntityType
		assertFalse(a.synthetic)
		assertEquals("A", a.name)
		{
			assertEquals(1, a.features.size)
			val x = a.features.get(0) as DAttribute
			assertFalse(x.synthetic)
			assertEquals("x", x.name)
			assertEquals(at, x.type)
		}

		return dim
	}

	@Test
	def void grabPrimitive() {
		val resourceSet = resourceSetProvider.get
		//
		val dmx = loadDmx(resourceSet)
		val at = dmx.types.get(0) as DmxArchetype

		val dim = loadSimpleDim(resourceSet, at)
		val dt = dim.types.get(0) as DPrimitive

		val smNS = simParseHelper.parse('''
			system SM
			base information model SM1 {
				grab primitive DM.DT as ST
			}
		''', resourceSet)
		assertNoParseErrors(smNS, "sm")
		val sm = smNS.model as SInformationModel
		assertNotNull(sm)
		//
		assertEquals(2, sm.types.size)
		val stDeduction = sm.types.get(0) as SPrimitiveDeduction
		assertFalse(stDeduction.synthetic)
		assertTrue(stDeduction.deductionRule instanceof SGrabRule)
		//
		val st = sm.types.get(1) as DPrimitive
		assertEquals("ST", st.name)
		assertTrue(st.synthetic)
		assertEquals(stDeduction, st.deducedFrom)
		assertEquals(dt, st.deducedFrom.deductionRule.source)
		
		// Check the index:
		val descs = index.getExportedDTypeDescriptions(st).toList
		assertEquals(1, descs.size)
		assertEquals(SM_SM1_ST, descs.get(0).qualifiedName)
		val visibleDescs = index.getVisibleDTypeDescriptions(st).toList
		assertEquals(4, visibleDescs.size)
		assertEquals(SM_SM1_ST, visibleDescs.get(3).qualifiedName)
		val visibleMapings = index.getVisibleSTypeMappingDescriptions(st, DeductionUtil.getDeductionSourceQNForIndex(DM_DT)).toList
		assertEquals(1, visibleMapings.size)
		assertEquals(SM_SM1_ST, DeductionUtil.getDeductionTargetQN(visibleMapings.get(0)))
	}

	@Test
	def void grabEnumeration() {
		val resourceSet = resourceSetProvider.get
		//
		val dmx = loadDmx(resourceSet)
		val at = dmx.types.get(0) as DmxArchetype

		val dim = loadSimpleDim(resourceSet, at)
		val en = dim.types.get(1) as DEnumeration
		val l1 = en.literals.get(0)
		val l2 = en.literals.get(1)

		val smNS = simParseHelper.parse('''
			system SM
			base information model SM1 {
				grab enumeration DM.En as SEn1 { add L3 }
				grab enumeration DM.En as SEn2 { grab L2 as L0 }
			}
		''', resourceSet)
		assertNoParseErrors(smNS, "sm")
		val sm = smNS.model as SInformationModel
		assertNotNull(sm)
		//
		assertEquals(4, sm.types.size)
		val sen1Deduction = sm.types.get(0) as SEnumerationDeduction
		assertFalse(sen1Deduction.synthetic)
		assertTrue(sen1Deduction.deductionRule instanceof SGrabRule)
		//
		val sen2Deduction = sm.types.get(1) as SEnumerationDeduction
		assertFalse(sen2Deduction.synthetic)
		assertTrue(sen2Deduction.deductionRule instanceof SGrabRule)
		//
		{
			val sen1 = sm.types.get(2) as DEnumeration
			assertEquals("SEn1", sen1.name)
			assertTrue(sen1.synthetic)
			assertEquals(sen1Deduction, sen1.deducedFrom)
			assertEquals(en, sen1.deducedFrom.deductionRule.source)
			//
			assertEquals(3, sen1.literals.size)
			val sl1 = sen1.literals.get(0)
			assertEquals("L1", sl1.name)
			val sl1Deduction = sl1.deducedFrom as DImplicitDeduction
			assertTrue(sl1Deduction.deductionRule instanceof SGrabRule)
			assertEquals(l1, sl1Deduction.deductionRule.source)
			//
			assertEquals("L2", sen1.literals.get(1).name)
			//
			val sl3 = sen1.literals.get(2)
			assertEquals("L3", sl3.name)
			assertNull(sl3.deducedFrom) // Note: NULL -- no rule, literal added explicitly
		}

		{
			val sen2 = sm.types.get(3) as DEnumeration
			assertEquals("SEn2", sen2.name)
			assertTrue(sen2.synthetic)
			assertEquals(sen2Deduction, sen2.deducedFrom)
			assertEquals(en, sen2.deducedFrom.deductionRule.source)
			//
			assertEquals(1, sen2.literals.size)
			val sl0 = sen2.literals.get(0)
			assertEquals("L0", sl0.name)
			val sl0Deduction = sl0.deducedFrom as SLiteralDeduction
			assertTrue(sl0Deduction.deductionRule instanceof SGrabRule)
			assertEquals(l2, sl0Deduction.deductionRule.source)

		}
	}

	@Test
	def void grabEntity() {
		val resourceSet = resourceSetProvider.get
		//
		val dmx = loadDmx(resourceSet)
		val at = dmx.types.get(0) as DmxArchetype

		val dim = loadComponentDim(resourceSet, at)
		val acomp = dim.aggregates.get(0)
		val a = acomp.types.get(0) as DEntityType
		val x = a.features.get(0) as DAttribute

		val smNS = simParseHelper.parse('''
			system SM
			core information model SM1 {
				grab primitive dm.types.AT as ST
				grab root entity DM.A as SMA1 { add y : ST}
				grab root entity DM.A as SMA2 { grab x}
			}
		''', resourceSet)
		assertNoParseErrors(smNS, "sm")
		val sm = smNS.model as SInformationModel
		assertNotNull(sm)
		//
		assertEquals(6, sm.types.size)
		val stDeduction = sm.types.get(0) as SPrimitiveDeduction
		assertFalse(stDeduction.synthetic)
		assertTrue(stDeduction.deductionRule instanceof SGrabRule)
		
		// Check the index:
		val descs2 = index.getExportedDTypeDescriptions(stDeduction).toList
//		assertEquals(1, descs2.size)
//		assertEquals("dm.types.AT", descs2.head.qualifiedName.toString)
		val visibleDTypeDescs2 = index.getVisibleDTypeDescriptions(stDeduction).toList
//		assertEquals(1, visibleDescs2.size)
//		assertEquals("dm.types.AT", visibleDescs2.head.qualifiedName.toString)
		val visibleDeductionDescs2 = index.getVisibleSTypeMappingDescriptions(stDeduction, DM_TYPES_AT).toList
//		assertEquals(1, visibleDTDeductionDescs2.size)
//		assertEquals("dm.types.AT", visibleDescs2.head.qualifiedName.toString)
		//
		val sma1Deduction = sm.types.get(1) as SEntityTypeDeduction
		assertFalse(sma1Deduction.synthetic)
		assertTrue(sma1Deduction.deductionRule instanceof SGrabRule)
		//
		val sma2Deduction = sm.types.get(2) as SEntityTypeDeduction
		assertFalse(sma2Deduction.synthetic)
		assertTrue(sma2Deduction.deductionRule instanceof SGrabRule)
		//
		val st = sm.types.get(3) as DPrimitive
		assertEquals("ST", st.name)
		assertTrue(st.synthetic)
		assertEquals(stDeduction, st.deducedFrom)
		assertEquals(at, st.deducedFrom.deductionRule.source)
		//
		val sma1 = sm.types.get(4) as DEntityType
		assertEquals("SMA1", sma1.name)
		assertTrue(sma1.synthetic)
		assertEquals(sma1Deduction, sma1.deducedFrom)
		assertEquals(a, sma1.deducedFrom.deductionRule.source)
		{
			assertEquals(2, sma1.features.size)
			val smx = sma1.features.get(0) as DAttribute
			assertTrue(smx.synthetic)
			assertEquals("x", smx.name)
			assertEquals(st, smx.type)
			val smxDeduction = smx.deducedFrom as DImplicitDeduction
			assertTrue(smxDeduction.deductionRule instanceof SGrabRule)
			assertEquals(x, smx.deducedFrom.deductionRule.source)
			//
			val smy = sma1.features.get(1) as DAttribute
			assertTrue(smy.synthetic)
			assertEquals("y", smy.name)
			assertEquals(st, smy.type)
			assertNull(smy.deducedFrom) // Note: NULL -- no rule, attribute added explicitly
		}
		//
		val sma2 = sm.types.get(5) as DEntityType
		assertEquals("SMA2", sma2.name)
		assertTrue(sma2.synthetic)
		assertEquals(sma2Deduction, sma2.deducedFrom)
		assertEquals(a, sma2.deducedFrom.deductionRule.source)
		{
			assertEquals(1, sma2.features.size)
			val smx = sma2.features.get(0) as DAttribute
			assertTrue(smx.synthetic)
			assertEquals("x", smx.name)
			assertEquals(st, smx.type)
			val smxDeduction = smx.deducedFrom as SFeatureDeduction
			assertTrue(smxDeduction.deductionRule instanceof SGrabRule)
			assertEquals(x, smx.deducedFrom.deductionRule.source)
		}
	}

	@Test
	def void grabQuery() {
		val resourceSet = resourceSetProvider.get
		//
		val dmx = loadDmx(resourceSet)
		val at = dmx.types.get(0) as DmxArchetype

		val dim = loadComponentDim(resourceSet, at)
		val acomp = dim.aggregates.get(0)
		val q = acomp.features.get(0) as DQuery
		val p1 = q.parameters.get(0) as DQueryParameter

		val smNS = simParseHelper.parse('''
			system SM
			core information model SM1 {
				grab primitive dm.types.AT as ST
				grab aggregate DM.AComp as SAggr {
					grab query q as sq1 (add p2 : ST)
					grab query q as sq2 (grab p1 as p0)
				}
			}
		''', resourceSet)
		assertNoParseErrors(smNS, "sm")
		val sm = smNS.model as SInformationModel
		assertNotNull(sm)
		//
		assertEquals(2, sm.types.size)
		val stDeduction = sm.types.get(0) as SPrimitiveDeduction
		assertFalse(stDeduction.synthetic)
		assertTrue(stDeduction.deductionRule instanceof SGrabRule)
		//
		val st = sm.types.get(1) as DPrimitive
		assertEquals("ST", st.name)
		assertTrue(st.synthetic)
		assertEquals(stDeduction, st.deducedFrom)
		assertEquals(at, st.deducedFrom.deductionRule.source)
		//
		assertEquals(2, sm.aggregates.size)
		val sAggrDeduction = sm.aggregates.get(0) as SAggregateDeduction
		assertFalse(sAggrDeduction.synthetic)
		assertTrue(sAggrDeduction.deductionRule instanceof SGrabAggregateRule)
		assertEquals(2, sAggrDeduction.features.size)
		val sq1Deduction = sAggrDeduction.features.get(0) as SQueryDeduction
		val sq2Deduction = sAggrDeduction.features.get(1) as SQueryDeduction
		//
		val sAggr = sm.aggregates.get(1) as DAggregate
		assertTrue(sAggr.synthetic)
		assertEquals(sAggrDeduction, sAggr.deducedFrom)
		assertEquals(acomp, sAggr.deducedFrom.deductionRule.source)
		//
		assertEquals(2, sAggr.features.size)
		val sq1 = sAggr.features.get(0) as DQuery
		assertEquals("sq1", sq1.name)
		assertTrue(sq1.synthetic)
		assertEquals(sq1Deduction, sq1.deducedFrom)
		assertEquals(q, sq1.deducedFrom.deductionRule.source)
		{
			assertEquals(2, sq1.parameters.size)
			val sp1 = sq1.parameters.get(0) as DQueryParameter
			assertTrue(sp1.synthetic)
			assertEquals("p1", sp1.name)
			assertEquals(st, sp1.type)
			val sp1Deduction = sp1.deducedFrom as DImplicitDeduction
			assertTrue(sp1Deduction.deductionRule instanceof SGrabRule)
			assertEquals(p1, sp1.deducedFrom.deductionRule.source)
			//
			val sp2 = sq1.parameters.get(1) as DQueryParameter
			assertTrue(sp2.synthetic)
			assertEquals("p2", sp2.name)
			assertEquals(st, sp2.type)
			assertNull(sp2.deducedFrom) // Note: NULL -- no rule, parameter added explicitly
		}
		//
		val sq2 = sAggr.features.get(1) as DQuery
		assertEquals("sq2", sq2.name)
		assertTrue(sq2.synthetic)
		assertEquals(sq2Deduction, sq2.deducedFrom)
		assertEquals(q, sq2.deducedFrom.deductionRule.source)
		{
			assertEquals(1, sq2.parameters.size)
			val sp0 = sq2.parameters.get(0) as DQueryParameter
			assertTrue(sp0.synthetic)
			assertEquals("p0", sp0.name)
			assertEquals(st, sp0.type)
			val sp0Deduction = sp0.deducedFrom as SQueryParameterDeduction
			assertTrue(sp0Deduction.deductionRule instanceof SGrabRule)
			assertEquals(p1, sp0.deducedFrom.deductionRule.source)
		}
	}

	@Test
	def void grabAggregate() {
		val resourceSet = resourceSetProvider.get
		//
		val dmx = loadDmx(resourceSet)
		val at = dmx.types.get(0) as DmxArchetype

		val dim = loadComponentDim(resourceSet, at)
		val acomp = dim.aggregates.get(0)
		val a = acomp.types.get(0) as DEntityType
		val x = a.features.get(0) as DAttribute

		val smNS = simParseHelper.parse('''
			system SM
			core information model SM1 {
				grab primitive dm.types.AT as ST
				grab aggregate DM.AComp as SAggr {}
			}
		''', resourceSet)
		assertNoParseErrors(smNS, "sm")
		val sm = smNS.model as SInformationModel
		assertNotNull(sm)
		//
		assertEquals(2, sm.types.size)
		val stDeduction = sm.types.get(0) as SPrimitiveDeduction
		assertFalse(stDeduction.synthetic)
		assertTrue(stDeduction.deductionRule instanceof SGrabRule)
		//
		val st = sm.types.get(1) as DPrimitive
		assertEquals("ST", st.name)
		assertTrue(st.synthetic)
		assertEquals(stDeduction, st.deducedFrom)
		assertEquals(at, st.deducedFrom.deductionRule.source)
		//
		assertEquals(2, sm.aggregates.size)
		val sAggrDeduction = sm.aggregates.get(0) as SAggregateDeduction
		assertFalse(sAggrDeduction.synthetic)
		assertTrue(sAggrDeduction.deductionRule instanceof SGrabAggregateRule)
		//
		val sAggr = sm.aggregates.get(1) as DAggregate
		assertTrue(sAggr.synthetic)
		assertEquals(sAggrDeduction, sAggr.deducedFrom)
		assertEquals(acomp, sAggr.deducedFrom.deductionRule.source)
		//
		assertEquals(1, sAggr.types.size)
		val sma = sAggr.types.get(0) as DEntityType
		assertEquals("A", sma.name)
		assertTrue(sma.synthetic)
		val smaDeduction = sma.deducedFrom as DImplicitDeduction
		assertTrue(smaDeduction.deductionRule instanceof SGrabRule)
		assertEquals(a, sma.deducedFrom.deductionRule.source)
		//
		assertEquals(1, sma.features.size)
		val smx = sma.features.get(0) as DAttribute
		assertTrue(smx.synthetic)
		assertEquals("x", smx.name)
		assertEquals(st, smx.type)
		val smxDeduction = smx.deducedFrom as DImplicitDeduction
		assertTrue(smxDeduction.deductionRule instanceof SGrabRule)
		assertEquals(x, smx.deducedFrom.deductionRule.source)
	}

	protected def assertNoParseErrors(DNamespace ns, String name) {
		assertNotNull(ns)
		val errors = ns.eResource.errors
		assertTrue(errors.isEmpty, '''Unexpected errors in «name» ': «errors.join(", ")»''')
	}
}
