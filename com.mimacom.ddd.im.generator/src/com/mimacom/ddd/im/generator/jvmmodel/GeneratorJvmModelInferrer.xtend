/*
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.im.generator.jvmmodel

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DFeature
import com.mimacom.ddd.dm.base.DNamedElement
import com.mimacom.ddd.dm.base.DNamespace
import com.mimacom.ddd.dm.base.DType
import com.mimacom.ddd.im.generator.generator.EndpointDeclaration
import com.mimacom.ddd.im.generator.generator.EndpointDeclarationBlock
import com.mimacom.ddd.im.generator.generator.ExceptionMapping
import com.mimacom.ddd.im.generator.generator.Model
import com.mimacom.ddd.sm.asm.SDirection
import com.mimacom.ddd.sm.asm.SException
import com.mimacom.ddd.sm.asm.SServiceParameter
import java.util.HashMap
import java.util.List
import java.util.Map
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class GeneratorJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider
	
	@Inject IJvmModelAssociations associations
	
	@Inject GeneratorTypesHelper typesHelper
	
	def Iterable<DType> getParameterTypeReferences(EndpointDeclarationBlock block) {
		block.endpoints.flatMap[name.parameters].map[type]
	}
	
	def dispatch generateForType(EObject container, DType element, IJvmDeclaredTypeAcceptor acceptor) {
		throw new UnsupportedOperationException("cannot generate for " + element)
	}
	
	def dispatch generateForType(EObject container, DComplexType element, IJvmDeclaredTypeAcceptor acceptor) {
		val jvmType = container.toClass(element.qualifiedName)
		acceptor.accept(jvmType) [
			for (DFeature f : element.features) {
				if (f.type !== null) {
					val refFeatureType = typesHelper.toType(_typeReferenceBuilder, f.type)
					val field = f.toField(f.name, refFeatureType)
					members += field
				}
			}
		]
		jvmType
	}

	def dispatch void infer(EndpointDeclarationBlock element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) return
		
		// generate types for all operation parameter types
		val Map<DType, JvmGenericType> paramTypeToJvmType = new HashMap
		for (endpoint : element.endpoints) {
			for (p : endpoint.name.parameters.filter[type !== null]) {
				val jvmType = endpoint.generateForType(p.type, acceptor)
				paramTypeToJvmType.put(p.type, jvmType)
			}
		}
		
		// TODO [gh-19] accept all required types first, i.e. DEnumeration, DEntityType/DComplexType
		
		acceptor.accept(element.toClass(element.qualifiedName)) [p|
			p.documentation = element.documentation
			
			// TODO [gh-19] annotations+=... in order to get these, the annotation types must be on the classpath :-/
			
			for (EndpointDeclaration endpoint: element.endpoints.filter[name !== null]) {
				val operation = endpoint.name
				
				var JvmTypeReference operationReturnType 
				val outboundType = operation.parameters.filter[direction === SDirection.OUTBOUND].head?.type
				if (outboundType !== null && paramTypeToJvmType.containsKey(outboundType)) {
				 	operationReturnType = typeRef(paramTypeToJvmType.get(outboundType))
				} else {
				 	operationReturnType = typeRef(Void) // TODO [gh-19] generates 'return Void'
				}
				
				p.members+=endpoint.toMethod(operation.name, operationReturnType)[
					if (endpoint.name.raises !== null) {
						val me = getMappedExceptions(acceptor, EcoreUtil2.getContainerOfType(endpoint, Model), endpoint.name.raises)
						exceptions+=me
					}
					for (SServiceParameter arg: operation.parameters.filter[direction === SDirection.INBOUND && paramTypeToJvmType.containsKey(type)]) {
						val paramTypeRef = typeRef(paramTypeToJvmType.get(arg.type))
						parameters+=endpoint.toParameter(arg.name, paramTypeRef)
					}
					body='''
						throw new UnsupportedOperationException("Not yet implemented");
					'''
				]
			}
		]
	}
	
	private def Iterable<JvmTypeReference> getMappedExceptions(IJvmDeclaredTypeAcceptor acceptor, Model model, List<SException> exceptions) {
		val mappings = model.exceptionMappings.filter[exceptions.contains(it.name)].toList
		
		val typeRefsOfMappedExceptions = mappings
			.flatMap[associations.getJvmElements(it)]
			.filter[it instanceof JvmDeclaredType]
			.map[it as JvmDeclaredType]
			.map[typeRef]
			.toList
		
		if (exceptions.size === typeRefsOfMappedExceptions.size) return typeRefsOfMappedExceptions
		
		// there are additional unmapped exceptions, i.e. exceptions not modeled in gen model
		
		val unmappedExceptions = exceptions.dropWhile[mappings.exists[e|it == e.name]].toList
		val additionalExceptionTypes = unmappedExceptions.map[toExceptionType(model)]
		additionalExceptionTypes.forEach[acceptor.accept(it)] // triggers code gen of types
		val typeRefsOfUnmappedExceptions = (additionalExceptionTypes).map[typeRef]
		
		return typeRefsOfMappedExceptions + typeRefsOfUnmappedExceptions
	} 

	def dispatch void infer(ExceptionMapping element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val qualifiedName = element.getQualifiedName
		if (qualifiedName !== null)
			acceptor.accept(element.toClass(qualifiedName)) [
				documentation = element.documentation

				// extends
				var JvmTypeReference parentException
				if (element.extends !== null)
					parentException = element.extends.typeRef
				else
					parentException = typeRef(RuntimeException)
				if (parentException !== null)
					superTypes += parentException

				// message
				members += element.toConstructor [
					if (element.message !== null)
						body = '''super("«element.message»");'''
				]
			]
	}
	
	private def JvmGenericType toExceptionType(SException exception, Model model) {
		model.toClass(exception.getQualifiedName) [
			superTypes += typeRef(Exception)
		]
	}

	private def getPackageName(DComplexType complexType) {
		val namespace = EcoreUtil2.getContainerOfType(complexType, DNamespace)
		namespace.name + '.dto'
	}

	private def getPackageName(EndpointDeclarationBlock block) {
		val fqn = block.fullyQualifiedName
		val declaredPackageName = fqn.segments
			.drop(1) // ignore gen model name
			.take(fqn.segmentCount-2) // first and last ignored
			.map[toString.toLowerCase]
			.join('.')
		declaredPackageName  + '.controller'
	}
	
	private def dispatch getQualifiedName(DComplexType complexType) {
		complexType.packageName + '.' + complexType.name
	}
	
	private def dispatch getQualifiedName(DNamedElement element) {
		val fqn = element.fullyQualifiedName
		var String packageName = ''
		if (fqn.segmentCount > 1) {
			packageName = fqn.segments.take(fqn.segmentCount-1).map[toLowerCase].join('.') + '.' 
		} 
		packageName + fqn.segments.last.toString
	}

	private def dispatch getQualifiedName(EndpointDeclarationBlock block) {
		val declaredTypeName = block.fullyQualifiedName.segments.last
		val controller = declaredTypeName.endsWith('Controller') || declaredTypeName.endsWith('RestResource')
			? declaredTypeName 
			: declaredTypeName + 'Controller'
		block.packageName + '.' + controller
	}
	
	private def dispatch getQualifiedName(ExceptionMapping mapping) {
		if (mapping.package !== null)
			return '''«mapping.package.toLowerCase».«mapping.name.name»'''
		val qualifiedName = mapping.name?.fullyQualifiedName
		if (qualifiedName !== null) {
			val packageName = qualifiedName.segments.take(qualifiedName.segmentCount - 1).map[toLowerCase].join('.')
			return '''«packageName».«qualifiedName.lastSegment.toString»'''
		}
		return null
	}
}
