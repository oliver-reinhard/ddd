/*
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.im.generator.jvmmodel

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.DAttribute
import com.mimacom.ddd.dm.base.base.DComplexType
import com.mimacom.ddd.dm.base.base.DEnumeration
import com.mimacom.ddd.dm.base.base.DFeature
import com.mimacom.ddd.dm.base.base.DNamedElement
import com.mimacom.ddd.dm.base.base.DNamespace
import com.mimacom.ddd.dm.base.base.DPrimitive
import com.mimacom.ddd.dm.base.base.DSimpleType
import com.mimacom.ddd.dm.base.base.DType
import com.mimacom.ddd.dm.base.transpose.ITransposableElement
import com.mimacom.ddd.dm.base.transpose.TTranspositionRule
import com.mimacom.ddd.dm.dmx.DmxArchetype
import com.mimacom.ddd.im.generator.generator.EndpointDeclaration
import com.mimacom.ddd.im.generator.generator.EndpointDeclarationBlock
import com.mimacom.ddd.im.generator.generator.ExceptionMapping
import com.mimacom.ddd.im.generator.generator.HttpVerb
import com.mimacom.ddd.im.generator.generator.Model
import com.mimacom.ddd.im.generator.generator.Path
import com.mimacom.ddd.im.generator.generator.TypeMapping
import com.mimacom.ddd.sm.asm.AsmException
import com.mimacom.ddd.sm.asm.AsmParameterDirection
import com.mimacom.ddd.sm.asm.AsmServiceParameter
import java.math.BigDecimal
import java.math.BigInteger
import java.time.Duration
import java.time.ZonedDateTime
import java.util.List
import java.util.Map
import java.util.Objects
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class GeneratorJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	@Inject IJvmModelAssociations associations

	def dispatch void infer(ExceptionMapping element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		val qualifiedName = element.qualifiedName
		if (qualifiedName !== null)
			acceptor.accept(element.toClass(qualifiedName)) [
				documentation = element.documentation

				// extends
				var JvmTypeReference parentException
				if (element.extends !== null)
					parentException = element.extends.typeRef
				else
					parentException = typeRef(RuntimeException)
				if (parentException !== null)
					superTypes += parentException

				// message
				members += element.toConstructor [
					if (element.message !== null)
						body = '''super("«element.message»");'''
				]
			]
	}

	def dispatch void infer(EndpointDeclarationBlock element, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		if (isPreIndexingPhase) return

		/* 
		 * Generate code for all directly and indirectly referenced types; these will be used in the acceptor below;
		 * a ConcurrentModificationException is raised if one tries to recursively accept types, this must be done in
		 * a sequential fashion. Since referenced endpoint parameter types are not associated with this context element's
		 * resource, they are associated with given context element.
		 */
		val allTypes = element.getAllReferencedEndpointTypes
		allTypes.values.forEach[element.generateForType(it, acceptor)]

		val mappings = (element.eContainer as Model).typeMappings

		acceptor.accept(element.toClass(element.qualifiedName)) [
			documentation = element.documentation

			annotations += annotationRef(RestController)

			for (EndpointDeclaration endpoint : element.endpoints.filter[name !== null && type !== null]) {
				val operation = endpoint.type

				var JvmTypeReference operationReturnType
				val resultParameter = operation.parameters.filter[getDirection === AsmParameterDirection.OUTBOUND].head
				val outboundType = operation.parameters.filter[getDirection === AsmParameterDirection.OUTBOUND].head?.type
				if (outboundType !== null) {
					if (resultParameter.multiplicity !== null)
						operationReturnType = typeRef(List, toType(mappings, outboundType))
					else
						operationReturnType = toType(mappings, outboundType)
				} else {
					operationReturnType = typeRef(ResponseEntity)
				}

				members += endpoint.toMethod(operation.getName, operationReturnType) [
					documentation = endpoint.documentation
					annotations += annotationRef(endpoint.verb.toMethodAnnotationClass, endpoint.path.getEndpointPathAsString)
					if (endpoint.type.raises !== null) {
						val me = getMappedExceptions(acceptor, EcoreUtil2.getContainerOfType(endpoint, Model), endpoint.type.raises)
						exceptions += me
					}
					for (AsmServiceParameter param : operation.parameters.filter[getDirection === AsmParameterDirection.INBOUND]) {
						val paramTypeRef = toType(mappings, param.type)
						val parameter = endpoint.toParameter(param.name, paramTypeRef)
						parameter.annotations += endpoint.getParameterAnnotations(param)
						parameters += parameter
					}
					body = '''throw new UnsupportedOperationException("Not yet implemented");'''
				]
			}
		]
	}

	/*
	 * generateForType
	 */
	def dispatch JvmTypeReference generateForType(EObject container, DType element, IJvmDeclaredTypeAcceptor acceptor) {
		val mappings = EcoreUtil2.getContainerOfType(container, Model).typeMappings
		toType(mappings, element)
	}

	def dispatch JvmTypeReference generateForType(EObject container, DEnumeration element, IJvmDeclaredTypeAcceptor acceptor) {
		val jvmType = container.toEnumerationType(element.qualifiedName)
		acceptor.accept(jvmType) [
			members += element.literals.map[name].map[container.toEnumerationLiteral(it)]
		]
		typeRef(jvmType)
	}

	def dispatch JvmTypeReference generateForType(EObject container, DComplexType element, IJvmDeclaredTypeAcceptor acceptor) {
		val jvmType = container.toClass(element.qualifiedName)
		acceptor.accept(jvmType)[generateComplexType(container, element)]
		typeRef(jvmType)
	}

	/*
	 * getAllReferencedTypes
	 */
	private def dispatch Map<String, DType> getAllReferencedTypes(DType fallback) {
		emptyMap
	}

	private def dispatch Map<String, DType> getAllReferencedTypes(DComplexType complexType) {
		val result = newHashMap
		result.put(complexType.qualifiedName, complexType)
		complexType.features.filter[type !== null].forEach[result.putAll(type.getAllReferencedTypes)]
		result
	}

	private def dispatch Map<String, DType> getAllReferencedTypes(DSimpleType simpleType) {
		#{simpleType.qualifiedName -> simpleType}
	}

	private def dispatch Map<String, DType> getAllReferencedTypes(DEnumeration enumeration) {
		#{enumeration.qualifiedName -> enumeration}
	}

	/*
	 * toQualifiedName
	 */
	private def dispatch getQualifiedName(ExceptionMapping exceptionMapping) {
		val declaredTypeName = exceptionMapping.fullyQualifiedName.segments.last
		val exception = declaredTypeName.endsWith('Exception') ? declaredTypeName : declaredTypeName + 'Exception'
		exceptionMapping.packageName + '.' + exception
	}

	private def dispatch getQualifiedName(EndpointDeclarationBlock block) {
		val declaredTypeName = block.fullyQualifiedName.segments.last
		val controller = declaredTypeName.endsWith('Controller') || declaredTypeName.endsWith('RestResource') ? declaredTypeName : declaredTypeName +
				'Controller'
		block.packageName + '.' + controller
	}

	private def dispatch getQualifiedName(DEnumeration enumeration) {
		enumeration.packageName + '.' + enumeration.name
	}

	private def dispatch getQualifiedName(DComplexType complexType) {
		complexType.packageName + '.' + complexType.name
	}

	private def dispatch getQualifiedName(DNamedElement element) {
		val fqn = element.fullyQualifiedName
		var String packageName = ''
		if (fqn.segmentCount > 1) {
			packageName = fqn.segments.take(fqn.segmentCount - 1).map[toLowerCase].join('.') + '.'
		}
		packageName + fqn.segments.last.toString
	}

	/*
	 * getPackageName
	 */
	private def dispatch getPackageName(DEnumeration enumeration) {
		val namespace = EcoreUtil2.getContainerOfType(enumeration, DNamespace)
		namespace.name
	}

	private def dispatch getPackageName(DComplexType complexType) {
		val namespace = EcoreUtil2.getContainerOfType(complexType, DNamespace)
		namespace.name + '.dto'
	}

	private def dispatch getPackageName(ExceptionMapping exceptionMapping) {
		exceptionMapping.getRootPackageName + '.exception'
	}

	private def dispatch getPackageName(EndpointDeclarationBlock block) {
		block.getRootPackageName + '.controller'
	}

	/*
	 * toType
	 */
	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DType type) {
		if (type.name === null) typeRef(Object)
		typeRef(type.qualifiedName)
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DEnumeration enumeration) {
		typeRef(enumeration.qualifiedName)
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DComplexType complexType) {
		if (complexType.name === null) typeRef(Object)
		typeRef(complexType.qualifiedName)
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DAttribute attribute) {
		toType(mappings, attribute.type)
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DPrimitive primitive) {
		if (primitive.redefines !== null) {
			return toType(mappings, primitive.redefines)
		}
		if (primitive instanceof ITransposableElement) {
			if (primitive.transposedBy?.rule !== null) {
				return toType(mappings, primitive.transposedBy.rule)
			}
		}
		return typeRef(Object) // fallback
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, TTranspositionRule deductionRule) {
		toType(mappings, deductionRule.getSource)
	}

	def dispatch JvmTypeReference toType(Iterable<TypeMapping> mappings, DmxArchetype archetype) {
		val mappingsForType = mappings.filter[type.name == archetype.name].toList
		if (!mappingsForType.empty) {
			// assume there is at most one such mapping (implement validation!)
			return typeRef(mappingsForType.head.javaType)
		}
		switch (archetype.name) {
			case 'ID',
			case 'Name',
			case 'ShortText',
			case 'Text':
				typeRef(String)
			case 'Boolean':
				typeRef(Boolean)
			case 'Natural',
			case 'Natural0',
			case 'Integer':
				typeRef(BigInteger)
			case 'Real':
				typeRef(BigDecimal)
			case 'Timepoint':
				typeRef(ZonedDateTime)
			case 'Duration':
				typeRef(Duration)
			default:
				throw new IllegalArgumentException("unsupported archetype: " + archetype.name)
		}
	}

	/*
	 * other utility methods
	 */
	private def Map<String, DType> getAllReferencedEndpointTypes(EndpointDeclarationBlock block) {
		val allParameterTypes = block.endpoints.flatMap[type.parameters].filter[type !== null].map[type].toList
		val result = newHashMap
		allParameterTypes.forEach[result.putAll(allReferencedTypes)]
		return result
	}

	private def getParameterAnnotations(EndpointDeclaration endpoint, AsmServiceParameter param) {
		val annotations = newArrayList
		if (param.isPathParameter(endpoint.path))
			annotations += annotationRef(PathVariable)
		else if (endpoint.verb == HttpVerb.POST || endpoint.verb == HttpVerb.PUT)
			annotations += annotationRef(RequestBody)
		else
			annotations += annotationRef(RequestParam)
		annotations
	}

	private def isPathParameter(AsmServiceParameter param, Path path) {
		path.segments.exists[name == param.name && variable]
	}

	def generateComplexType(JvmDeclaredType it, EObject container, DComplexType element) {
		val typeName = simpleName
		val mappings = EcoreUtil2.getContainerOfType(container, Model).typeMappings
		for (DFeature f : element.features) {
			if (f.type !== null) {
				val refFeatureType = toType(mappings, f.type)
				val field = container.toField(f.name, refFeatureType)
				members += field
			}
		}
		val getters = newArrayList
		for (DFeature f : element.features) {
			if (f.type !== null) {
				val refFeatureType = toType(mappings, f.type)
				val getter = f.toGetter(f.name, refFeatureType)
				getters.add(getter)
				members += getter
				members += f.toSetter(f.name, refFeatureType)
			}
		}
		members += container.toToStringMethod(it)

		if (!getters.empty)
			members += container.toMethod('equals', typeRef(boolean)) [
				annotations += annotationRef(Override)
				parameters += container.toParameter('o', typeRef(Object))
				body = '''
					if (this == o) return true;
					if (o == null || getClass() != o.getClass()) return false;
					«typeName» that = («typeName») o;
					return
						«FOR f : getters SEPARATOR ' &&' + newLine»«typeRef(Objects)».equals(«f.simpleName»(), that.«f.simpleName»())«ENDFOR»;
				'''
			]
		members += container.toMethod('hashCode', typeRef(int)) [
			annotations += annotationRef(Override)
			body = '''
				return «typeRef(Objects)».hash(
					«FOR f : getters SEPARATOR ',' + newLine»«f.simpleName»()«ENDFOR»
				);
			'''
		]
	}

	private def newLine() {
		System.getProperty('line.separator')
	}

	private def Class<?> toMethodAnnotationClass(HttpVerb verb) {
		switch (verb) {
			case HttpVerb.GET: {
				GetMapping
			}
			case HttpVerb.PUT: {
				PutMapping
			}
			case HttpVerb.POST: {
				PostMapping
			}
			case HttpVerb.DELETE: {
				DeleteMapping
			}
			case HttpVerb.PATCH: {
				PatchMapping
			}
			default: {
				throw new IllegalArgumentException("invalid HTTP verb: " + verb)
			}
		}
	}

	private def Iterable<JvmTypeReference> getMappedExceptions(IJvmDeclaredTypeAcceptor acceptor, Model model, List<AsmException> exceptions) {
		val mappings = model.exceptionMappings.filter[exceptions.contains(it.type)].toList

		val typeRefsOfMappedExceptions = mappings.flatMap[associations.getJvmElements(it)].filter [
			it instanceof JvmDeclaredType
		].map[it as JvmDeclaredType].map[typeRef].toList

		if (exceptions.size === typeRefsOfMappedExceptions.size) return typeRefsOfMappedExceptions

		// there are additional unmapped exceptions, i.e. exceptions not modeled in gen model
		val unmappedExceptions = exceptions.dropWhile[mappings.exists[e|it == e.name]].toList
		val additionalExceptionTypes = unmappedExceptions.map[toExceptionType(model)]
		additionalExceptionTypes.forEach[acceptor.accept(it)] // triggers code gen of types
		val typeRefsOfUnmappedExceptions = (additionalExceptionTypes).map[typeRef]

		return typeRefsOfMappedExceptions + typeRefsOfUnmappedExceptions
	}

	private def JvmGenericType toExceptionType(AsmException exception, Model model) {
		model.toClass(exception.getQualifiedName) [
			superTypes += typeRef(Exception)
		]
	}

	private def getEndpointPathAsString(Path path) {
		if (path === null) return null
		val prefix = path.leadingSlash ? '/' : ''
		prefix + path.segments.map[isVariable ? '{' + it.name + '}' : it.name].join('/')
	}

	private def getRootPackageName(EObject child) {
		val fqn = EcoreUtil2.getContainerOfType(child, Model).fullyQualifiedName
		return fqn.segments.take(fqn.segmentCount - 1) // last ignored
		.map[toString.toLowerCase].join('.')
	}
}
