/**
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.im.generator.jvmmodel;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.DComplexType;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DNamedElement;
import com.mimacom.ddd.dm.base.DNamespace;
import com.mimacom.ddd.dm.base.DType;
import com.mimacom.ddd.im.generator.generator.EndpointDeclaration;
import com.mimacom.ddd.im.generator.generator.EndpointDeclarationBlock;
import com.mimacom.ddd.im.generator.generator.ExceptionMapping;
import com.mimacom.ddd.im.generator.generator.Model;
import com.mimacom.ddd.im.generator.jvmmodel.GeneratorTypesHelper;
import com.mimacom.ddd.sm.asm.SDirection;
import com.mimacom.ddd.sm.asm.SException;
import com.mimacom.ddd.sm.asm.SServiceOperation;
import com.mimacom.ddd.sm.asm.SServiceParameter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmConstructor;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

/**
 * <p>Infers a JVM model from the source model.</p>
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 */
@SuppressWarnings("all")
public class GeneratorJvmModelInferrer extends AbstractModelInferrer {
  /**
   * convenience API to build and initialize JVM types and their members.
   */
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Inject
  private IJvmModelAssociations associations;
  
  @Inject
  private GeneratorTypesHelper typesHelper;
  
  public Iterable<DType> getParameterTypeReferences(final EndpointDeclarationBlock block) {
    final Function1<EndpointDeclaration, EList<SServiceParameter>> _function = (EndpointDeclaration it) -> {
      return it.getName().getParameters();
    };
    final Function1<SServiceParameter, DType> _function_1 = (SServiceParameter it) -> {
      return it.getType();
    };
    return IterableExtensions.<SServiceParameter, DType>map(IterableExtensions.<EndpointDeclaration, SServiceParameter>flatMap(block.getEndpoints(), _function), _function_1);
  }
  
  protected JvmGenericType _generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    throw new UnsupportedOperationException(("cannot generate for " + element));
  }
  
  protected JvmGenericType _generateForType(final EObject container, final DComplexType element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmGenericType _xblockexpression = null;
    {
      final JvmGenericType jvmType = this._jvmTypesBuilder.toClass(container, this.getQualifiedName(element));
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        EList<DFeature> _features = element.getFeatures();
        for (final DFeature f : _features) {
          DType _type = f.getType();
          boolean _tripleNotEquals = (_type != null);
          if (_tripleNotEquals) {
            final JvmTypeReference refFeatureType = this.typesHelper.toType(this._typeReferenceBuilder, f.getType());
            final JvmField field = this._jvmTypesBuilder.toField(f, f.getName(), refFeatureType);
            EList<JvmMember> _members = it.getMembers();
            this._jvmTypesBuilder.<JvmField>operator_add(_members, field);
          }
        }
      };
      acceptor.<JvmGenericType>accept(jvmType, _function);
      _xblockexpression = jvmType;
    }
    return _xblockexpression;
  }
  
  protected void _infer(final EndpointDeclarationBlock element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (isPreIndexingPhase) {
      return;
    }
    final Map<DType, JvmGenericType> paramTypeToJvmType = new HashMap<DType, JvmGenericType>();
    EList<EndpointDeclaration> _endpoints = element.getEndpoints();
    for (final EndpointDeclaration endpoint : _endpoints) {
      final Function1<SServiceParameter, Boolean> _function = (SServiceParameter it) -> {
        DType _type = it.getType();
        return Boolean.valueOf((_type != null));
      };
      Iterable<SServiceParameter> _filter = IterableExtensions.<SServiceParameter>filter(endpoint.getName().getParameters(), _function);
      for (final SServiceParameter p : _filter) {
        {
          final JvmGenericType jvmType = this.generateForType(endpoint, p.getType(), acceptor);
          paramTypeToJvmType.put(p.getType(), jvmType);
        }
      }
    }
    final Procedure1<JvmGenericType> _function_1 = (JvmGenericType p_1) -> {
      this._jvmTypesBuilder.setDocumentation(p_1, this._jvmTypesBuilder.getDocumentation(element));
      final Function1<EndpointDeclaration, Boolean> _function_2 = (EndpointDeclaration it) -> {
        SServiceOperation _name = it.getName();
        return Boolean.valueOf((_name != null));
      };
      Iterable<EndpointDeclaration> _filter_1 = IterableExtensions.<EndpointDeclaration>filter(element.getEndpoints(), _function_2);
      for (final EndpointDeclaration endpoint_1 : _filter_1) {
        {
          final SServiceOperation operation = endpoint_1.getName();
          JvmTypeReference operationReturnType = null;
          final Function1<SServiceParameter, Boolean> _function_3 = (SServiceParameter it) -> {
            SDirection _direction = it.getDirection();
            return Boolean.valueOf((_direction == SDirection.OUTBOUND));
          };
          SServiceParameter _head = IterableExtensions.<SServiceParameter>head(IterableExtensions.<SServiceParameter>filter(operation.getParameters(), _function_3));
          DType _type = null;
          if (_head!=null) {
            _type=_head.getType();
          }
          final DType outboundType = _type;
          if (((outboundType != null) && paramTypeToJvmType.containsKey(outboundType))) {
            operationReturnType = this._typeReferenceBuilder.typeRef(paramTypeToJvmType.get(outboundType));
          } else {
            operationReturnType = this._typeReferenceBuilder.typeRef(Void.class);
          }
          EList<JvmMember> _members = p_1.getMembers();
          final Procedure1<JvmOperation> _function_4 = (JvmOperation it) -> {
            EList<SException> _raises = endpoint_1.getName().getRaises();
            boolean _tripleNotEquals = (_raises != null);
            if (_tripleNotEquals) {
              final Iterable<JvmTypeReference> me = this.getMappedExceptions(acceptor, EcoreUtil2.<Model>getContainerOfType(endpoint_1, Model.class), endpoint_1.getName().getRaises());
              EList<JvmTypeReference> _exceptions = it.getExceptions();
              this._jvmTypesBuilder.<JvmTypeReference>operator_add(_exceptions, me);
            }
            final Function1<SServiceParameter, Boolean> _function_5 = (SServiceParameter it_1) -> {
              return Boolean.valueOf(((it_1.getDirection() == SDirection.INBOUND) && paramTypeToJvmType.containsKey(it_1.getType())));
            };
            Iterable<SServiceParameter> _filter_2 = IterableExtensions.<SServiceParameter>filter(operation.getParameters(), _function_5);
            for (final SServiceParameter arg : _filter_2) {
              {
                final JvmTypeReference paramTypeRef = this._typeReferenceBuilder.typeRef(paramTypeToJvmType.get(arg.getType()));
                EList<JvmFormalParameter> _parameters = it.getParameters();
                JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(endpoint_1, arg.getName(), paramTypeRef);
                this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
              }
            }
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("throw new UnsupportedOperationException(\"Not yet implemented\");");
                _builder.newLine();
              }
            };
            this._jvmTypesBuilder.setBody(it, _client);
          };
          JvmOperation _method = this._jvmTypesBuilder.toMethod(endpoint_1, operation.getName(), operationReturnType, _function_4);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members, _method);
        }
      }
    };
    acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, this.getQualifiedName(element)), _function_1);
  }
  
  private Iterable<JvmTypeReference> getMappedExceptions(final IJvmDeclaredTypeAcceptor acceptor, final Model model, final List<SException> exceptions) {
    final Function1<ExceptionMapping, Boolean> _function = (ExceptionMapping it) -> {
      return Boolean.valueOf(exceptions.contains(it.getName()));
    };
    final List<ExceptionMapping> mappings = IterableExtensions.<ExceptionMapping>toList(IterableExtensions.<ExceptionMapping>filter(model.getExceptionMappings(), _function));
    final Function1<ExceptionMapping, Set<EObject>> _function_1 = (ExceptionMapping it) -> {
      return this.associations.getJvmElements(it);
    };
    final Function1<EObject, Boolean> _function_2 = (EObject it) -> {
      return Boolean.valueOf((it instanceof JvmDeclaredType));
    };
    final Function1<EObject, JvmDeclaredType> _function_3 = (EObject it) -> {
      return ((JvmDeclaredType) it);
    };
    final Function1<JvmDeclaredType, JvmTypeReference> _function_4 = (JvmDeclaredType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfMappedExceptions = IterableExtensions.<JvmTypeReference>toList(IterableExtensions.<JvmDeclaredType, JvmTypeReference>map(IterableExtensions.<EObject, JvmDeclaredType>map(IterableExtensions.<EObject>filter(IterableExtensions.<ExceptionMapping, EObject>flatMap(mappings, _function_1), _function_2), _function_3), _function_4));
    int _size = exceptions.size();
    int _size_1 = typeRefsOfMappedExceptions.size();
    boolean _tripleEquals = (_size == _size_1);
    if (_tripleEquals) {
      return typeRefsOfMappedExceptions;
    }
    final Function1<SException, Boolean> _function_5 = (SException it) -> {
      final Function1<ExceptionMapping, Boolean> _function_6 = (ExceptionMapping e) -> {
        SException _name = e.getName();
        return Boolean.valueOf(Objects.equal(it, _name));
      };
      return Boolean.valueOf(IterableExtensions.<ExceptionMapping>exists(mappings, _function_6));
    };
    final List<SException> unmappedExceptions = IterableExtensions.<SException>toList(IterableExtensions.<SException>dropWhile(exceptions, _function_5));
    final Function1<SException, JvmGenericType> _function_6 = (SException it) -> {
      return this.toExceptionType(it, model);
    };
    final List<JvmGenericType> additionalExceptionTypes = ListExtensions.<SException, JvmGenericType>map(unmappedExceptions, _function_6);
    final Consumer<JvmGenericType> _function_7 = (JvmGenericType it) -> {
      acceptor.<JvmGenericType>accept(it);
    };
    additionalExceptionTypes.forEach(_function_7);
    final Function1<JvmGenericType, JvmTypeReference> _function_8 = (JvmGenericType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfUnmappedExceptions = ListExtensions.<JvmGenericType, JvmTypeReference>map(additionalExceptionTypes, _function_8);
    return Iterables.<JvmTypeReference>concat(typeRefsOfMappedExceptions, typeRefsOfUnmappedExceptions);
  }
  
  protected void _infer(final ExceptionMapping element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    final String qualifiedName = this.getQualifiedName(element);
    if ((qualifiedName != null)) {
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        this._jvmTypesBuilder.setDocumentation(it, this._jvmTypesBuilder.getDocumentation(element));
        JvmTypeReference parentException = null;
        JvmType _extends = element.getExtends();
        boolean _tripleNotEquals = (_extends != null);
        if (_tripleNotEquals) {
          parentException = this._typeReferenceBuilder.typeRef(element.getExtends());
        } else {
          parentException = this._typeReferenceBuilder.typeRef(RuntimeException.class);
        }
        if ((parentException != null)) {
          EList<JvmTypeReference> _superTypes = it.getSuperTypes();
          this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, parentException);
        }
        EList<JvmMember> _members = it.getMembers();
        final Procedure1<JvmConstructor> _function_1 = (JvmConstructor it_1) -> {
          String _message = element.getMessage();
          boolean _tripleNotEquals_1 = (_message != null);
          if (_tripleNotEquals_1) {
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("super(\"");
                String _message = element.getMessage();
                _builder.append(_message);
                _builder.append("\");");
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          }
        };
        JvmConstructor _constructor = this._jvmTypesBuilder.toConstructor(element, _function_1);
        this._jvmTypesBuilder.<JvmConstructor>operator_add(_members, _constructor);
      };
      acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, qualifiedName), _function);
    }
  }
  
  private JvmGenericType toExceptionType(final SException exception, final Model model) {
    final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
      EList<JvmTypeReference> _superTypes = it.getSuperTypes();
      JvmTypeReference _typeRef = this._typeReferenceBuilder.typeRef(Exception.class);
      this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, _typeRef);
    };
    return this._jvmTypesBuilder.toClass(model, this.getQualifiedName(exception), _function);
  }
  
  private String getPackageName(final DComplexType complexType) {
    String _xblockexpression = null;
    {
      final DNamespace namespace = EcoreUtil2.<DNamespace>getContainerOfType(complexType, DNamespace.class);
      String _name = namespace.getName();
      _xblockexpression = (_name + ".dto");
    }
    return _xblockexpression;
  }
  
  private String getPackageName(final EndpointDeclarationBlock block) {
    String _xblockexpression = null;
    {
      final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(block);
      Iterable<String> _drop = IterableExtensions.<String>drop(fqn.getSegments(), 1);
      int _segmentCount = fqn.getSegmentCount();
      int _minus = (_segmentCount - 2);
      final Function1<String, String> _function = (String it) -> {
        return it.toString().toLowerCase();
      };
      final String declaredPackageName = IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_drop, _minus), _function), ".");
      _xblockexpression = (declaredPackageName + ".controller");
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final DComplexType complexType) {
    String _packageName = this.getPackageName(complexType);
    String _plus = (_packageName + ".");
    String _name = complexType.getName();
    return (_plus + _name);
  }
  
  private String _getQualifiedName(final DNamedElement element) {
    String _xblockexpression = null;
    {
      final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(element);
      String packageName = "";
      int _segmentCount = fqn.getSegmentCount();
      boolean _greaterThan = (_segmentCount > 1);
      if (_greaterThan) {
        List<String> _segments = fqn.getSegments();
        int _segmentCount_1 = fqn.getSegmentCount();
        int _minus = (_segmentCount_1 - 1);
        final Function1<String, String> _function = (String it) -> {
          return it.toLowerCase();
        };
        String _join = IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
        String _plus = (_join + ".");
        packageName = _plus;
      }
      String _string = IterableExtensions.<String>last(fqn.getSegments()).toString();
      _xblockexpression = (packageName + _string);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final EndpointDeclarationBlock block) {
    String _xblockexpression = null;
    {
      final String declaredTypeName = IterableExtensions.<String>last(this._iQualifiedNameProvider.getFullyQualifiedName(block).getSegments());
      String _xifexpression = null;
      if ((declaredTypeName.endsWith("Controller") || declaredTypeName.endsWith("RestResource"))) {
        _xifexpression = declaredTypeName;
      } else {
        _xifexpression = (declaredTypeName + "Controller");
      }
      final String controller = _xifexpression;
      String _packageName = this.getPackageName(block);
      String _plus = (_packageName + ".");
      _xblockexpression = (_plus + controller);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final ExceptionMapping mapping) {
    String _package = mapping.getPackage();
    boolean _tripleNotEquals = (_package != null);
    if (_tripleNotEquals) {
      StringConcatenation _builder = new StringConcatenation();
      String _lowerCase = mapping.getPackage().toLowerCase();
      _builder.append(_lowerCase);
      _builder.append(".");
      String _name = mapping.getName().getName();
      _builder.append(_name);
      return _builder.toString();
    }
    SException _name_1 = mapping.getName();
    QualifiedName _fullyQualifiedName = null;
    if (_name_1!=null) {
      _fullyQualifiedName=this._iQualifiedNameProvider.getFullyQualifiedName(_name_1);
    }
    final QualifiedName qualifiedName = _fullyQualifiedName;
    if ((qualifiedName != null)) {
      List<String> _segments = qualifiedName.getSegments();
      int _segmentCount = qualifiedName.getSegmentCount();
      int _minus = (_segmentCount - 1);
      final Function1<String, String> _function = (String it) -> {
        return it.toLowerCase();
      };
      final String packageName = IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append(packageName);
      _builder_1.append(".");
      String _string = qualifiedName.getLastSegment().toString();
      _builder_1.append(_string);
      return _builder_1.toString();
    }
    return null;
  }
  
  public JvmGenericType generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    if (element instanceof DComplexType) {
      return _generateForType(container, (DComplexType)element, acceptor);
    } else if (element != null) {
      return _generateForType(container, element, acceptor);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(container, element, acceptor).toString());
    }
  }
  
  public void infer(final EObject element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (element instanceof EndpointDeclarationBlock) {
      _infer((EndpointDeclarationBlock)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element instanceof ExceptionMapping) {
      _infer((ExceptionMapping)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element != null) {
      _infer(element, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, acceptor, isPreIndexingPhase).toString());
    }
  }
  
  private String getQualifiedName(final EObject complexType) {
    if (complexType instanceof DComplexType) {
      return _getQualifiedName((DComplexType)complexType);
    } else if (complexType instanceof DNamedElement) {
      return _getQualifiedName((DNamedElement)complexType);
    } else if (complexType instanceof EndpointDeclarationBlock) {
      return _getQualifiedName((EndpointDeclarationBlock)complexType);
    } else if (complexType instanceof ExceptionMapping) {
      return _getQualifiedName((ExceptionMapping)complexType);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(complexType).toString());
    }
  }
}
