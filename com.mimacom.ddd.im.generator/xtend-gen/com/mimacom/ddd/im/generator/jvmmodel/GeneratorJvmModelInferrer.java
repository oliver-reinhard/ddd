/**
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.im.generator.jvmmodel;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.base.DAttribute;
import com.mimacom.ddd.dm.base.base.DComplexType;
import com.mimacom.ddd.dm.base.base.DEnumeration;
import com.mimacom.ddd.dm.base.base.DFeature;
import com.mimacom.ddd.dm.base.base.DLiteral;
import com.mimacom.ddd.dm.base.base.DMultiplicity;
import com.mimacom.ddd.dm.base.base.DNamedElement;
import com.mimacom.ddd.dm.base.base.DNamespace;
import com.mimacom.ddd.dm.base.base.DPrimitive;
import com.mimacom.ddd.dm.base.base.DSimpleType;
import com.mimacom.ddd.dm.base.base.DType;
import com.mimacom.ddd.dm.base.base.ITransposition;
import com.mimacom.ddd.dm.base.base.TTranspositionRule;
import com.mimacom.ddd.dm.dmx.DmxArchetype;
import com.mimacom.ddd.im.generator.generator.EndpointDeclaration;
import com.mimacom.ddd.im.generator.generator.EndpointDeclarationBlock;
import com.mimacom.ddd.im.generator.generator.ExceptionMapping;
import com.mimacom.ddd.im.generator.generator.HttpVerb;
import com.mimacom.ddd.im.generator.generator.Model;
import com.mimacom.ddd.im.generator.generator.Path;
import com.mimacom.ddd.im.generator.generator.PathSegment;
import com.mimacom.ddd.im.generator.generator.TypeMapping;
import com.mimacom.ddd.sm.asm.AsmException;
import com.mimacom.ddd.sm.asm.AsmParameterDirection;
import com.mimacom.ddd.sm.asm.AsmServiceOperation;
import com.mimacom.ddd.sm.asm.AsmServiceParameter;
import java.lang.annotation.Annotation;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Duration;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmAnnotationReference;
import org.eclipse.xtext.common.types.JvmConstructor;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmEnumerationLiteral;
import org.eclipse.xtext.common.types.JvmEnumerationType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>Infers a JVM model from the source model.</p>
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 */
@SuppressWarnings("all")
public class GeneratorJvmModelInferrer extends AbstractModelInferrer {
  /**
   * convenience API to build and initialize JVM types and their members.
   */
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Inject
  private IJvmModelAssociations associations;
  
  protected void _infer(final ExceptionMapping element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    final String qualifiedName = this.getQualifiedName(element);
    if ((qualifiedName != null)) {
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        this._jvmTypesBuilder.setDocumentation(it, this._jvmTypesBuilder.getDocumentation(element));
        JvmTypeReference parentException = null;
        JvmType _extends = element.getExtends();
        boolean _tripleNotEquals = (_extends != null);
        if (_tripleNotEquals) {
          parentException = this._typeReferenceBuilder.typeRef(element.getExtends());
        } else {
          parentException = this._typeReferenceBuilder.typeRef(RuntimeException.class);
        }
        if ((parentException != null)) {
          EList<JvmTypeReference> _superTypes = it.getSuperTypes();
          this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, parentException);
        }
        EList<JvmMember> _members = it.getMembers();
        final Procedure1<JvmConstructor> _function_1 = (JvmConstructor it_1) -> {
          String _message = element.getMessage();
          boolean _tripleNotEquals_1 = (_message != null);
          if (_tripleNotEquals_1) {
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("super(\"");
                String _message = element.getMessage();
                _builder.append(_message);
                _builder.append("\");");
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          }
        };
        JvmConstructor _constructor = this._jvmTypesBuilder.toConstructor(element, _function_1);
        this._jvmTypesBuilder.<JvmConstructor>operator_add(_members, _constructor);
      };
      acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, qualifiedName), _function);
    }
  }
  
  protected void _infer(final EndpointDeclarationBlock element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (isPreIndexingPhase) {
      return;
    }
    final Map<String, DType> allTypes = this.getAllReferencedEndpointTypes(element);
    final Consumer<DType> _function = (DType it) -> {
      this.generateForType(element, it, acceptor);
    };
    allTypes.values().forEach(_function);
    EObject _eContainer = element.eContainer();
    final EList<TypeMapping> mappings = ((Model) _eContainer).getTypeMappings();
    final Procedure1<JvmGenericType> _function_1 = (JvmGenericType it) -> {
      this._jvmTypesBuilder.setDocumentation(it, this._jvmTypesBuilder.getDocumentation(element));
      EList<JvmAnnotationReference> _annotations = it.getAnnotations();
      JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(RestController.class);
      this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
      final Function1<EndpointDeclaration, Boolean> _function_2 = (EndpointDeclaration it_1) -> {
        return Boolean.valueOf(((it_1.getName() != null) && (it_1.getType() != null)));
      };
      Iterable<EndpointDeclaration> _filter = IterableExtensions.<EndpointDeclaration>filter(element.getEndpoints(), _function_2);
      for (final EndpointDeclaration endpoint : _filter) {
        {
          final AsmServiceOperation operation = endpoint.getType();
          JvmTypeReference operationReturnType = null;
          final Function1<AsmServiceParameter, Boolean> _function_3 = (AsmServiceParameter it_1) -> {
            AsmParameterDirection _direction = it_1.getDirection();
            return Boolean.valueOf((_direction == AsmParameterDirection.OUTBOUND));
          };
          final AsmServiceParameter resultParameter = IterableExtensions.<AsmServiceParameter>head(IterableExtensions.<AsmServiceParameter>filter(operation.getParameters(), _function_3));
          final Function1<AsmServiceParameter, Boolean> _function_4 = (AsmServiceParameter it_1) -> {
            AsmParameterDirection _direction = it_1.getDirection();
            return Boolean.valueOf((_direction == AsmParameterDirection.OUTBOUND));
          };
          AsmServiceParameter _head = IterableExtensions.<AsmServiceParameter>head(IterableExtensions.<AsmServiceParameter>filter(operation.getParameters(), _function_4));
          DType _type = null;
          if (_head!=null) {
            _type=_head.getType();
          }
          final DType outboundType = _type;
          if ((outboundType != null)) {
            DMultiplicity _multiplicity = resultParameter.getMultiplicity();
            boolean _tripleNotEquals = (_multiplicity != null);
            if (_tripleNotEquals) {
              operationReturnType = this._typeReferenceBuilder.typeRef(List.class, this.toType(mappings, outboundType));
            } else {
              operationReturnType = this.toType(mappings, outboundType);
            }
          } else {
            operationReturnType = this._typeReferenceBuilder.typeRef(ResponseEntity.class);
          }
          EList<JvmMember> _members = it.getMembers();
          final Procedure1<JvmOperation> _function_5 = (JvmOperation it_1) -> {
            this._jvmTypesBuilder.setDocumentation(it_1, this._jvmTypesBuilder.getDocumentation(endpoint));
            EList<JvmAnnotationReference> _annotations_1 = it_1.getAnnotations();
            JvmAnnotationReference _annotationRef_1 = this._annotationTypesBuilder.annotationRef(this.toMethodAnnotationClass(endpoint.getVerb()), this.getEndpointPathAsString(endpoint.getPath()));
            this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations_1, _annotationRef_1);
            EList<AsmException> _raises = endpoint.getType().getRaises();
            boolean _tripleNotEquals_1 = (_raises != null);
            if (_tripleNotEquals_1) {
              final Iterable<JvmTypeReference> me = this.getMappedExceptions(acceptor, EcoreUtil2.<Model>getContainerOfType(endpoint, Model.class), 
                endpoint.getType().getRaises());
              EList<JvmTypeReference> _exceptions = it_1.getExceptions();
              this._jvmTypesBuilder.<JvmTypeReference>operator_add(_exceptions, me);
            }
            final Function1<AsmServiceParameter, Boolean> _function_6 = (AsmServiceParameter it_2) -> {
              AsmParameterDirection _direction = it_2.getDirection();
              return Boolean.valueOf((_direction == AsmParameterDirection.INBOUND));
            };
            Iterable<AsmServiceParameter> _filter_1 = IterableExtensions.<AsmServiceParameter>filter(operation.getParameters(), _function_6);
            for (final AsmServiceParameter param : _filter_1) {
              {
                final JvmTypeReference paramTypeRef = this.toType(mappings, param.getType());
                final JvmFormalParameter parameter = this._jvmTypesBuilder.toParameter(endpoint, param.getName(), paramTypeRef);
                EList<JvmAnnotationReference> _annotations_2 = parameter.getAnnotations();
                ArrayList<JvmAnnotationReference> _parameterAnnotations = this.getParameterAnnotations(endpoint, param);
                this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations_2, _parameterAnnotations);
                EList<JvmFormalParameter> _parameters = it_1.getParameters();
                this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, parameter);
              }
            }
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("throw new UnsupportedOperationException(\"Not yet implemented\");");
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          };
          JvmOperation _method = this._jvmTypesBuilder.toMethod(endpoint, operation.getName(), operationReturnType, _function_5);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members, _method);
        }
      }
    };
    acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, this.getQualifiedName(element)), _function_1);
  }
  
  /**
   * generateForType
   */
  protected JvmTypeReference _generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final EList<TypeMapping> mappings = EcoreUtil2.<Model>getContainerOfType(container, Model.class).getTypeMappings();
      _xblockexpression = this.toType(mappings, element);
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _generateForType(final EObject container, final DEnumeration element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final JvmEnumerationType jvmType = this._jvmTypesBuilder.toEnumerationType(container, this.getQualifiedName(element));
      final Procedure1<JvmEnumerationType> _function = (JvmEnumerationType it) -> {
        EList<JvmMember> _members = it.getMembers();
        final Function1<DLiteral, String> _function_1 = (DLiteral it_1) -> {
          return it_1.getName();
        };
        final Function1<String, JvmEnumerationLiteral> _function_2 = (String it_1) -> {
          return this._jvmTypesBuilder.toEnumerationLiteral(container, it_1);
        };
        List<JvmEnumerationLiteral> _map = ListExtensions.<String, JvmEnumerationLiteral>map(ListExtensions.<DLiteral, String>map(element.getLiterals(), _function_1), _function_2);
        this._jvmTypesBuilder.<JvmMember>operator_add(_members, _map);
      };
      acceptor.<JvmEnumerationType>accept(jvmType, _function);
      _xblockexpression = this._typeReferenceBuilder.typeRef(jvmType);
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _generateForType(final EObject container, final DComplexType element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final JvmGenericType jvmType = this._jvmTypesBuilder.toClass(container, this.getQualifiedName(element));
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        this.generateComplexType(it, container, element);
      };
      acceptor.<JvmGenericType>accept(jvmType, _function);
      _xblockexpression = this._typeReferenceBuilder.typeRef(jvmType);
    }
    return _xblockexpression;
  }
  
  /**
   * getAllReferencedTypes
   */
  private Map<String, DType> _getAllReferencedTypes(final DType fallback) {
    return CollectionLiterals.<String, DType>emptyMap();
  }
  
  private Map<String, DType> _getAllReferencedTypes(final DComplexType complexType) {
    HashMap<String, DType> _xblockexpression = null;
    {
      final HashMap<String, DType> result = CollectionLiterals.<String, DType>newHashMap();
      result.put(this.getQualifiedName(complexType), complexType);
      final Function1<DFeature, Boolean> _function = (DFeature it) -> {
        DType _type = it.getType();
        return Boolean.valueOf((_type != null));
      };
      final Consumer<DFeature> _function_1 = (DFeature it) -> {
        result.putAll(this.getAllReferencedTypes(it.getType()));
      };
      IterableExtensions.<DFeature>filter(complexType.getFeatures(), _function).forEach(_function_1);
      _xblockexpression = result;
    }
    return _xblockexpression;
  }
  
  private Map<String, DType> _getAllReferencedTypes(final DSimpleType simpleType) {
    String _qualifiedName = this.getQualifiedName(simpleType);
    Pair<String, DSimpleType> _mappedTo = Pair.<String, DSimpleType>of(_qualifiedName, simpleType);
    return Collections.<String, DType>unmodifiableMap(CollectionLiterals.<String, DType>newHashMap(_mappedTo));
  }
  
  private Map<String, DType> _getAllReferencedTypes(final DEnumeration enumeration) {
    String _qualifiedName = this.getQualifiedName(enumeration);
    Pair<String, DEnumeration> _mappedTo = Pair.<String, DEnumeration>of(_qualifiedName, enumeration);
    return Collections.<String, DType>unmodifiableMap(CollectionLiterals.<String, DType>newHashMap(_mappedTo));
  }
  
  /**
   * toQualifiedName
   */
  private String _getQualifiedName(final ExceptionMapping exceptionMapping) {
    String _xblockexpression = null;
    {
      final String declaredTypeName = IterableExtensions.<String>last(this._iQualifiedNameProvider.getFullyQualifiedName(exceptionMapping).getSegments());
      String _xifexpression = null;
      boolean _endsWith = declaredTypeName.endsWith("Exception");
      if (_endsWith) {
        _xifexpression = declaredTypeName;
      } else {
        _xifexpression = (declaredTypeName + "Exception");
      }
      final String exception = _xifexpression;
      String _packageName = this.getPackageName(exceptionMapping);
      String _plus = (_packageName + ".");
      _xblockexpression = (_plus + exception);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final EndpointDeclarationBlock block) {
    String _xblockexpression = null;
    {
      final String declaredTypeName = IterableExtensions.<String>last(this._iQualifiedNameProvider.getFullyQualifiedName(block).getSegments());
      String _xifexpression = null;
      if ((declaredTypeName.endsWith("Controller") || 
        declaredTypeName.endsWith("RestResource"))) {
        _xifexpression = declaredTypeName;
      } else {
        _xifexpression = (declaredTypeName + "Controller");
      }
      final String controller = _xifexpression;
      String _packageName = this.getPackageName(block);
      String _plus = (_packageName + ".");
      _xblockexpression = (_plus + controller);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final DEnumeration enumeration) {
    String _packageName = this.getPackageName(enumeration);
    String _plus = (_packageName + ".");
    String _name = enumeration.getName();
    return (_plus + _name);
  }
  
  private String _getQualifiedName(final DComplexType complexType) {
    String _packageName = this.getPackageName(complexType);
    String _plus = (_packageName + ".");
    String _name = complexType.getName();
    return (_plus + _name);
  }
  
  private String _getQualifiedName(final DNamedElement element) {
    String _xblockexpression = null;
    {
      final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(element);
      String packageName = "";
      int _segmentCount = fqn.getSegmentCount();
      boolean _greaterThan = (_segmentCount > 1);
      if (_greaterThan) {
        List<String> _segments = fqn.getSegments();
        int _segmentCount_1 = fqn.getSegmentCount();
        int _minus = (_segmentCount_1 - 1);
        final Function1<String, String> _function = (String it) -> {
          return it.toLowerCase();
        };
        String _join = IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
        String _plus = (_join + ".");
        packageName = _plus;
      }
      String _string = IterableExtensions.<String>last(fqn.getSegments()).toString();
      _xblockexpression = (packageName + _string);
    }
    return _xblockexpression;
  }
  
  /**
   * getPackageName
   */
  private String _getPackageName(final DEnumeration enumeration) {
    String _xblockexpression = null;
    {
      final DNamespace namespace = EcoreUtil2.<DNamespace>getContainerOfType(enumeration, DNamespace.class);
      _xblockexpression = namespace.getName();
    }
    return _xblockexpression;
  }
  
  private String _getPackageName(final DComplexType complexType) {
    String _xblockexpression = null;
    {
      final DNamespace namespace = EcoreUtil2.<DNamespace>getContainerOfType(complexType, DNamespace.class);
      String _name = namespace.getName();
      _xblockexpression = (_name + ".dto");
    }
    return _xblockexpression;
  }
  
  private String _getPackageName(final ExceptionMapping exceptionMapping) {
    String _rootPackageName = this.getRootPackageName(exceptionMapping);
    return (_rootPackageName + ".exception");
  }
  
  private String _getPackageName(final EndpointDeclarationBlock block) {
    String _rootPackageName = this.getRootPackageName(block);
    return (_rootPackageName + ".controller");
  }
  
  /**
   * toType
   */
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DType type) {
    JvmTypeReference _xblockexpression = null;
    {
      String _name = type.getName();
      boolean _tripleEquals = (_name == null);
      if (_tripleEquals) {
        this._typeReferenceBuilder.typeRef(Object.class);
      }
      _xblockexpression = this._typeReferenceBuilder.typeRef(this.getQualifiedName(type));
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DEnumeration enumeration) {
    return this._typeReferenceBuilder.typeRef(this.getQualifiedName(enumeration));
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DComplexType complexType) {
    JvmTypeReference _xblockexpression = null;
    {
      String _name = complexType.getName();
      boolean _tripleEquals = (_name == null);
      if (_tripleEquals) {
        this._typeReferenceBuilder.typeRef(Object.class);
      }
      _xblockexpression = this._typeReferenceBuilder.typeRef(this.getQualifiedName(complexType));
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DAttribute attribute) {
    return this.toType(mappings, attribute.getType());
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DPrimitive primitive) {
    DPrimitive _redefines = primitive.getRedefines();
    boolean _tripleNotEquals = (_redefines != null);
    if (_tripleNotEquals) {
      return this.toType(mappings, primitive.getRedefines());
    }
    ITransposition _transposedBy = primitive.getTransposedBy();
    TTranspositionRule _transpositionRule = null;
    if (_transposedBy!=null) {
      _transpositionRule=_transposedBy.getTranspositionRule();
    }
    boolean _tripleNotEquals_1 = (_transpositionRule != null);
    if (_tripleNotEquals_1) {
      return this.toType(mappings, primitive.getTransposedBy().getTranspositionRule());
    }
    return this._typeReferenceBuilder.typeRef(Object.class);
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final TTranspositionRule deductionRule) {
    return this.toType(mappings, deductionRule.getSource());
  }
  
  protected JvmTypeReference _toType(final Iterable<TypeMapping> mappings, final DmxArchetype archetype) {
    JvmTypeReference _xblockexpression = null;
    {
      final Function1<TypeMapping, Boolean> _function = (TypeMapping it) -> {
        String _name = it.getType().getName();
        String _name_1 = archetype.getName();
        return Boolean.valueOf(Objects.equal(_name, _name_1));
      };
      final List<TypeMapping> mappingsForType = IterableExtensions.<TypeMapping>toList(IterableExtensions.<TypeMapping>filter(mappings, _function));
      boolean _isEmpty = mappingsForType.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        return this._typeReferenceBuilder.typeRef(IterableExtensions.<TypeMapping>head(mappingsForType).getJavaType());
      }
      JvmTypeReference _switchResult = null;
      String _name = archetype.getName();
      if (_name != null) {
        switch (_name) {
          case "ID":
          case "Name":
          case "ShortText":
          case "Text":
            _switchResult = this._typeReferenceBuilder.typeRef(String.class);
            break;
          case "Boolean":
            _switchResult = this._typeReferenceBuilder.typeRef(Boolean.class);
            break;
          case "Natural":
          case "Natural0":
          case "Integer":
            _switchResult = this._typeReferenceBuilder.typeRef(BigInteger.class);
            break;
          case "Real":
            _switchResult = this._typeReferenceBuilder.typeRef(BigDecimal.class);
            break;
          case "Timepoint":
            _switchResult = this._typeReferenceBuilder.typeRef(ZonedDateTime.class);
            break;
          case "Duration":
            _switchResult = this._typeReferenceBuilder.typeRef(Duration.class);
            break;
          default:
            String _name_1 = archetype.getName();
            String _plus = ("unsupported archetype: " + _name_1);
            throw new IllegalArgumentException(_plus);
        }
      } else {
        String _name_1 = archetype.getName();
        String _plus = ("unsupported archetype: " + _name_1);
        throw new IllegalArgumentException(_plus);
      }
      _xblockexpression = _switchResult;
    }
    return _xblockexpression;
  }
  
  /**
   * other utility methods
   */
  private Map<String, DType> getAllReferencedEndpointTypes(final EndpointDeclarationBlock block) {
    final Function1<EndpointDeclaration, EList<AsmServiceParameter>> _function = (EndpointDeclaration it) -> {
      return it.getType().getParameters();
    };
    final Function1<AsmServiceParameter, Boolean> _function_1 = (AsmServiceParameter it) -> {
      DType _type = it.getType();
      return Boolean.valueOf((_type != null));
    };
    final Function1<AsmServiceParameter, DType> _function_2 = (AsmServiceParameter it) -> {
      return it.getType();
    };
    final List<DType> allParameterTypes = IterableExtensions.<DType>toList(IterableExtensions.<AsmServiceParameter, DType>map(IterableExtensions.<AsmServiceParameter>filter(IterableExtensions.<EndpointDeclaration, AsmServiceParameter>flatMap(block.getEndpoints(), _function), _function_1), _function_2));
    final HashMap<String, DType> result = CollectionLiterals.<String, DType>newHashMap();
    final Consumer<DType> _function_3 = (DType it) -> {
      result.putAll(this.getAllReferencedTypes(it));
    };
    allParameterTypes.forEach(_function_3);
    return result;
  }
  
  private ArrayList<JvmAnnotationReference> getParameterAnnotations(final EndpointDeclaration endpoint, final AsmServiceParameter param) {
    ArrayList<JvmAnnotationReference> _xblockexpression = null;
    {
      final ArrayList<JvmAnnotationReference> annotations = CollectionLiterals.<JvmAnnotationReference>newArrayList();
      boolean _isPathParameter = this.isPathParameter(param, endpoint.getPath());
      if (_isPathParameter) {
        JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(PathVariable.class);
        annotations.add(_annotationRef);
      } else {
        if ((Objects.equal(endpoint.getVerb(), HttpVerb.POST) || Objects.equal(endpoint.getVerb(), HttpVerb.PUT))) {
          JvmAnnotationReference _annotationRef_1 = this._annotationTypesBuilder.annotationRef(RequestBody.class);
          annotations.add(_annotationRef_1);
        } else {
          JvmAnnotationReference _annotationRef_2 = this._annotationTypesBuilder.annotationRef(RequestParam.class);
          annotations.add(_annotationRef_2);
        }
      }
      _xblockexpression = annotations;
    }
    return _xblockexpression;
  }
  
  private boolean isPathParameter(final AsmServiceParameter param, final Path path) {
    final Function1<PathSegment, Boolean> _function = (PathSegment it) -> {
      return Boolean.valueOf((Objects.equal(it.getName(), param.getName()) && it.isVariable()));
    };
    return IterableExtensions.<PathSegment>exists(path.getSegments(), _function);
  }
  
  public boolean generateComplexType(final JvmDeclaredType it, final EObject container, final DComplexType element) {
    boolean _xblockexpression = false;
    {
      final String typeName = it.getSimpleName();
      final EList<TypeMapping> mappings = EcoreUtil2.<Model>getContainerOfType(container, Model.class).getTypeMappings();
      EList<DFeature> _features = element.getFeatures();
      for (final DFeature f : _features) {
        DType _type = f.getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          final JvmTypeReference refFeatureType = this.toType(mappings, f.getType());
          final JvmField field = this._jvmTypesBuilder.toField(container, f.getName(), refFeatureType);
          EList<JvmMember> _members = it.getMembers();
          this._jvmTypesBuilder.<JvmField>operator_add(_members, field);
        }
      }
      final ArrayList<JvmOperation> getters = CollectionLiterals.<JvmOperation>newArrayList();
      EList<DFeature> _features_1 = element.getFeatures();
      for (final DFeature f_1 : _features_1) {
        DType _type_1 = f_1.getType();
        boolean _tripleNotEquals_1 = (_type_1 != null);
        if (_tripleNotEquals_1) {
          final JvmTypeReference refFeatureType_1 = this.toType(mappings, f_1.getType());
          final JvmOperation getter = this._jvmTypesBuilder.toGetter(f_1, f_1.getName(), refFeatureType_1);
          getters.add(getter);
          EList<JvmMember> _members_1 = it.getMembers();
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members_1, getter);
          EList<JvmMember> _members_2 = it.getMembers();
          JvmOperation _setter = this._jvmTypesBuilder.toSetter(f_1, f_1.getName(), refFeatureType_1);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members_2, _setter);
        }
      }
      EList<JvmMember> _members_3 = it.getMembers();
      JvmOperation _toStringMethod = this._jvmTypesBuilder.toToStringMethod(container, it);
      this._jvmTypesBuilder.<JvmOperation>operator_add(_members_3, _toStringMethod);
      boolean _isEmpty = getters.isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        EList<JvmMember> _members_4 = it.getMembers();
        final Procedure1<JvmOperation> _function = (JvmOperation it_1) -> {
          EList<JvmAnnotationReference> _annotations = it_1.getAnnotations();
          JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
          this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
          EList<JvmFormalParameter> _parameters = it_1.getParameters();
          JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(container, "o", this._typeReferenceBuilder.typeRef(Object.class));
          this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
          StringConcatenationClient _client = new StringConcatenationClient() {
            @Override
            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
              _builder.append("if (this == o) return true;");
              _builder.newLine();
              _builder.append("if (o == null || getClass() != o.getClass()) return false;");
              _builder.newLine();
              _builder.append(typeName);
              _builder.append(" that = (");
              _builder.append(typeName);
              _builder.append(") o;");
              _builder.newLineIfNotEmpty();
              _builder.append("return");
              _builder.newLine();
              _builder.append("\t");
              {
                boolean _hasElements = false;
                for(final JvmOperation f : getters) {
                  if (!_hasElements) {
                    _hasElements = true;
                  } else {
                    String _newLine = GeneratorJvmModelInferrer.this.newLine();
                    String _plus = (" &&" + _newLine);
                    _builder.appendImmediate(_plus, "\t");
                  }
                  JvmTypeReference _typeRef = GeneratorJvmModelInferrer.this._typeReferenceBuilder.typeRef(java.util.Objects.class);
                  _builder.append(_typeRef, "\t");
                  _builder.append(".equals(");
                  String _simpleName = f.getSimpleName();
                  _builder.append(_simpleName, "\t");
                  _builder.append("(), that.");
                  String _simpleName_1 = f.getSimpleName();
                  _builder.append(_simpleName_1, "\t");
                  _builder.append("())");
                }
              }
              _builder.append(";");
              _builder.newLineIfNotEmpty();
            }
          };
          this._jvmTypesBuilder.setBody(it_1, _client);
        };
        JvmOperation _method = this._jvmTypesBuilder.toMethod(container, "equals", this._typeReferenceBuilder.typeRef(boolean.class), _function);
        this._jvmTypesBuilder.<JvmOperation>operator_add(_members_4, _method);
      }
      EList<JvmMember> _members_5 = it.getMembers();
      final Procedure1<JvmOperation> _function_1 = (JvmOperation it_1) -> {
        EList<JvmAnnotationReference> _annotations = it_1.getAnnotations();
        JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
        this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
        StringConcatenationClient _client = new StringConcatenationClient() {
          @Override
          protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
            _builder.append("return ");
            JvmTypeReference _typeRef = GeneratorJvmModelInferrer.this._typeReferenceBuilder.typeRef(java.util.Objects.class);
            _builder.append(_typeRef);
            _builder.append(".hash(");
            _builder.newLineIfNotEmpty();
            _builder.append("\t");
            {
              boolean _hasElements = false;
              for(final JvmOperation f : getters) {
                if (!_hasElements) {
                  _hasElements = true;
                } else {
                  String _newLine = GeneratorJvmModelInferrer.this.newLine();
                  String _plus = ("," + _newLine);
                  _builder.appendImmediate(_plus, "\t");
                }
                String _simpleName = f.getSimpleName();
                _builder.append(_simpleName, "\t");
                _builder.append("()");
              }
            }
            _builder.newLineIfNotEmpty();
            _builder.append(");");
            _builder.newLine();
          }
        };
        this._jvmTypesBuilder.setBody(it_1, _client);
      };
      JvmOperation _method_1 = this._jvmTypesBuilder.toMethod(container, "hashCode", this._typeReferenceBuilder.typeRef(int.class), _function_1);
      _xblockexpression = this._jvmTypesBuilder.<JvmOperation>operator_add(_members_5, _method_1);
    }
    return _xblockexpression;
  }
  
  private String newLine() {
    return System.getProperty("line.separator");
  }
  
  private Class<?> toMethodAnnotationClass(final HttpVerb verb) {
    Class<? extends Annotation> _switchResult = null;
    if (verb != null) {
      switch (verb) {
        case GET:
          _switchResult = GetMapping.class;
          break;
        case PUT:
          _switchResult = PutMapping.class;
          break;
        case POST:
          _switchResult = PostMapping.class;
          break;
        case DELETE:
          _switchResult = DeleteMapping.class;
          break;
        case PATCH:
          _switchResult = PatchMapping.class;
          break;
        default:
          throw new IllegalArgumentException(("invalid HTTP verb: " + verb));
      }
    } else {
      throw new IllegalArgumentException(("invalid HTTP verb: " + verb));
    }
    return _switchResult;
  }
  
  private Iterable<JvmTypeReference> getMappedExceptions(final IJvmDeclaredTypeAcceptor acceptor, final Model model, final List<AsmException> exceptions) {
    final Function1<ExceptionMapping, Boolean> _function = (ExceptionMapping it) -> {
      return Boolean.valueOf(exceptions.contains(it.getType()));
    };
    final List<ExceptionMapping> mappings = IterableExtensions.<ExceptionMapping>toList(IterableExtensions.<ExceptionMapping>filter(model.getExceptionMappings(), _function));
    final Function1<ExceptionMapping, Set<EObject>> _function_1 = (ExceptionMapping it) -> {
      return this.associations.getJvmElements(it);
    };
    final Function1<EObject, Boolean> _function_2 = (EObject it) -> {
      return Boolean.valueOf((it instanceof JvmDeclaredType));
    };
    final Function1<EObject, JvmDeclaredType> _function_3 = (EObject it) -> {
      return ((JvmDeclaredType) it);
    };
    final Function1<JvmDeclaredType, JvmTypeReference> _function_4 = (JvmDeclaredType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfMappedExceptions = IterableExtensions.<JvmTypeReference>toList(IterableExtensions.<JvmDeclaredType, JvmTypeReference>map(IterableExtensions.<EObject, JvmDeclaredType>map(IterableExtensions.<EObject>filter(IterableExtensions.<ExceptionMapping, EObject>flatMap(mappings, _function_1), _function_2), _function_3), _function_4));
    int _size = exceptions.size();
    int _size_1 = typeRefsOfMappedExceptions.size();
    boolean _tripleEquals = (_size == _size_1);
    if (_tripleEquals) {
      return typeRefsOfMappedExceptions;
    }
    final Function1<AsmException, Boolean> _function_5 = (AsmException it) -> {
      final Function1<ExceptionMapping, Boolean> _function_6 = (ExceptionMapping e) -> {
        String _name = e.getName();
        return Boolean.valueOf(Objects.equal(it, _name));
      };
      return Boolean.valueOf(IterableExtensions.<ExceptionMapping>exists(mappings, _function_6));
    };
    final List<AsmException> unmappedExceptions = IterableExtensions.<AsmException>toList(IterableExtensions.<AsmException>dropWhile(exceptions, _function_5));
    final Function1<AsmException, JvmGenericType> _function_6 = (AsmException it) -> {
      return this.toExceptionType(it, model);
    };
    final List<JvmGenericType> additionalExceptionTypes = ListExtensions.<AsmException, JvmGenericType>map(unmappedExceptions, _function_6);
    final Consumer<JvmGenericType> _function_7 = (JvmGenericType it) -> {
      acceptor.<JvmGenericType>accept(it);
    };
    additionalExceptionTypes.forEach(_function_7);
    final Function1<JvmGenericType, JvmTypeReference> _function_8 = (JvmGenericType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfUnmappedExceptions = ListExtensions.<JvmGenericType, JvmTypeReference>map(additionalExceptionTypes, _function_8);
    return Iterables.<JvmTypeReference>concat(typeRefsOfMappedExceptions, typeRefsOfUnmappedExceptions);
  }
  
  private JvmGenericType toExceptionType(final AsmException exception, final Model model) {
    final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
      EList<JvmTypeReference> _superTypes = it.getSuperTypes();
      JvmTypeReference _typeRef = this._typeReferenceBuilder.typeRef(Exception.class);
      this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, _typeRef);
    };
    return this._jvmTypesBuilder.toClass(model, this.getQualifiedName(exception), _function);
  }
  
  private String getEndpointPathAsString(final Path path) {
    String _xblockexpression = null;
    {
      if ((path == null)) {
        return null;
      }
      String _xifexpression = null;
      boolean _isLeadingSlash = path.isLeadingSlash();
      if (_isLeadingSlash) {
        _xifexpression = "/";
      } else {
        _xifexpression = "";
      }
      final String prefix = _xifexpression;
      final Function1<PathSegment, String> _function = (PathSegment it) -> {
        String _xifexpression_1 = null;
        boolean _isVariable = it.isVariable();
        if (_isVariable) {
          String _name = it.getName();
          String _plus = ("{" + _name);
          _xifexpression_1 = (_plus + "}");
        } else {
          _xifexpression_1 = it.getName();
        }
        return _xifexpression_1;
      };
      String _join = IterableExtensions.join(ListExtensions.<PathSegment, String>map(path.getSegments(), _function), "/");
      _xblockexpression = (prefix + _join);
    }
    return _xblockexpression;
  }
  
  private String getRootPackageName(final EObject child) {
    final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(EcoreUtil2.<Model>getContainerOfType(child, Model.class));
    List<String> _segments = fqn.getSegments();
    int _segmentCount = fqn.getSegmentCount();
    int _minus = (_segmentCount - 1);
    final Function1<String, String> _function = (String it) -> {
      return it.toString().toLowerCase();
    };
    return IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
  }
  
  public void infer(final EObject element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (element instanceof EndpointDeclarationBlock) {
      _infer((EndpointDeclarationBlock)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element instanceof ExceptionMapping) {
      _infer((ExceptionMapping)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element != null) {
      _infer(element, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, acceptor, isPreIndexingPhase).toString());
    }
  }
  
  public JvmTypeReference generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    if (element instanceof DEnumeration) {
      return _generateForType(container, (DEnumeration)element, acceptor);
    } else if (element instanceof DComplexType) {
      return _generateForType(container, (DComplexType)element, acceptor);
    } else if (element != null) {
      return _generateForType(container, element, acceptor);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(container, element, acceptor).toString());
    }
  }
  
  private Map<String, DType> getAllReferencedTypes(final DType enumeration) {
    if (enumeration instanceof DEnumeration) {
      return _getAllReferencedTypes((DEnumeration)enumeration);
    } else if (enumeration instanceof DComplexType) {
      return _getAllReferencedTypes((DComplexType)enumeration);
    } else if (enumeration instanceof DSimpleType) {
      return _getAllReferencedTypes((DSimpleType)enumeration);
    } else if (enumeration != null) {
      return _getAllReferencedTypes(enumeration);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(enumeration).toString());
    }
  }
  
  private String getQualifiedName(final EObject enumeration) {
    if (enumeration instanceof DEnumeration) {
      return _getQualifiedName((DEnumeration)enumeration);
    } else if (enumeration instanceof DComplexType) {
      return _getQualifiedName((DComplexType)enumeration);
    } else if (enumeration instanceof DNamedElement) {
      return _getQualifiedName((DNamedElement)enumeration);
    } else if (enumeration instanceof EndpointDeclarationBlock) {
      return _getQualifiedName((EndpointDeclarationBlock)enumeration);
    } else if (enumeration instanceof ExceptionMapping) {
      return _getQualifiedName((ExceptionMapping)enumeration);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(enumeration).toString());
    }
  }
  
  private String getPackageName(final EObject enumeration) {
    if (enumeration instanceof DEnumeration) {
      return _getPackageName((DEnumeration)enumeration);
    } else if (enumeration instanceof DComplexType) {
      return _getPackageName((DComplexType)enumeration);
    } else if (enumeration instanceof EndpointDeclarationBlock) {
      return _getPackageName((EndpointDeclarationBlock)enumeration);
    } else if (enumeration instanceof ExceptionMapping) {
      return _getPackageName((ExceptionMapping)enumeration);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(enumeration).toString());
    }
  }
  
  public JvmTypeReference toType(final Iterable<TypeMapping> mappings, final EObject archetype) {
    if (archetype instanceof DmxArchetype) {
      return _toType(mappings, (DmxArchetype)archetype);
    } else if (archetype instanceof DEnumeration) {
      return _toType(mappings, (DEnumeration)archetype);
    } else if (archetype instanceof DPrimitive) {
      return _toType(mappings, (DPrimitive)archetype);
    } else if (archetype instanceof DAttribute) {
      return _toType(mappings, (DAttribute)archetype);
    } else if (archetype instanceof DComplexType) {
      return _toType(mappings, (DComplexType)archetype);
    } else if (archetype instanceof DType) {
      return _toType(mappings, (DType)archetype);
    } else if (archetype instanceof TTranspositionRule) {
      return _toType(mappings, (TTranspositionRule)archetype);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(mappings, archetype).toString());
    }
  }
}
