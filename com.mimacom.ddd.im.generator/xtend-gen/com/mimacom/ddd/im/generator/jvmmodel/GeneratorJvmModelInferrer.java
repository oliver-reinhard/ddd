/**
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.im.generator.jvmmodel;

import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.DComplexType;
import com.mimacom.ddd.dm.base.DEnumeration;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DLiteral;
import com.mimacom.ddd.dm.base.DMultiplicity;
import com.mimacom.ddd.dm.base.DNamedElement;
import com.mimacom.ddd.dm.base.DNamespace;
import com.mimacom.ddd.dm.base.DType;
import com.mimacom.ddd.im.generator.generator.EndpointDeclaration;
import com.mimacom.ddd.im.generator.generator.EndpointDeclarationBlock;
import com.mimacom.ddd.im.generator.generator.ExceptionMapping;
import com.mimacom.ddd.im.generator.generator.HttpVerb;
import com.mimacom.ddd.im.generator.generator.Model;
import com.mimacom.ddd.im.generator.generator.Path;
import com.mimacom.ddd.im.generator.generator.PathSegment;
import com.mimacom.ddd.im.generator.generator.TypeMapping;
import com.mimacom.ddd.im.generator.jvmmodel.GeneratorTypesHelper;
import com.mimacom.ddd.sm.asm.SDirection;
import com.mimacom.ddd.sm.asm.SException;
import com.mimacom.ddd.sm.asm.SServiceOperation;
import com.mimacom.ddd.sm.asm.SServiceParameter;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenationClient;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.common.types.JvmAnnotationReference;
import org.eclipse.xtext.common.types.JvmConstructor;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmEnumerationLiteral;
import org.eclipse.xtext.common.types.JvmEnumerationType;
import org.eclipse.xtext.common.types.JvmField;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericType;
import org.eclipse.xtext.common.types.JvmMember;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.common.types.JvmType;
import org.eclipse.xtext.common.types.JvmTypeReference;
import org.eclipse.xtext.common.types.util.TypeReferences;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer;
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations;
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * <p>Infers a JVM model from the source model.</p>
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>
 */
@SuppressWarnings("all")
public class GeneratorJvmModelInferrer extends AbstractModelInferrer {
  /**
   * convenience API to build and initialize JVM types and their members.
   */
  @Inject
  @Extension
  private JvmTypesBuilder _jvmTypesBuilder;
  
  @Inject
  @Extension
  private IQualifiedNameProvider _iQualifiedNameProvider;
  
  @Inject
  private IJvmModelAssociations associations;
  
  @Inject
  private GeneratorTypesHelper typesHelper;
  
  @Inject
  private TypeReferences references;
  
  public Iterable<DType> getParameterTypeReferences(final EndpointDeclarationBlock block) {
    final Function1<EndpointDeclaration, EList<SServiceParameter>> _function = (EndpointDeclaration it) -> {
      return it.getType().getParameters();
    };
    final Function1<SServiceParameter, DType> _function_1 = (SServiceParameter it) -> {
      return it.getType();
    };
    return IterableExtensions.<SServiceParameter, DType>map(IterableExtensions.<EndpointDeclaration, SServiceParameter>flatMap(block.getEndpoints(), _function), _function_1);
  }
  
  protected JvmTypeReference _generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final EList<TypeMapping> mappings = EcoreUtil2.<Model>getContainerOfType(container, Model.class).getTypeMappings();
      _xblockexpression = this.typesHelper.toType(this._typeReferenceBuilder, mappings, element);
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _generateForType(final EObject container, final DEnumeration element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final JvmEnumerationType jvmType = this._jvmTypesBuilder.toEnumerationType(container, this.getQualifiedName(element));
      final Procedure1<JvmEnumerationType> _function = (JvmEnumerationType it) -> {
        EList<JvmMember> _members = it.getMembers();
        final Function1<DLiteral, String> _function_1 = (DLiteral it_1) -> {
          return it_1.getName();
        };
        final Function1<String, JvmEnumerationLiteral> _function_2 = (String it_1) -> {
          return this._jvmTypesBuilder.toEnumerationLiteral(container, it_1);
        };
        List<JvmEnumerationLiteral> _map = ListExtensions.<String, JvmEnumerationLiteral>map(ListExtensions.<DLiteral, String>map(element.getLiterals(), _function_1), _function_2);
        this._jvmTypesBuilder.<JvmMember>operator_add(_members, _map);
      };
      acceptor.<JvmEnumerationType>accept(jvmType, _function);
      _xblockexpression = this._typeReferenceBuilder.typeRef(jvmType);
    }
    return _xblockexpression;
  }
  
  protected JvmTypeReference _generateForType(final EObject container, final DComplexType element, final IJvmDeclaredTypeAcceptor acceptor) {
    JvmTypeReference _xblockexpression = null;
    {
      final JvmGenericType jvmType = this._jvmTypesBuilder.toClass(container, this.getQualifiedName(element));
      final EList<TypeMapping> mappings = EcoreUtil2.<Model>getContainerOfType(container, Model.class).getTypeMappings();
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        EList<DFeature> _features = element.getFeatures();
        for (final DFeature f : _features) {
          DType _type = f.getType();
          boolean _tripleNotEquals = (_type != null);
          if (_tripleNotEquals) {
            final JvmTypeReference refFeatureType = this.typesHelper.toType(this._typeReferenceBuilder, mappings, f.getType());
            final JvmField field = this._jvmTypesBuilder.toField(f, f.getName(), refFeatureType);
            EList<JvmMember> _members = it.getMembers();
            this._jvmTypesBuilder.<JvmField>operator_add(_members, field);
          }
        }
        final ArrayList<JvmOperation> getters = CollectionLiterals.<JvmOperation>newArrayList();
        EList<DFeature> _features_1 = element.getFeatures();
        for (final DFeature f_1 : _features_1) {
          DType _type_1 = f_1.getType();
          boolean _tripleNotEquals_1 = (_type_1 != null);
          if (_tripleNotEquals_1) {
            final JvmTypeReference refFeatureType_1 = this.typesHelper.toType(this._typeReferenceBuilder, mappings, f_1.getType());
            final JvmOperation getter = this._jvmTypesBuilder.toGetter(f_1, f_1.getName(), refFeatureType_1);
            getters.add(getter);
            EList<JvmMember> _members_1 = it.getMembers();
            this._jvmTypesBuilder.<JvmOperation>operator_add(_members_1, getter);
            EList<JvmMember> _members_2 = it.getMembers();
            JvmOperation _setter = this._jvmTypesBuilder.toSetter(f_1, f_1.getName(), refFeatureType_1);
            this._jvmTypesBuilder.<JvmOperation>operator_add(_members_2, _setter);
          }
        }
        EList<JvmMember> _members_3 = it.getMembers();
        JvmOperation _toStringMethod = this._jvmTypesBuilder.toToStringMethod(container, it);
        this._jvmTypesBuilder.<JvmOperation>operator_add(_members_3, _toStringMethod);
        boolean _isEmpty = getters.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          EList<JvmMember> _members_4 = it.getMembers();
          final Procedure1<JvmOperation> _function_1 = (JvmOperation it_1) -> {
            EList<JvmAnnotationReference> _annotations = it_1.getAnnotations();
            JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
            this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
            EList<JvmFormalParameter> _parameters = it_1.getParameters();
            JvmFormalParameter _parameter = this._jvmTypesBuilder.toParameter(container, "o", this.references.getTypeForName(Object.class, container));
            this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, _parameter);
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("if (this == o) return true;");
                _builder.newLine();
                _builder.append("if (o == null || getClass() != o.getClass()) return false;");
                _builder.newLine();
                String _simpleName = GeneratorJvmModelInferrer.this._typeReferenceBuilder.typeRef(jvmType).getSimpleName();
                _builder.append(_simpleName);
                _builder.append(" that = (");
                String _simpleName_1 = GeneratorJvmModelInferrer.this._typeReferenceBuilder.typeRef(jvmType).getSimpleName();
                _builder.append(_simpleName_1);
                _builder.append(") o;");
                _builder.newLineIfNotEmpty();
                _builder.append("return");
                _builder.newLine();
                {
                  boolean _hasElements = false;
                  for(final JvmOperation f : getters) {
                    if (!_hasElements) {
                      _hasElements = true;
                    } else {
                      _builder.appendImmediate("&&", "\t");
                    }
                    _builder.append("\t");
                    String _qualifiedName = GeneratorJvmModelInferrer.this.references.getTypeForName(Objects.class, container).getQualifiedName();
                    _builder.append(_qualifiedName, "\t");
                    _builder.append(".equals(");
                    String _simpleName_2 = f.getSimpleName();
                    _builder.append(_simpleName_2, "\t");
                    _builder.append("(), that.");
                    String _simpleName_3 = f.getSimpleName();
                    _builder.append(_simpleName_3, "\t");
                    _builder.append("())");
                    _builder.newLineIfNotEmpty();
                    _builder.append("\t");
                  }
                }
                _builder.append(";");
                _builder.newLineIfNotEmpty();
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          };
          JvmOperation _method = this._jvmTypesBuilder.toMethod(container, "equals", this.references.getTypeForName(boolean.class, container), _function_1);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members_4, _method);
        }
        EList<JvmMember> _members_5 = it.getMembers();
        final Procedure1<JvmOperation> _function_2 = (JvmOperation it_1) -> {
          EList<JvmAnnotationReference> _annotations = it_1.getAnnotations();
          JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(Override.class);
          this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
          StringConcatenationClient _client = new StringConcatenationClient() {
            @Override
            protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
              _builder.append("return ");
              String _qualifiedName = GeneratorJvmModelInferrer.this.references.getTypeForName(Objects.class, container).getQualifiedName();
              _builder.append(_qualifiedName);
              _builder.append(".hash(");
              _builder.newLineIfNotEmpty();
              _builder.append("\t");
              {
                boolean _hasElements = false;
                for(final JvmOperation f : getters) {
                  if (!_hasElements) {
                    _hasElements = true;
                  } else {
                    String _property = System.getProperty("line.separator");
                    String _plus = ("," + _property);
                    _builder.appendImmediate(_plus, "\t");
                  }
                  String _simpleName = f.getSimpleName();
                  _builder.append(_simpleName, "\t");
                  _builder.append("()");
                }
              }
              _builder.newLineIfNotEmpty();
              _builder.append(");");
              _builder.newLine();
            }
          };
          this._jvmTypesBuilder.setBody(it_1, _client);
        };
        JvmOperation _method_1 = this._jvmTypesBuilder.toMethod(container, "hashCode", this.references.getTypeForName(int.class, container), _function_2);
        this._jvmTypesBuilder.<JvmOperation>operator_add(_members_5, _method_1);
      };
      acceptor.<JvmGenericType>accept(jvmType, _function);
      _xblockexpression = this._typeReferenceBuilder.typeRef(jvmType);
    }
    return _xblockexpression;
  }
  
  protected void _infer(final ExceptionMapping element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    final String qualifiedName = this.getQualifiedName(element);
    if ((qualifiedName != null)) {
      final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
        this._jvmTypesBuilder.setDocumentation(it, this._jvmTypesBuilder.getDocumentation(element));
        JvmTypeReference parentException = null;
        JvmType _extends = element.getExtends();
        boolean _tripleNotEquals = (_extends != null);
        if (_tripleNotEquals) {
          parentException = this._typeReferenceBuilder.typeRef(element.getExtends());
        } else {
          parentException = this._typeReferenceBuilder.typeRef(RuntimeException.class);
        }
        if ((parentException != null)) {
          EList<JvmTypeReference> _superTypes = it.getSuperTypes();
          this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, parentException);
        }
        EList<JvmMember> _members = it.getMembers();
        final Procedure1<JvmConstructor> _function_1 = (JvmConstructor it_1) -> {
          String _message = element.getMessage();
          boolean _tripleNotEquals_1 = (_message != null);
          if (_tripleNotEquals_1) {
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("super(\"");
                String _message = element.getMessage();
                _builder.append(_message);
                _builder.append("\");");
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          }
        };
        JvmConstructor _constructor = this._jvmTypesBuilder.toConstructor(element, _function_1);
        this._jvmTypesBuilder.<JvmConstructor>operator_add(_members, _constructor);
      };
      acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, qualifiedName), _function);
    }
  }
  
  private boolean isAlreadyAssociatedWith(final EObject context, final String qualifiedName) {
    boolean _xblockexpression = false;
    {
      final Set<EObject> associations = this.associations.getJvmElements(context);
      final Function1<EObject, Boolean> _function = (EObject it) -> {
        String _string = this._iQualifiedNameProvider.getFullyQualifiedName(it).toString();
        return Boolean.valueOf(com.google.common.base.Objects.equal(_string, qualifiedName));
      };
      _xblockexpression = IterableExtensions.<EObject>exists(associations, _function);
    }
    return _xblockexpression;
  }
  
  protected void _infer(final EndpointDeclarationBlock element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (isPreIndexingPhase) {
      return;
    }
    final Map<DType, JvmTypeReference> paramTypeToJvmType = new HashMap<DType, JvmTypeReference>();
    EList<EndpointDeclaration> _endpoints = element.getEndpoints();
    for (final EndpointDeclaration endpoint : _endpoints) {
      final Function1<SServiceParameter, Boolean> _function = (SServiceParameter it) -> {
        DType _type = it.getType();
        return Boolean.valueOf((_type != null));
      };
      Iterable<SServiceParameter> _filter = IterableExtensions.<SServiceParameter>filter(endpoint.getType().getParameters(), _function);
      for (final SServiceParameter p : _filter) {
        boolean _isAlreadyAssociatedWith = this.isAlreadyAssociatedWith(element, this.getQualifiedName(p.getType()));
        boolean _not = (!_isAlreadyAssociatedWith);
        if (_not) {
          final JvmTypeReference jvmTypeRef = this.generateForType(element, p.getType(), acceptor);
          paramTypeToJvmType.put(p.getType(), jvmTypeRef);
        }
      }
    }
    final Procedure1<JvmGenericType> _function_1 = (JvmGenericType it) -> {
      this._jvmTypesBuilder.setDocumentation(it, this._jvmTypesBuilder.getDocumentation(element));
      EList<JvmAnnotationReference> _annotations = it.getAnnotations();
      JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(RestController.class);
      this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations, _annotationRef);
      final Function1<EndpointDeclaration, Boolean> _function_2 = (EndpointDeclaration it_1) -> {
        return Boolean.valueOf(((it_1.getName() != null) && (it_1.getType() != null)));
      };
      Iterable<EndpointDeclaration> _filter_1 = IterableExtensions.<EndpointDeclaration>filter(element.getEndpoints(), _function_2);
      for (final EndpointDeclaration endpoint_1 : _filter_1) {
        {
          final SServiceOperation operation = endpoint_1.getType();
          JvmTypeReference operationReturnType = null;
          final Function1<SServiceParameter, Boolean> _function_3 = (SServiceParameter it_1) -> {
            SDirection _direction = it_1.getDirection();
            return Boolean.valueOf((_direction == SDirection.OUTBOUND));
          };
          final SServiceParameter resultParameter = IterableExtensions.<SServiceParameter>head(IterableExtensions.<SServiceParameter>filter(operation.getParameters(), _function_3));
          final Function1<SServiceParameter, Boolean> _function_4 = (SServiceParameter it_1) -> {
            SDirection _direction = it_1.getDirection();
            return Boolean.valueOf((_direction == SDirection.OUTBOUND));
          };
          SServiceParameter _head = IterableExtensions.<SServiceParameter>head(IterableExtensions.<SServiceParameter>filter(operation.getParameters(), _function_4));
          DType _type = null;
          if (_head!=null) {
            _type=_head.getType();
          }
          final DType outboundType = _type;
          if (((outboundType != null) && paramTypeToJvmType.containsKey(outboundType))) {
            DMultiplicity _multiplicity = resultParameter.getMultiplicity();
            boolean _tripleNotEquals = (_multiplicity != null);
            if (_tripleNotEquals) {
              operationReturnType = this._typeReferenceBuilder.typeRef(List.class, paramTypeToJvmType.get(outboundType));
            } else {
              operationReturnType = paramTypeToJvmType.get(outboundType);
            }
          } else {
            operationReturnType = this._typeReferenceBuilder.typeRef(ResponseEntity.class);
          }
          EList<JvmMember> _members = it.getMembers();
          final Procedure1<JvmOperation> _function_5 = (JvmOperation it_1) -> {
            this._jvmTypesBuilder.setDocumentation(it_1, this._jvmTypesBuilder.getDocumentation(endpoint_1));
            EList<JvmAnnotationReference> _annotations_1 = it_1.getAnnotations();
            JvmAnnotationReference _annotationRef_1 = this._annotationTypesBuilder.annotationRef(this.toMethodAnnotationClass(endpoint_1.getVerb()), this.getEndpointPathAsString(endpoint_1.getPath()));
            this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations_1, _annotationRef_1);
            EList<SException> _raises = endpoint_1.getType().getRaises();
            boolean _tripleNotEquals_1 = (_raises != null);
            if (_tripleNotEquals_1) {
              final Iterable<JvmTypeReference> me = this.getMappedExceptions(acceptor, EcoreUtil2.<Model>getContainerOfType(endpoint_1, Model.class), endpoint_1.getType().getRaises());
              EList<JvmTypeReference> _exceptions = it_1.getExceptions();
              this._jvmTypesBuilder.<JvmTypeReference>operator_add(_exceptions, me);
            }
            final Function1<SServiceParameter, Boolean> _function_6 = (SServiceParameter it_2) -> {
              return Boolean.valueOf(((it_2.getDirection() == SDirection.INBOUND) && paramTypeToJvmType.containsKey(it_2.getType())));
            };
            Iterable<SServiceParameter> _filter_2 = IterableExtensions.<SServiceParameter>filter(operation.getParameters(), _function_6);
            for (final SServiceParameter param : _filter_2) {
              {
                final JvmTypeReference paramTypeRef = paramTypeToJvmType.get(param.getType());
                final JvmFormalParameter parameter = this._jvmTypesBuilder.toParameter(endpoint_1, param.getName(), paramTypeRef);
                EList<JvmAnnotationReference> _annotations_2 = parameter.getAnnotations();
                ArrayList<JvmAnnotationReference> _parameterAnnotations = this.getParameterAnnotations(endpoint_1, param);
                this._jvmTypesBuilder.<JvmAnnotationReference>operator_add(_annotations_2, _parameterAnnotations);
                EList<JvmFormalParameter> _parameters = it_1.getParameters();
                this._jvmTypesBuilder.<JvmFormalParameter>operator_add(_parameters, parameter);
              }
            }
            StringConcatenationClient _client = new StringConcatenationClient() {
              @Override
              protected void appendTo(StringConcatenationClient.TargetStringConcatenation _builder) {
                _builder.append("throw new UnsupportedOperationException(\"Not yet implemented\");");
              }
            };
            this._jvmTypesBuilder.setBody(it_1, _client);
          };
          JvmOperation _method = this._jvmTypesBuilder.toMethod(endpoint_1, operation.getName(), operationReturnType, _function_5);
          this._jvmTypesBuilder.<JvmOperation>operator_add(_members, _method);
        }
      }
    };
    acceptor.<JvmGenericType>accept(this._jvmTypesBuilder.toClass(element, this.getQualifiedName(element)), _function_1);
  }
  
  private ArrayList<JvmAnnotationReference> getParameterAnnotations(final EndpointDeclaration endpoint, final SServiceParameter param) {
    ArrayList<JvmAnnotationReference> _xblockexpression = null;
    {
      final ArrayList<JvmAnnotationReference> annotations = CollectionLiterals.<JvmAnnotationReference>newArrayList();
      boolean _isPathParameter = this.isPathParameter(param, endpoint.getPath());
      if (_isPathParameter) {
        JvmAnnotationReference _annotationRef = this._annotationTypesBuilder.annotationRef(PathVariable.class);
        annotations.add(_annotationRef);
      } else {
        if ((com.google.common.base.Objects.equal(endpoint.getVerb(), HttpVerb.POST) || com.google.common.base.Objects.equal(endpoint.getVerb(), HttpVerb.PUT))) {
          JvmAnnotationReference _annotationRef_1 = this._annotationTypesBuilder.annotationRef(RequestBody.class);
          annotations.add(_annotationRef_1);
        } else {
          JvmAnnotationReference _annotationRef_2 = this._annotationTypesBuilder.annotationRef(RequestParam.class);
          annotations.add(_annotationRef_2);
        }
      }
      _xblockexpression = annotations;
    }
    return _xblockexpression;
  }
  
  private boolean isPathParameter(final SServiceParameter param, final Path path) {
    final Function1<PathSegment, Boolean> _function = (PathSegment it) -> {
      return Boolean.valueOf((com.google.common.base.Objects.equal(it.getName(), param.getName()) && it.isVariable()));
    };
    return IterableExtensions.<PathSegment>exists(path.getSegments(), _function);
  }
  
  private Class<?> toMethodAnnotationClass(final HttpVerb verb) {
    Class<? extends Annotation> _switchResult = null;
    if (verb != null) {
      switch (verb) {
        case GET:
          _switchResult = GetMapping.class;
          break;
        case PUT:
          _switchResult = PutMapping.class;
          break;
        case POST:
          _switchResult = PostMapping.class;
          break;
        case DELETE:
          _switchResult = DeleteMapping.class;
          break;
        case PATCH:
          _switchResult = PatchMapping.class;
          break;
        default:
          throw new IllegalArgumentException(("invalid HTTP verb: " + verb));
      }
    } else {
      throw new IllegalArgumentException(("invalid HTTP verb: " + verb));
    }
    return _switchResult;
  }
  
  private Iterable<JvmTypeReference> getMappedExceptions(final IJvmDeclaredTypeAcceptor acceptor, final Model model, final List<SException> exceptions) {
    final Function1<ExceptionMapping, Boolean> _function = (ExceptionMapping it) -> {
      return Boolean.valueOf(exceptions.contains(it.getType()));
    };
    final List<ExceptionMapping> mappings = IterableExtensions.<ExceptionMapping>toList(IterableExtensions.<ExceptionMapping>filter(model.getExceptionMappings(), _function));
    final Function1<ExceptionMapping, Set<EObject>> _function_1 = (ExceptionMapping it) -> {
      return this.associations.getJvmElements(it);
    };
    final Function1<EObject, Boolean> _function_2 = (EObject it) -> {
      return Boolean.valueOf((it instanceof JvmDeclaredType));
    };
    final Function1<EObject, JvmDeclaredType> _function_3 = (EObject it) -> {
      return ((JvmDeclaredType) it);
    };
    final Function1<JvmDeclaredType, JvmTypeReference> _function_4 = (JvmDeclaredType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfMappedExceptions = IterableExtensions.<JvmTypeReference>toList(IterableExtensions.<JvmDeclaredType, JvmTypeReference>map(IterableExtensions.<EObject, JvmDeclaredType>map(IterableExtensions.<EObject>filter(IterableExtensions.<ExceptionMapping, EObject>flatMap(mappings, _function_1), _function_2), _function_3), _function_4));
    int _size = exceptions.size();
    int _size_1 = typeRefsOfMappedExceptions.size();
    boolean _tripleEquals = (_size == _size_1);
    if (_tripleEquals) {
      return typeRefsOfMappedExceptions;
    }
    final Function1<SException, Boolean> _function_5 = (SException it) -> {
      final Function1<ExceptionMapping, Boolean> _function_6 = (ExceptionMapping e) -> {
        String _name = e.getName();
        return Boolean.valueOf(com.google.common.base.Objects.equal(it, _name));
      };
      return Boolean.valueOf(IterableExtensions.<ExceptionMapping>exists(mappings, _function_6));
    };
    final List<SException> unmappedExceptions = IterableExtensions.<SException>toList(IterableExtensions.<SException>dropWhile(exceptions, _function_5));
    final Function1<SException, JvmGenericType> _function_6 = (SException it) -> {
      return this.toExceptionType(it, model);
    };
    final List<JvmGenericType> additionalExceptionTypes = ListExtensions.<SException, JvmGenericType>map(unmappedExceptions, _function_6);
    final Consumer<JvmGenericType> _function_7 = (JvmGenericType it) -> {
      acceptor.<JvmGenericType>accept(it);
    };
    additionalExceptionTypes.forEach(_function_7);
    final Function1<JvmGenericType, JvmTypeReference> _function_8 = (JvmGenericType it) -> {
      return this._typeReferenceBuilder.typeRef(it);
    };
    final List<JvmTypeReference> typeRefsOfUnmappedExceptions = ListExtensions.<JvmGenericType, JvmTypeReference>map(additionalExceptionTypes, _function_8);
    return Iterables.<JvmTypeReference>concat(typeRefsOfMappedExceptions, typeRefsOfUnmappedExceptions);
  }
  
  private JvmGenericType toExceptionType(final SException exception, final Model model) {
    final Procedure1<JvmGenericType> _function = (JvmGenericType it) -> {
      EList<JvmTypeReference> _superTypes = it.getSuperTypes();
      JvmTypeReference _typeRef = this._typeReferenceBuilder.typeRef(Exception.class);
      this._jvmTypesBuilder.<JvmTypeReference>operator_add(_superTypes, _typeRef);
    };
    return this._jvmTypesBuilder.toClass(model, this.getQualifiedName(exception), _function);
  }
  
  private String getEndpointPathAsString(final Path path) {
    String _xblockexpression = null;
    {
      if ((path == null)) {
        return null;
      }
      String _xifexpression = null;
      boolean _isLeadingSlash = path.isLeadingSlash();
      if (_isLeadingSlash) {
        _xifexpression = "/";
      } else {
        _xifexpression = "";
      }
      final String prefix = _xifexpression;
      final Function1<PathSegment, String> _function = (PathSegment it) -> {
        String _xifexpression_1 = null;
        boolean _isVariable = it.isVariable();
        if (_isVariable) {
          String _name = it.getName();
          String _plus = ("{" + _name);
          _xifexpression_1 = (_plus + "}");
        } else {
          _xifexpression_1 = it.getName();
        }
        return _xifexpression_1;
      };
      String _join = IterableExtensions.join(ListExtensions.<PathSegment, String>map(path.getSegments(), _function), "/");
      _xblockexpression = (prefix + _join);
    }
    return _xblockexpression;
  }
  
  private String getPackageName(final DComplexType complexType) {
    String _xblockexpression = null;
    {
      final DNamespace namespace = EcoreUtil2.<DNamespace>getContainerOfType(complexType, DNamespace.class);
      String _name = namespace.getName();
      _xblockexpression = (_name + ".dto");
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final ExceptionMapping exceptionMapping) {
    String _xblockexpression = null;
    {
      final String declaredTypeName = IterableExtensions.<String>last(this._iQualifiedNameProvider.getFullyQualifiedName(exceptionMapping).getSegments());
      String _xifexpression = null;
      boolean _endsWith = declaredTypeName.endsWith("Exception");
      if (_endsWith) {
        _xifexpression = declaredTypeName;
      } else {
        _xifexpression = (declaredTypeName + "Exception");
      }
      final String exception = _xifexpression;
      String _packageName = this.getPackageName(exceptionMapping);
      String _plus = (_packageName + ".");
      _xblockexpression = (_plus + exception);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final EndpointDeclarationBlock block) {
    String _xblockexpression = null;
    {
      final String declaredTypeName = IterableExtensions.<String>last(this._iQualifiedNameProvider.getFullyQualifiedName(block).getSegments());
      String _xifexpression = null;
      if ((declaredTypeName.endsWith("Controller") || declaredTypeName.endsWith("RestResource"))) {
        _xifexpression = declaredTypeName;
      } else {
        _xifexpression = (declaredTypeName + "Controller");
      }
      final String controller = _xifexpression;
      String _packageName = this.getPackageName(block);
      String _plus = (_packageName + ".");
      _xblockexpression = (_plus + controller);
    }
    return _xblockexpression;
  }
  
  private String _getQualifiedName(final DComplexType complexType) {
    String _packageName = this.getPackageName(complexType);
    String _plus = (_packageName + ".");
    String _name = complexType.getName();
    return (_plus + _name);
  }
  
  private String _getQualifiedName(final DNamedElement element) {
    String _xblockexpression = null;
    {
      final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(element);
      String packageName = "";
      int _segmentCount = fqn.getSegmentCount();
      boolean _greaterThan = (_segmentCount > 1);
      if (_greaterThan) {
        List<String> _segments = fqn.getSegments();
        int _segmentCount_1 = fqn.getSegmentCount();
        int _minus = (_segmentCount_1 - 1);
        final Function1<String, String> _function = (String it) -> {
          return it.toLowerCase();
        };
        String _join = IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
        String _plus = (_join + ".");
        packageName = _plus;
      }
      String _string = IterableExtensions.<String>last(fqn.getSegments()).toString();
      _xblockexpression = (packageName + _string);
    }
    return _xblockexpression;
  }
  
  private String getPackageName(final ExceptionMapping exceptionMapping) {
    String _rootPackageName = this.getRootPackageName(exceptionMapping);
    return (_rootPackageName + ".exception");
  }
  
  private String getPackageName(final EndpointDeclarationBlock block) {
    String _rootPackageName = this.getRootPackageName(block);
    return (_rootPackageName + ".controller");
  }
  
  private String getRootPackageName(final EObject child) {
    final QualifiedName fqn = this._iQualifiedNameProvider.getFullyQualifiedName(EcoreUtil2.<Model>getContainerOfType(child, Model.class));
    List<String> _segments = fqn.getSegments();
    int _segmentCount = fqn.getSegmentCount();
    int _minus = (_segmentCount - 1);
    final Function1<String, String> _function = (String it) -> {
      return it.toString().toLowerCase();
    };
    return IterableExtensions.join(IterableExtensions.<String, String>map(IterableExtensions.<String>take(_segments, _minus), _function), ".");
  }
  
  public JvmTypeReference generateForType(final EObject container, final DType element, final IJvmDeclaredTypeAcceptor acceptor) {
    if (element instanceof DEnumeration) {
      return _generateForType(container, (DEnumeration)element, acceptor);
    } else if (element instanceof DComplexType) {
      return _generateForType(container, (DComplexType)element, acceptor);
    } else if (element != null) {
      return _generateForType(container, element, acceptor);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(container, element, acceptor).toString());
    }
  }
  
  public void infer(final EObject element, final IJvmDeclaredTypeAcceptor acceptor, final boolean isPreIndexingPhase) {
    if (element instanceof EndpointDeclarationBlock) {
      _infer((EndpointDeclarationBlock)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element instanceof ExceptionMapping) {
      _infer((ExceptionMapping)element, acceptor, isPreIndexingPhase);
      return;
    } else if (element != null) {
      _infer(element, acceptor, isPreIndexingPhase);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(element, acceptor, isPreIndexingPhase).toString());
    }
  }
  
  private String getQualifiedName(final EObject complexType) {
    if (complexType instanceof DComplexType) {
      return _getQualifiedName((DComplexType)complexType);
    } else if (complexType instanceof DNamedElement) {
      return _getQualifiedName((DNamedElement)complexType);
    } else if (complexType instanceof EndpointDeclarationBlock) {
      return _getQualifiedName((EndpointDeclarationBlock)complexType);
    } else if (complexType instanceof ExceptionMapping) {
      return _getQualifiedName((ExceptionMapping)complexType);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(complexType).toString());
    }
  }
}
