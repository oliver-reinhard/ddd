/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.tests

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.DIdentityType
import com.mimacom.ddd.dm.base.DNamedElement
import com.mimacom.ddd.dm.base.impl.DFunctionImpl
import com.mimacom.ddd.dm.dmx.DmxModel
import com.mimacom.ddd.dm.dmx.impl.DAssignmentImpl
import com.mimacom.ddd.dm.dmx.impl.DBooleanLiteralImpl
import com.mimacom.ddd.dm.dmx.impl.DConstructorCallImpl
import com.mimacom.ddd.dm.dmx.impl.DContextReferenceImpl
import com.mimacom.ddd.dm.dmx.impl.DDecimalLiteralImpl
import com.mimacom.ddd.dm.dmx.impl.DFunctionCallImpl
import com.mimacom.ddd.dm.dmx.impl.DNaturalLiteralImpl
import com.mimacom.ddd.dm.dmx.impl.DUndefinedLiteralImpl
import com.mimacom.ddd.dm.dmx.impl.DRaiseExpressionImpl
import com.mimacom.ddd.dm.dmx.impl.DReturnExpressionImpl
import com.mimacom.ddd.dm.dmx.impl.DSelfExpressionImpl
import com.mimacom.ddd.dm.dmx.impl.DStringLiteralImpl
import com.mimacom.ddd.dm.dmx.impl.DNavigableMemberReferenceImpl
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith

import static org.junit.Assert.*

@ExtendWith(InjectionExtension)
@InjectWith(DmxInjectorProvider)
class DmxParsingTest {
	@Inject extension ParseHelper<DmxModel> parseHelper
	
	@Test
	def void testLiterals() {
		val result = parseHelper.parse('''
			expr 0: true;
			expr 1: "Domain Model";
			expr 2: 2;
			expr 3: 314.159E-2;
			expr 4: nil;
			expr 5: NIL;
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Literal errors: «errors.join("; ")»''')
		val expr = result.expressions
		
		val e0 = expr.get(0)
		assertEquals(DBooleanLiteralImpl, e0.class)
		assertEquals(true, (e0 as DBooleanLiteralImpl).value)
		val e1 = expr.get(1)
		assertEquals(DStringLiteralImpl, e1.class)
		assertEquals("Domain Model", (e1 as DStringLiteralImpl).value)
		val e2 = expr.get(2)
		assertEquals(e2.class, DNaturalLiteralImpl)
		assertEquals(2, (e2 as DNaturalLiteralImpl).value)
		val e3 = expr.get(3)
		assertEquals(e3.class, DDecimalLiteralImpl)
		assertEquals("314.159E-2", (e3 as DDecimalLiteralImpl).value)
		val e4 = expr.get(4)
		assertEquals(DUndefinedLiteralImpl, e4.class)
		val e5 = expr.get(5)
		assertEquals(DUndefinedLiteralImpl, e5.class)
	}
	
	@Test
	def void testPrimaries() {
		val result = parseHelper.parse('''
			expr 0: self;
			expr 1: return;
			expr 2: return 2;
			expr 3: raise "Expression";
			expr 4: (4);
			
			expr 5: f();
			expr 6: f(6);
			expr 7: new X;
			expr 8: new X(9);
			expr 9: A;
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Primaries errors: «errors.join("; ")»''')
		val expr = result.expressions
		
		val e0 = expr.get(0)
		assertEquals(DSelfExpressionImpl, e0.class)
		val e1 = expr.get(1)
		assertEquals(DReturnExpressionImpl, e1.class)
		assertEquals(null, (e1 as DReturnExpressionImpl).expression)
		val e2 = expr.get(2)
		assertEquals(DReturnExpressionImpl, e2.class)
		assertEquals(DNaturalLiteralImpl, (e2 as DReturnExpressionImpl).expression.class)
		val e3 = expr.get(3)
		assertEquals(DRaiseExpressionImpl, e3.class)
		assertEquals(DStringLiteralImpl, (e3 as DRaiseExpressionImpl).expression.class)
		val e4 = expr.get(4)
		assertEquals(DNaturalLiteralImpl, e4.class)
		assertEquals(4, (e4 as DNaturalLiteralImpl).value)
		
		val e5 = expr.get(5)
		assertEquals(DFunctionCallImpl, e5.class)
		// actual value of 'e5.function' cross reference is a proxy that gets resolved upon access => Exception => use basicGetFunction
		assertTrue((e5 as DFunctionCallImpl).basicGetFunction.eIsProxy)
		assertEquals(DFunctionImpl, (e5 as DFunctionCallImpl).basicGetFunction.class) 
		assertEquals(0, (e5 as DFunctionCallImpl).functionCallArguments.size)
		val e6 = expr.get(6)
		assertEquals(DFunctionImpl, (e6 as DFunctionCallImpl).basicGetFunction.class)
		assertEquals(1, (e6 as DFunctionCallImpl).functionCallArguments.size)
		assertEquals(DNaturalLiteralImpl, (e6 as DFunctionCallImpl).functionCallArguments.get(0).class)
		val e7 = expr.get(7)
		assertEquals(DConstructorCallImpl, e7.class)
		// actual value of 'e7.constructor' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue((e7 as DConstructorCallImpl).basicGetConstructor.eIsProxy)
		assertTrue((e7 as DConstructorCallImpl).basicGetConstructor instanceof DIdentityType) 
		assertFalse((e7 as DConstructorCallImpl).explicitConstructorCall)
		val e8 = expr.get(8)
		assertEquals(DConstructorCallImpl, e8.class)
		assertTrue((e8 as DConstructorCallImpl).basicGetConstructor instanceof DIdentityType) 
		assertTrue((e8 as DConstructorCallImpl).explicitConstructorCall)
		assertEquals(1, (e8 as DConstructorCallImpl).arguments.size)
		assertEquals(DNaturalLiteralImpl, (e8 as DConstructorCallImpl).arguments.get(0).class)
		val e9 = expr.get(9)
		assertEquals(DContextReferenceImpl, e9.class)
		// actual value of 'e9.contextElement' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue((e9 as DContextReferenceImpl).basicGetTarget.eIsProxy)
		assertTrue((e9 as DContextReferenceImpl).basicGetTarget instanceof DNamedElement)
		
	}
	
	@Test
	def void testMemberFeatureCalls() {
		val result = parseHelper.parse('''
			expr 0: self.a;
			expr 1: self.a.b;
			expr 2: A.b;
			expr 3: A.b.c;
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''MemberFeatureCalls errors: «errors.join("; ")»''')
		val expr = result.expressions
		
		val e0 = expr.get(0)
		// DMemberFeatureCall -- memberContainer --> DSelfExpression
		assertEquals(DNavigableMemberReferenceImpl, e0.class)
		// actual value of 'e0.member' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue((e0 as DNavigableMemberReferenceImpl).basicGetMember.eIsProxy)
		assertEquals(DSelfExpressionImpl, (e0 as DNavigableMemberReferenceImpl).memberContainerReference.class)
		
		val e1 = expr.get(1)
		// DMemberFeatureCall -- memberContainer --> DMemberFeatureCall -- memberContainer --> DSelfExpression
		assertEquals(DNavigableMemberReferenceImpl, e1.class)
		val e1_1 = e1 as DNavigableMemberReferenceImpl
		assertTrue(e1_1.basicGetMember.eIsProxy)
		assertEquals(DNavigableMemberReferenceImpl, e1_1.memberContainerReference.class)
		val e1_2 = e1_1.memberContainerReference as DNavigableMemberReferenceImpl
		assertTrue(e1_2.basicGetMember.eIsProxy)
		assertEquals(DSelfExpressionImpl, e1_2.memberContainerReference.class)
		
		val e2 = expr.get(2)
		// DMemberFeatureCall -- memberContainer --> DContextReference
		assertEquals(DNavigableMemberReferenceImpl, e2.class)
		val e2_1 = e2 as DNavigableMemberReferenceImpl
		// actual value of 'e2.member' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue((e2_1 as DNavigableMemberReferenceImpl).basicGetMember.eIsProxy)
		assertEquals(DContextReferenceImpl, e2_1.memberContainerReference.class)
		val e2_2 = e2_1.memberContainerReference as DContextReferenceImpl
		// actual value of 'e2.reference' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue(e2_2.basicGetTarget.eIsProxy)
		assertTrue(e2_2.basicGetTarget instanceof DNamedElement)
		
		val e3 = expr.get(3)
		// DMemberFeatureCall -- memberContainer --> DMemberFeatureCall -- memberContainer --> DContextReference
		assertEquals(DNavigableMemberReferenceImpl, e3.class)
		val e3_1 = e3 as DNavigableMemberReferenceImpl
		assertTrue(e3_1.basicGetMember.eIsProxy)
		assertEquals(DNavigableMemberReferenceImpl, e3_1.memberContainerReference.class)
		val e3_2 = e3_1.memberContainerReference as DNavigableMemberReferenceImpl
		assertTrue(e3_2.basicGetMember.eIsProxy)
		assertEquals(DContextReferenceImpl, e3_2.memberContainerReference.class)
		val e3_3 = e3_2.memberContainerReference as DContextReferenceImpl
		// actual value of 'e3_2.reference' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue(e3_3.basicGetTarget.eIsProxy)
		assertTrue(e3_3.basicGetTarget instanceof DNamedElement)
	}
	
	@Test
	def void testAssignment() {
		val result = parseHelper.parse('''
			expr 0: a := 0;
			expr 1: self.a := 1;
			expr 2: A.b := 2;
			expr 3: A.b.c := 3;
		''')
		assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Assignment errors: «errors.join("; ")»''')
		val expr = result.expressions
		
		val e0 = expr.get(0)
		assertEquals(DAssignmentImpl, e0.class)
		// actual value of 'e0.member' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue((e0 as DAssignmentImpl).basicGetMember.eIsProxy)
		assertNull((e0 as DAssignmentImpl).memberContainer)
		assertEquals(DNaturalLiteralImpl, (e0 as DAssignmentImpl).value.class)
		
		val e1 = expr.get(1)
		assertEquals(DAssignmentImpl, e1.class)
		assertTrue((e1 as DAssignmentImpl).basicGetMember.eIsProxy)
		assertEquals(DSelfExpressionImpl, (e1 as DAssignmentImpl).memberContainer.class)
		assertEquals(DNaturalLiteralImpl, (e1 as DAssignmentImpl).value.class)
		
		val e2 = expr.get(2)
		assertEquals(DAssignmentImpl, e2.class)
		assertTrue((e2 as DAssignmentImpl).basicGetMember.eIsProxy)
		assertEquals(DContextReferenceImpl, (e2 as DAssignmentImpl).memberContainer.class)
		assertEquals(DNaturalLiteralImpl, (e2 as DAssignmentImpl).value.class)
		
		val e3 = expr.get(3)
		// DMemberFeatureCall -- memberContainer --> DMemberFeatureCall -- memberContainer --> DContextReference
		assertEquals(DAssignmentImpl, e3.class)
		assertTrue((e3 as DAssignmentImpl).basicGetMember.eIsProxy)
		assertEquals(DNavigableMemberReferenceImpl, (e3 as DAssignmentImpl).memberContainer.class)
		val e3_1 = (e3 as DAssignmentImpl).memberContainer as DNavigableMemberReferenceImpl
		// actual value of 'e3.member' cross reference is a proxy that gets resolved upon access => Exception
		assertTrue(e3_1.basicGetMember.eIsProxy)
		assertEquals(DContextReferenceImpl, e3_1.memberContainerReference.class)
		assertEquals(DNaturalLiteralImpl, (e3 as DAssignmentImpl).value.class)
		}
	
//	@Test
//	def void testQualifiedNameProvider() {
//		val result = parseHelper.parse('''
//		class A {attr a A; }
//		class B { attr a A; attr b A; }
//		''')
//		result.assertNotNull
//		// DmxDeclarativeQualifiedNameProvider.xtend returns simple names for DTestFeature:
//		result.assertExportedEObjectDescriptions("A, a, B, a, b")
//	}
//	
//	def private assertExportedEObjectDescriptions(EObject o, CharSequence expected) {
//		val actual = o.exportedEObjectDescriptions.map[qualifiedName].join(", ")
//		expected.toString.assertEquals(actual)
//	}
//	
//	@Test
//	def void testMemberFeatureCall() {
//		val result = parseHelper.parse('''
//				class A {}
//				class B { attr a A; attr b A; }
//				class X { attr y B; attr z B; }
//				expr B.a := B.b
//				expr X.y.a := X.z.b
//		''')
//		Assertions.assertNotNull(result)
//		val errors = result.eResource.errors
//		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
//	}
//	
//	@Test
//	def void testFunctionCall() {
//		val result = parseHelper.parse('''
//			class A {}
//			class B { attr a A; attr b A; }
//			class X { attr y B; attr z B; }
//			function fb returns B;
//			function fx returns X;
//			expr fb(4).a := fb(4).b
//			expr fx(4).y.a := fx(4).z.b
//		''')
//		Assertions.assertNotNull(result)
//		val errors = result.eResource.errors
//		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
//	}
}
