/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dmx.tests

import com.google.inject.Inject
import com.google.inject.Provider
import com.mimacom.ddd.dm.base.DExpression
import com.mimacom.ddd.dm.dim.DimStandaloneSetup
import com.mimacom.ddd.dm.dmx.DmxNamespace
import com.mimacom.ddd.dm.dmx.DmxTest
import com.mimacom.ddd.dm.dmx.evaluator.DmxExpressionEvaluator
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider
import java.math.BigDecimal
import java.util.Date
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.ResourceSet
import org.eclipse.emf.ecore.util.Diagnostician
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import static org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import com.mimacom.ddd.dm.base.DInformationModel

@ExtendWith(InjectionExtension)
@InjectWith(DmxInjectorProvider)
class DmxEvaluatorTest {
	
	@Inject ParseHelper<DmxNamespace> dmxParseHelper
	@Inject Provider<ResourceSet> resourceSetProvider
	@Inject extension DmxExpressionEvaluator
	@Inject extension DmxTypeComputer
	final ParseHelper<DInformationModel> dimParseHelper
	
	new() {
		val dimInjector = new DimStandaloneSetup().createInjectorAndDoEMFRegistration()
		dimParseHelper = dimInjector.getInstance(ParseHelper)
	}
	
	def EList<DmxTest> parse(CharSequence input) {
		val resourceSet = resourceSetProvider.get
		
		// Provide SystemTypes:
		val systemTypes = dmxParseHelper.parse('''
			namespace dm.types
			archetype Boolean		is BOOLEAN
			archetype Natural 		is NUMBER	
			archetype Text				is TEXT
			archetype Timepoint	is TIMEPOINT
			''', resourceSet)
		assertNotNull(systemTypes)
		val stErrors = systemTypes.eResource.errors
		assertTrue(stErrors.isEmpty, '''Parse errors in system types: «stErrors.join(", ")»''')
		
		// Provide custom types:
		val customTypes = dimParseHelper.parse('''
			domain D
			primitive P1 redefines Natural
			enumeration E1 { L1, L2 }
			detail A {
				a0 : Text
				a1 : Natural?
				a2 : Natural
				a3 : E1
				a4 : Natural*
				a5 : Timepoint
				a6 : Boolean
				a7 : A
				detail b1 : B
				detail b2 : B+
				q0(): Natural
				q1(p:P1) : Natural
				q2(left:P1, right:P1) : Natural
				q3() : B
			}
			detail B {
				b1 : Natural
				q5(p:P1) : Natural
			}
		''', resourceSet)
		assertNotNull(customTypes)
		val ctErrors = systemTypes.eResource.errors
		assertTrue(ctErrors.isEmpty, '''Parse errors in custom types: «ctErrors.join(", ")»''')
		
		// Parse actual expression
		val result = dmxParseHelper.parse(input, resourceSet)
		assertNotNull(result)
		val errors = result.eResource.errors
		assertTrue(errors.isEmpty, '''Parse errors: «errors.join("; ")»''')
		return result.tests
	}
	
	@Test
	def void testLiterals() {
		val tests = parse('''
			namespace N
			test T00 { true }
			test T01 { false }
			test T02 { 0 }
			test T03 { 22 }
			test T04 { -1 }
			test T05 { 3.1415 }
			test T06 { 3141.526E-3 }
			test T07 { "String" }
			test T08 { undefined }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00, true)
		
		val e01 = tests.get(1).expr
		assertBoolean(e01, false)
		
		val e02 = tests.get(2).expr
		assertNumber(e02, new BigDecimal(0))
		
		val e03 = tests.get(3).expr
		assertNumber(e03, new BigDecimal(22))
		
		val e04 = tests.get(4).expr
		assertNumber(e04, new BigDecimal(-1))
		
		val e05 = tests.get(5).expr
		assertNumber(e05, new BigDecimal("3.1415")) // quotes eliminate rounding errors
		
		val e06 = tests.get(6).expr
		assertNumber(e06, new BigDecimal("3141.526E-3")) // quotes eliminate rounding errors
		
		val e07 = tests.get(7).expr
		assertText(e07, "String")
		
		val e08 = tests.get(8).expr
		assertValue(e08, DmxTypeDescriptorProvider::UNDEFINED_TYPE)
	}
	
	@Test
	def void testArithmetics() {
		val tests = parse('''
			namespace N
			test T00 { 1 + 2 }
			test T01 { 1 - 2 }
			test T02 { 1 * 2 }
			test T03 { 1 / 2 }
			test T04 { 8 % 3 }
			test T05 { 2**4 }
			test T06 { "A" + "B" }
			test T08 context t : Timepoint { t + 155 } 				// add a number value
			test T09 context t : Timepoint { t - 155 } 				// subtract a number value
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertNumber(e00, new BigDecimal(3))
		
		val e01 = tests.get(1).expr
		assertNumber(e01, new BigDecimal(-1))
		
		val e02 = tests.get(2).expr
		assertNumber(e02, new BigDecimal(2))
		
		val e03 = tests.get(3).expr
		assertNumber(e03, new BigDecimal(0.5))
		
		val e04 = tests.get(4).expr
		assertNumber(e04, new BigDecimal(2))
		
		val e05 = tests.get(5).expr
		assertNumber(e05, new BigDecimal(16))
		
		val e06 = tests.get(6).expr
		assertText(e06, "AB")
		
//		val e08 = tests.get(8).expr
//		assertType(e08, )
//		
//		val e09 = tests.get(9).expr
//		assertType(e09, DmxTypeDescriptorProvider::TIMEPOINT)
		
		}
	/*
	@Test
	def void testTimepoints() {
		val tests = parse('''
		import D.*
		namespace N
		test T00 context a : Timepoint, b : Timepoint { a = b }
		test T01 context a : A, b : Timepoint { a.a5 := b }  
		test T02 context a : A { a.a5 := "2019-05-15" }			// right-hand side parsed as date
		test T03 context a : A { a.a5 := "2019-05-15 10:48" }	// right-hand side parsed as date + time
		test T05 context t : Timepoint { t <= "2019-05-15" }	
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00)
		
		val e01 = tests.get(1).expr
		assertVoid(e01)
		
		val e02 = tests.get(2).expr
		assertVoid(e02)
		
		val e03 = tests.get(3).expr
		assertVoid(e03)
		
		val e05 = tests.get(5).expr
		assertBoolean(e05)
		
		}
	
	
	@Test
	def void testLists() {
		val tests = parse('''
			import D.*
			namespace N
			test T00 {  {}  }  // empty collection
			test T01 { {1} }
			test T02 { {1,2} }
			test T05 { {1,2} = {} }
			test T06 { {1,2} = {1,2} }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertValue(e00, DmxTypeDescriptorProvider::UNDEFINED_TYPE, DmxExpressionEvaluator::UNDEFINED_VALUE)
		
		val e01 = tests.get(1).expr
		assertValue(e01, DmxTypeDescriptorProvider::NUMBER_COLLECTION, new ArrayList())
		
		val e02 = tests.get(2).expr
		assertValue(e02, DmxTypeDescriptorProvider::NUMBER_COLLECTION)
		
		val e05 = tests.get(5).expr
		assertBoolean(e05)
		
		val e06 = tests.get(6).expr
		assertBoolean(e06)
	}
	
	@Test
	def void testIn() {
		val tests = parse('''
		import D.*
		namespace N
		test T00 context a : A { 3 in {3,4} }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00)
	}
	*/
	@Test
	def void testEquality() {
		val tests = parse('''
			import D.*
			namespace N
			test T00  { 3 = 3 }
			test T01  { 3 != 3 }
			test T02  { 3 <> 3 }
			test T03 { E1.L1 = E1.L1 }  					// Enumerations
			test T04 { E1.L1 <> E1.L2 }  					// Enumerations
			test T05 context a : A := detail A { a2 = 3} { a.a2 = 3 }
			test T06 context a : A := detail A { a4 = {} } { a.a4 = {} }
			test T07 context a : A := detail A { a4 = {1} } { a.a4 = {1} }
			test T08 context a : A := detail A { a4 = {1, 2, 3} } { a.a4 = {1, 2, 3} }
			test T09 context a : A := detail A { a4 = {1, 2, 3} } { a.a4 <> {1, 2} }
			// test T07  context a : A { a.q1(2) = 3 }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00, true)
		
		val e01 = tests.get(1).expr
		assertBoolean(e01, false)
		
		val e02 = tests.get(2).expr
		assertBoolean(e02, false)
		
		val e03 = tests.get(3).expr
		assertBoolean(e03, true)
		
		val e04 = tests.get(4).expr
		assertBoolean(e04, true)
		
		val e05 = tests.get(5).expr
		assertBoolean(e05, true)
		
		val e06 = tests.get(6).expr
		assertBoolean(e06, true)
		
		val e07= tests.get(7).expr
		assertBoolean(e07, true)
		
		val e08 = tests.get(8).expr
		assertBoolean(e08, true)
	}
	
	@Test
	def void testTest() {
		val tests = parse('''
			import D.*
			namespace N
			test T00 context a : A := detail A { a4 = {1, 2, 3} } { a.a4 <> {1, 2} }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00, true)
	}
	/*
	@Test
	def void testRelationalOperators() {
		val tests = parse('''
			import D.*
			namespace N
			// "comparable" types:
			test T00 context a : Natural, b : Natural { a > b }
			test T01 context a : Text, b : Text { a > b }
			test T02 context a : Timepoint, b : Timepoint { a > b }
			
			test T03 context a : Natural, b : Natural { a >= b }
			test T04 context a : Natural, b : Natural { a ≥ b }
			test T05 context a : Natural, b : Natural { a < b }
			test T06 context a : Natural, b : Natural { a <= b }
			test T07 context a : Natural, b : Natural { a ≤ b }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00)
		
		val e01 = tests.get(1).expr
		assertBoolean(e01)
		
		val e02 = tests.get(2).expr
		assertBoolean(e02)
		
		val e03 = tests.get(3).expr
		assertBoolean(e03)
		
		val e04 = tests.get(4).expr
		assertBoolean(e04)
		
		val e05 = tests.get(5).expr
		assertBoolean(e05)
		
		val e06 = tests.get(6).expr
		assertBoolean(e06)
		
		val e07 = tests.get(7).expr
		assertBoolean(e07)
	}
	*/
	@Test
	def void testBooleanOperators() {
		val tests = parse('''
			namespace N
			test T00 { true AND false }
			test T01 { true OR false }
			test T02 { true XOR true }
			test T03 { true => true }
			test T04 { NOT true }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertBoolean(e00, false)
		
		val e01 = tests.get(1).expr
		assertBoolean(e01, true)
		
		val e02 = tests.get(2).expr
		assertBoolean(e02, false)
		
		val e03 = tests.get(3).expr
		assertBoolean(e03, true)
		
		val e04 = tests.get(4).expr
		assertBoolean(e04, false)
	}
	/*/
	@Test
	def void testAssignments() {
		val tests = parse('''
		import D.*
		namespace N
		test T01 context a : A { a.a1 := 1 }  
		test T04 context a : A { a.b1.b1 := 3 }
		test T05 context a : A { a.a1 := a.q0() } 
		test T06 context a : A { a.a4 := {} }
		test T07 context a : A { a.a4 := {3} }
		test T08 context a : A { a.a4 := {3,4} }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e01 = tests.get(1).expr
		assertVoid(e01)
		
		val e04 = tests.get(4).expr
		assertVoid(e04)
		
		val e05 = tests.get(5).expr
		assertVoid(e05)
		
		val e06 = tests.get(6).expr
		assertVoid(e06)
		
		val e07 = tests.get(7).expr
		assertVoid(e07)
		
		val e08 = tests.get(8).expr
		assertVoid(e08)
	}
	
	
	@Test
	def void testFunctionCalls() {
		val tests = parse('''
		import D.*
		namespace N
		test T00 context a : A { a.q0 } 
		test T01 context a : A { a.q0() } 
		test T04 context a : A { a.q1(1) } 
		test T07 context a : A { a.q2(1,2) } 
		test T09 context a : A { a.q2(1,2) }
		''')
		assertNoValidationErrors(tests.head.eContainer)
		
		val e00 = tests.get(0).expr
		assertNumber(e00)
		
		val e01 = tests.get(1).expr
		assertNumber(e01)
		
		val e04 = tests.get(4).expr
		assertNumber(e04)
		
		val e07 = tests.get(7).expr
		assertNumber(e07)
		
		val e09 = tests.get(9).expr
		assertNumber(e09)
	}
	*/
	// ------------------------------
	
	def void assertValue(DExpression expr, AbstractDmxTypeDescriptor<?> expectedType) {
		val type = expr.typeFor
		assertTrue((type).isCompatibleWith(expectedType), "Was: " + type.toString + ", expected: " + expectedType)
	}
	
	def void assertNumber(DExpression expr, BigDecimal expected) {
		assertValue(expr, DmxTypeDescriptorProvider::NUMBER)
		assertEquals(expected, expr.valueFor)
	}
	
	def void assertBoolean(DExpression expr, boolean expected) {
		assertValue(expr, DmxTypeDescriptorProvider::BOOLEAN)
		assertEquals(expected, expr.valueFor)
	}
	
	def void assertText(DExpression expr, String expected) {
		assertValue(expr, DmxTypeDescriptorProvider::TEXT)
		assertEquals(expected, expr.valueFor)
	}
	
	def void assertTimepoint(DExpression expr, Date expected) {
		assertValue(expr, DmxTypeDescriptorProvider::TIMEPOINT)
		assertEquals(expected, expr.valueFor)
	}
	
	def void assertVoid(DExpression expr) {
		assertValue(expr, DmxTypeDescriptorProvider::VOID)
	}
	
	def assertNoValidationErrors(EObject obj) {
//		val result = Diagnostician.INSTANCE.validate(EcoreUtil.getRootContainer(obj)).children
		val result = Diagnostician.INSTANCE.validate(obj).children
		assertTrue(result.isEmpty, '''Validation errors: «result.join("; ")»''')
	}
	
	def assertHasValidationERRORS(EObject obj) {
		val result = Diagnostician.INSTANCE.validate(obj).children
		assertTrue(result.size >= 1, "No validation errors")
	}
}
