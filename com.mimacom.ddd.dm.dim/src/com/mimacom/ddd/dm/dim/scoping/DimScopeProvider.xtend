/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dim.scoping

import com.google.common.collect.Lists
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DAssociation
import com.mimacom.ddd.dm.base.DAttribute
import com.mimacom.ddd.dm.base.DDetailType
import com.mimacom.ddd.dm.base.DEntityType
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DQueryParameter
import com.mimacom.ddd.dm.base.IAggregateContainer
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class DimScopeProvider extends AbstractDimScopeProvider {

	val BASE = BasePackage.eINSTANCE

	override getScope(EObject context, EReference reference) {

		if (reference == BASE.DNavigableMember_Type) {
			return getNavigableMemberTypeScope(context, IScope.NULLSCOPE)

		} else if (reference == BASE.DComplexType_SuperType) {
			return switch context {
				DEntityType: getIdentityTypeScope(context, DEntityType)
				DDetailType: getDefaultScopeOfType(context, BASE.DDetailType)
				default: IScope.NULLSCOPE
			}
		}
		return super.getScope(context, reference)
	}

	/*
	 * Returns the scope for the 'type' property of DNavigableMembers.
	 */
	def IScope getNavigableMemberTypeScope(EObject context, IScope outerScope) {
		// This is classic scoping along the eContainer CONTAINMENT hierarchy:
		val type = switch context {
			DAttribute:	if (context.detail) BASE.DDetailType else BASE.IValueType
			DQuery:BASE.DType
			DAssociation: BASE.DEntityType
			DQueryParameter:BASE.DType
			default:BASE.IValueType
		}
		val IScope scope = getDefaultScopeOfType(context, type)
		return scope
	}

	def IScope getIdentityTypeScope(
		DEntityType context,
		Class<?> type
	) {
		val domain = EcoreUtil2.getContainerOfType(context, IAggregateContainer)
		if (domain !== null) {
			val list = Lists.newArrayList
			for (a : domain.aggregates) {
				val roots = a.roots.filter[it !== context && type.isAssignableFrom(it.class)]
				list.addAll(roots)
			}
			return Scopes.scopeFor(list)
		}
		return IScope.NULLSCOPE
	}
}
