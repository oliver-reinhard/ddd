grammar com.mimacom.ddd.dm.dim.Dim with com.mimacom.ddd.dm.dmx.Dmx

import "http://www.mimacom.com/ddd/dm/dmx" 
import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
 * MODEL STRUCTURE
 */

@Override 
DNamespace:
	'domain'
	name=DQualifiedName
	(imports+=DImport)*
	model=DInformationModel;

DInformationModel:
	'information' 'model'
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?
	'{'
	(types+=DType | aggregates+=DAggregate)*
	'}';

	
DAggregate:
	{DAggregate}
	DAggregateKeyword
	name=ID
	(description=DRichText)?
	'{'
		('query' features+=DQuery)*
		( types+=DType)*
	'}';

DAggregateKeyword:
	'component';
/*
 * TYPES
 */
DType:
	DPrimitive | DEnumeration | DEntityType | DDetailType;
	
DConstraint returns DNamedPredicate:
	'constraint'
	name=ID
	('alias' aliases+=ID)*
	':'
	predicate=DExpression
	(description=DRichText)?;

DPrimitive:
	'primitive'
	name=ID
	('alias' aliases+=ID)*
	'redefines' redefines=[DmxArchetype]
	(description=DRichText)?
	(	'{'
		(constraints+=DConstraint)+
		'}'
	)?;


DEnumeration:
	'enumeration'
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?
	'{'
	 	(literals+=DLiteral (',' literals+=DLiteral)*)?
		(constraints+=DConstraint)*
	 '}';

DLiteral:
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?;

DEntityType:
	(abstract?='abstract')?
	(root?='main')?
	(	'entity'
	|	nature=DEntityNatureAutonomous 'entity'	// validation: cannot be abstract
	|	nature=DEntityNatureRelationship
	) 
	DComplexType
	'{'
	(	'states' 
		'{'
		states+=DState (',' states+=DState)*
		'}'
		(	'events'
			'{'
			events+=DStateEvent (',' events+=DStateEvent)*
			'}'
		)?
	)?
	(features+=DFeature | constraints+=DConstraint)*
	'}';
	
enum DEntityNatureAutonomous returns DEntityNature:
	AUTONOMOUS_ENTITY='autonomous';	
enum DEntityNatureRelationship returns DEntityNature:
	RELATIONSHIP='relationship';	

DState:
	name=ID;

DStateEvent:
	name=ID;

DDetailType:
	(abstract?='abstract')?
	'detail'
	DComplexType
	'{'
	(features+=DFeature | constraints+=DConstraint)*
	'}';

fragment DComplexType:
	name=ID
	('alias' aliases+=ID)*
	('extends' superType=[DComplexType|ID])?
	(description=DRichText)?;
	
DFeature:
	DAssociation |  DAttribute | DQuery;

DAssociation:
	(derived?='derived')? 
	name=ID
	('alias' aliases+=ID)*
	(kind=DAssociationKind | (kind=DAssociationKindInverse "contains"))
	(type=[DEntityType|ID])?  // optional: allows parser to continue parsing potential targets, caught by validation
	(multiplicity=DMultiplicity)?
	(description=DRichText)?;

enum DAssociationKind:
	REFERENCE="references" | COMPOSITE="contains";

enum DAssociationKindInverse returns DAssociationKind:	
	 INVERSE_COMPOSITE="inverse";
	
DAttribute:
	(detail?='detail')?
	name=ID
	('alias' aliases+=ID)*
	':'
	(type=[DType|ID])? // optional: allows parser to continue parsing potential targets, caught by validation
	(multiplicity=DMultiplicity)?
	(key?='key')?
	(description=DRichText)?;

DQuery:
	name=ID
	('alias' aliases+=ID)*
	'(' (parameters+=DQueryParameter ( "," parameters+=DQueryParameter)*)? ')'
	':' 
	(type=[DType|ID])?  // optional: allows parser to continue parsing potential targets, caught by validation
	(multiplicity=DMultiplicity)?
	('returns' ^returns=DExpression)?
	(description=DRichText)?;

DQueryParameter:
	name=ID 
	':' 
	(type=[DType|ID])? // optional: allows parser to continue parsing potential targets, caught by validation
	(multiplicity=DMultiplicity)?
	(description=DRichText)?;

