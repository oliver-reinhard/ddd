grammar com.mimacom.ddd.dm.dim.Dim with com.mimacom.ddd.dm.dmx.Dmx

import "http://www.mimacom.com/ddd/dm/dmx" 
import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

/*
 * MODEL STRUCTURE
 */

DDomain:
	(imports+=DImport)*
	'domain'
	name=DQualifiedName
	('alias' aliases+=ID)*
	(description=DRichText)?
	(types+=DType | aggregates+=DAggregate)*;

	
DAggregate:
	{DAggregate}
	'component'
	name=ID
	(description=DRichText)?
	'{'
		('query' staticQueries+=DQuery)*
		( types+=DType)*
	'}';

/*
 * TYPES
 */
DType:
	DPrimitive | DEnumeration | DEntityType | DRelationship | DDetailType;
	
DConstraint returns DNamedPredicate:
	'constraint'
	name=ID
	('alias' aliases+=ID)*
	':'
	predicate=DExpression
	(description=DRichText)?;

DPrimitive:
	'primitive'
	name=ID
	('alias' aliases+=ID)*
	'redefines' redefines=[DmxArchetype]
	(description=DRichText)?
	(	'{'
		(constraints+=DConstraint)+
		'}'
	)?;


DEnumeration:
	'enumeration'
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?
	'{'
	 	(literals+=DLiteral (',' literals+=DLiteral)*)?
		(constraints+=DConstraint)*
	 '}';

DLiteral:
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?;

DEntityType:
	(abstract?='abstract')?
	(	(root?='root')?
		origin=DIdentityOriginGeneric
	|	(root?='main')?
		(	'physical' origin=DIdentityOriginObject // validation: cannot be abstract
		|	'virtual' origin=DIdentityOriginConcept
		) 
	)
	DComplexType;

DRelationship:
	(abstract?='abstract')?
	(root?='root' | root?='main')?
	'relationship'
	DComplexType;
	
enum DIdentityOriginObject returns DIdentityOrigin:
	REAL_WORLD_OBJECT='object';	
enum DIdentityOriginConcept returns DIdentityOrigin:
	VIRTUAL_CONCEPT='concept';	
enum DIdentityOriginGeneric returns DIdentityOrigin:
	GENERIC_ENTITY='entity';	

DDetailType:
	(abstract?='abstract')?
	'detail'
	DComplexType;

fragment DComplexType:
	name=ID
	('alias' aliases+=ID)*
	('extends' superType=[DComplexType|ID])?
	(description=DRichText)?
	'{'
		(features+=DFeature | constraints+=DConstraint)*
	'}';
	
DFeature:
	DAssociation |  DAttribute | DQuery;

DAssociation:
	(derived?='derived')? 
	(kind=DAssociationKind | (kind=DAssociationKindInverse "contains"))
	name=ID
	('alias' aliases+=ID)*
	':'
	type=[DEntityType|ID]  (multiplicity=DMultiplicity)?
	(description=DRichText)?;

enum DAssociationKind:
	REFERENCE="references" | COMPOSITE="contains";

enum DAssociationKindInverse returns DAssociationKind:	
	 INVERSE_COMPOSITE="inverse";
	
DAttribute:
	(detail?='detail')?
	(name=ID
	('alias' aliases+=ID)*
	':'
	type=[DType|ID] )
	(multiplicity=DMultiplicity)?
	(key?='key')?
	(description=DRichText)?;

DQuery:
	name=ID
	('alias' aliases+=ID)*
	'(' (parameters+=DQueryParameter ( "," parameters+=DQueryParameter)*)? ')'
	':' 
	type=[DType|ID]  (multiplicity=DMultiplicity)?
	('returns' ^returns=DExpression)?
	(description=DRichText)?;

DQueryParameter:
	name=ID 
	':' 
	type=[DType|ID]  (multiplicity=DMultiplicity)?
	(description=DRichText)?;

