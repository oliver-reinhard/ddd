/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dim.validation

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.BasePackage
import com.mimacom.ddd.dm.base.base.DAggregate
import com.mimacom.ddd.dm.base.base.DAssociation
import com.mimacom.ddd.dm.base.base.DAttribute
import com.mimacom.ddd.dm.base.base.DComplexType
import com.mimacom.ddd.dm.base.base.DContext
import com.mimacom.ddd.dm.base.base.DEntityNature
import com.mimacom.ddd.dm.base.base.DEntityType
import com.mimacom.ddd.dm.base.base.DEnumeration
import com.mimacom.ddd.dm.base.base.DFeature
import com.mimacom.ddd.dm.base.base.DLiteral
import com.mimacom.ddd.dm.base.base.DMultiplicity
import com.mimacom.ddd.dm.base.base.DNamedElement
import com.mimacom.ddd.dm.base.base.DNamedPredicate
import com.mimacom.ddd.dm.base.base.DNavigableMember
import com.mimacom.ddd.dm.base.base.DPrimitive
import com.mimacom.ddd.dm.base.base.DQuery
import com.mimacom.ddd.dm.base.base.DQueryParameter
import com.mimacom.ddd.dm.base.base.DState
import com.mimacom.ddd.dm.base.base.DStateEvent
import com.mimacom.ddd.dm.base.base.DType
import com.mimacom.ddd.dm.base.base.IFeatureContainer
import com.mimacom.ddd.dm.base.base.ITypeContainer
import com.mimacom.ddd.dm.base.base.IValueType
import com.mimacom.ddd.dm.base.synthetic.TSyntheticEnumeration
import com.mimacom.ddd.dm.base.synthetic.TSyntheticQuery
import com.mimacom.ddd.dm.base.transpose.ISyntheticElement
import com.mimacom.ddd.dm.dim.DimUtil
import com.mimacom.ddd.dm.dim.DomainInformationModel
import com.mimacom.ddd.dm.dim.derivedState.DimDerivedStateComputer
import java.util.List
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.validation.Check

import static com.mimacom.ddd.dm.dmx.scoping.DmxImportedNamespaceAwareLocalScopeProviderWithDmTypes.*

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DimValidator extends AbstractDimValidator {

	@Inject extension DimUtil

	protected static val BASE = BasePackage.eINSTANCE

	@Check
	def checkDomainDeclaresOnlyValueTypes(DomainInformationModel d) {
		for (vt : d.types) {
			if (! (vt instanceof IValueType)) {
				error('Declared type is not a value type', vt, BASE.DNamedElement_Name)
			} else if (vt instanceof DComplexType) {
				for (f : vt.features) {
					if (f instanceof DAssociation) {
						error('Declared feature cannot be an association', f, BASE.DNamedElement_Name)
					}
				}
			}
		}
	}

	@Check
	def checkAggregateHasSingleRootOrRootHiearchy(DAggregate a) {
		val roots = a.types.filter(DEntityType).filter[isRoot]
		// only one root hierarchy is allowed => top level is in same aggregate (superType == null) or in another aggregate
		val topLevelRoots = roots.filter[superType.aggregate != a]
		if (topLevelRoots.size > 1) {
			for (r : roots) {
				error('Aggregate can only declare a single root / main entity or relationship or a a single hierarchy thereof', r,
					BASE.DNamedElement_Name)
			}
		}
//		if(roots.size == 0) {
//			warning('Aggregate does not declare a root or a relationship', a, BASE.DAGGREGATE)
//		}
	}

// Types: restrictions on features and supertypes
	@Check
	def checkCyclicTypeHierarchy(DComplexType t) {
		if (t.typeHierarchy.contains(t)) {
			error('Type is part of a supertype cycle', t, BASE.DNamedElement_Name)
		}
	}

	@Check
	def checkSupertype(DComplexType t) {
		if (t.superType !== null) {
			if (t.superType.eClass !== t.eClass) {
				error('Supertype is not compatible', t, BASE.DNamedElement_Name)
			} else if (t instanceof DEntityType) {
				if (t.isRoot !== (t.superType as DEntityType).isRoot) {
					error("Entity or relationship root property must match supertype's root property", t, BASE.DNamedElement_Name)
				}
			}
			val tDomain = EcoreUtil2.getContainerOfType(t, DomainInformationModel)
			val superTypeDomain = EcoreUtil2.getContainerOfType(t.superType, DomainInformationModel)
			if (superTypeDomain !== tDomain) {
				error('Supertype must be in same domain', t, BASE.DNamedElement_Name)
			}
		}
	}

	@Check
	def checkNoFeatureOverrides(DComplexType t) {
		val inherited = t.inheritedFeatureNames
		for (f : t.features) {
			if (inherited.contains(f.name) && f.name != DimDerivedStateComputer::SYNTHETIC_STATE_QUERY_NAME) {
				// Case of DimDerivedStateComputer::SYNTHETIC_STATE_QUERY_NAME is covered by another @Check
				error("Feature '" + f.name + "' cannot override inherited feature of same name", f, BASE.DNamedElement_Name)
			}
		}
	}

	@Check
	def checkRelationshipHasTwoAssociations(DEntityType r) {
		if (r.nature == DEntityNature.RELATIONSHIP) {
			var count = 0;
			for (i : 0 ..< r.features.size) {
				if (r.features.get(i) instanceof DAssociation) count++
			}
			if (count < 2) {
				error('A relationship must declare at least 2 associations', r, BASE.DNamedElement_Name)
			}
		}
	}

	@Check
	def checkPrimitiveDoesNotRedefineItself(DPrimitive p) {
		if (p.redefines == p) {
			error('Primitive cannot redefine itself', p, BASE.DPrimitive_Redefines)
		}
	}

	@Check
	def checkEnumerationHasLiterals(DEnumeration e) {
		if (e.literals.size == 0) {
			warning('Enumeration does not declare literals', e, BASE.DNamedElement_Name)
		}
	}

	@Check
	def checkFeatureTypeIsSet(DFeature f) {
		if (f.type === null) {
			error('Feature must have a type', f, BASE.DNamedElement_Name)
		}
	}

	@Check
	def checkNoFeatureNamedState(DFeature f) {
		if (f.name == DimDerivedStateComputer::SYNTHETIC_STATE_QUERY_NAME) {
			val container = EcoreUtil2.getContainerOfType(f, IFeatureContainer)
			if (container instanceof DEntityType) {
				val superTypes = container.typeHierarchy
				if (superTypes.exists(t|t instanceof DEntityType && ! (t as DEntityType).states.empty)) {
					if (f instanceof TSyntheticQuery) { // = this entity declares states
						error("Cannot declare states while states or a 'state' feature are declared for one of its super types.", container,
							BASE.DEntityType_States)
					} else { // = this entity declares an explicit 'state' feature
						error("Cannot declare a 'state' feature while states or a 'state' feature are declared for one of its super types.", f,
							BASE.DNamedElement_Name)
					}
				}
			}
		}
	}

	@Check
	def checkNoEnumNamedState(DEnumeration e) {
		if (e.name.endsWith(DimDerivedStateComputer::SYNTHETIC_STATES_ENUM_SUFFIX) && ! (e instanceof TSyntheticEnumeration)) {
			val container = EcoreUtil2.getContainerOfType(e, ITypeContainer)
			if (container !== null) {
				val len = DimDerivedStateComputer::SYNTHETIC_STATES_ENUM_SUFFIX.length
				val entityName = e.name.substring(0, e.name.length - len)
				val candidate = container.types.filter(DEntityType).filter[name == entityName].head

				if (candidate !== null && ! candidate.states.empty) {
					error("Cannot declare a '" + e.name + "' enumeration while entity '" + candidate.name + "' declares states.", e,
						BASE.DNamedElement_Name)
				}
			}
		}
	}

	@Check
	def checkAttributeIsValueType(DAttribute a) {
		if (! (a.type instanceof IValueType)) {
			error('Referenced type must be a ValueType', a, BASE.DNavigableMember_Type)
		}
	}

	@Check
	def checkRealWorldEntityType(DEntityType e) {
		if (e.nature == DEntityNature.AUTONOMOUS_ENTITY && e.abstract) {
			error('Autonomous entities cannot be abstract', e, BASE.DComplexType_Abstract)
		}
	}

	@Check
	def checkAssocitionToEntityType(DAssociation a) {
		if (! (a.getType instanceof DEntityType)) {
			error('Referenced type must be an EntityType', a, BASE.DNavigableMember_Type)
		}
	}

	@Check
	def checkAssociationMultiplicities(DMultiplicity m) {
		if (m.maxOccurs == 0) {
			error('Maximum targets cannot be 0', m, BASE.DMultiplicity_MaxOccurs)
		}
	}

	// // Queries: restrictions on types
	@Check
	def checkQueryType(DQuery q) {
		checkMemberType(q)
	}

	@Check
	def checkQueryParameterType(DQueryParameter p) {
		checkMemberType(p)
	}

	protected def checkMemberType(DNavigableMember member) {
		if (! member.isAllowedMemberType) {
			error("Referenced " + ILLEGAL_MEMBER_TYPE_MSG, member, BASE.DNavigableMember_Type)
		}
	}

	protected static val ILLEGAL_MEMBER_TYPE_MSG = "type must be a ValueType, the query's own container, or the component's main entity"

	protected def boolean isAllowedMemberType(DNavigableMember member) {
		val containingType = EcoreUtil2.getContainerOfType(member, DComplexType) // is null if container is an aggregate
		val aggregate = EcoreUtil2.getContainerOfType(member, DAggregate)
		val type = member.type
		return type instanceof IValueType || type == containingType ||
			type instanceof DEntityType && (type as DEntityType).root && aggregate.allTypes.contains(type)
	}

	// use to override
	protected def List<DType> allTypes(DAggregate a) {
		a.types
	}

	/*
	 * Naming: Elements whose names should start with a CAPITAL
	 */
	protected def void checkNameStartsWithCapitalImpl(String name, DNamedElement ne) {
		if (! (ne instanceof ISyntheticElement)) { // synthetic elements' names are generated and source may violate capitalization rule
			if (name !== null && name.length > 0 && !Character::isUpperCase(name.charAt(0))) {
				warning("Name should start with a capital", ne, BASE.DNamedElement_Name)
			}
		}
	}

	@Check
	def void checkTypeNameStartsWithCapital(DomainInformationModel d) {
		if (DEFAULT_IMPORT_TYPES == d.name) {
			return
		} else if (d.name !== null && d.name.startsWith(PREFIX + ".")) {
			checkNameStartsWithCapitalImpl(d.name.substring(3), d) // 3 = length of PREFIX + 1
			return
		}
		checkNameStartsWithCapitalImpl(d.name, d)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DAggregate a) {
		checkNameStartsWithCapitalImpl(a.name, a)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DType t) {
		checkNameStartsWithCapitalImpl(t.name, t)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DNamedPredicate c) {
		checkNameStartsWithCapitalImpl(c.name, c)
	}

	/*
	 * Naming: Elements whose names should start with a LOWERCASE
	 */
	protected def void checkNameStartsWithLowercaseImpl(DNamedElement ne) {
		if (! (ne instanceof ISyntheticElement)) { // synthetic elements' names are generated and source may violate capitalization rule
			if (ne.name !== null) {
				val first = ne.getName().charAt(0)
				val char underscore = '_'
				if (!Character::isLowerCase(first) && first !== underscore) {
					warning("Name should start with a lowercase or underscore", BASE.DNamedElement_Name)
				}
			}
		}
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DFeature f) {
		checkNameStartsWithLowercaseImpl(f)
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DQueryParameter p) {
		checkNameStartsWithLowercaseImpl(p)
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DContext c) {
		checkNameStartsWithLowercaseImpl(c)
	}

	/*
	 * Naming: Elements whose names should be ALL UPPERCASE
	 */
	protected def void checkLiteralIsUppercaseImpl(DNamedElement ne) {
		if (! (ne instanceof ISyntheticElement)) { // synthetic elements' names are generated and source may violate capitalization rule
			val name = ne.name
			if (name !== null && ! name.equals(name.toUpperCase)) {
				warning("Name should be all uppercase: " + ne.name, BASE.DNamedElement_Name)
			}
		}
	}

	@Check def void checkLiteralIsUppercase(DLiteral literal) {
		checkLiteralIsUppercaseImpl(literal)
	}

	@Check def void checkStateNameIsUppercase(DState state) {
		checkLiteralIsUppercaseImpl(state)
	}

	@Check def void checkStateEventNameIsUppercase(DStateEvent event) {
		checkLiteralIsUppercaseImpl(event)
	}
}
