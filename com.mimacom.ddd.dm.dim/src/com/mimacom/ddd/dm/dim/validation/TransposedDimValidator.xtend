/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dim.validation

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.BasePackage
import com.mimacom.ddd.dm.base.base.DAggregate
import com.mimacom.ddd.dm.base.base.DAssociation
import com.mimacom.ddd.dm.base.base.DAttribute
import com.mimacom.ddd.dm.base.base.DComplexType
import com.mimacom.ddd.dm.base.base.DDetailType
import com.mimacom.ddd.dm.base.base.DEntityType
import com.mimacom.ddd.dm.base.base.DEnumeration
import com.mimacom.ddd.dm.base.base.DFeature
import com.mimacom.ddd.dm.base.base.DNamedElement
import com.mimacom.ddd.dm.base.base.DNavigableMember
import com.mimacom.ddd.dm.base.base.DQuery
import com.mimacom.ddd.dm.base.base.DType
import com.mimacom.ddd.dm.base.base.IIdentityType
import com.mimacom.ddd.dm.base.base.IValueType
import com.mimacom.ddd.dm.base.transpose.ISyntheticElement
import com.mimacom.ddd.dm.base.transpose.ITransposableElement
import com.mimacom.ddd.dm.base.transpose.ITransposition
import com.mimacom.ddd.dm.base.transpose.TAggregateTransposition
import com.mimacom.ddd.dm.base.transpose.TAssociationTransposition
import com.mimacom.ddd.dm.base.transpose.TAttributeTransposition
import com.mimacom.ddd.dm.base.transpose.TComplexTypeTransposition
import com.mimacom.ddd.dm.base.transpose.TDetailTypeTransposition
import com.mimacom.ddd.dm.base.transpose.TDitchRule
import com.mimacom.ddd.dm.base.transpose.TEntityTypeTransposition
import com.mimacom.ddd.dm.base.transpose.TEnumerationTransposition
import com.mimacom.ddd.dm.base.transpose.TFeatureTransposition
import com.mimacom.ddd.dm.base.transpose.TFuseRule
import com.mimacom.ddd.dm.base.transpose.TGrabRule
import com.mimacom.ddd.dm.base.transpose.TImplicitTransposition
import com.mimacom.ddd.dm.base.transpose.TLiteralTransposition
import com.mimacom.ddd.dm.base.transpose.TQueryTransposition
import com.mimacom.ddd.dm.base.transpose.TStructureChangingRule
import com.mimacom.ddd.dm.base.transpose.TTristate
import com.mimacom.ddd.dm.base.transpose.TransposePackage
import com.mimacom.ddd.dm.dim.DimUtil
import com.mimacom.ddd.dm.dmx.scoping.DmxQualifiedNameProvider
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class TransposedDimValidator extends DimValidator {

	@Inject extension DimUtil

	@Inject IQualifiedNameProvider transposedQualifiedNameProvider
	@Inject DmxQualifiedNameProvider dimQualifiedNameProvider // TODO replace by injection of IQualifiedNameProvider based on DimRuntimeModule

	@Check
	override checkAggregateHasSingleRootOrRootHiearchy(DAggregate a) {
		val roots = a.types.filter(DEntityType).filter[! (it instanceof TEntityTypeTransposition) && isRoot]
		// only one root hierarchy is allowed => top level is in same aggregate (superType == null) or in another aggregate
		val topLevelRoots = roots.filter[superType.aggregate != a]
		if (topLevelRoots.size > 1) {
			for (r : roots) {
				error('Aggregate can only declare a single root or relationship or a single hierarchy thereof', r,
					BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
		}
	}

	@Check
	def checkCorrespondingAggregateType(TAggregateTransposition a) {
		if (a.rule.source !== null && ! (a.rule.source instanceof DAggregate)) {
			error("Transposed-aggregate rule must have a domain-model Aggregate as its source", a.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

// Types: restrictions on features and supertypes
	@Check
	def checkCorrespondingDEntityType(TEntityTypeTransposition t) {
		val source = t.rule.source
		if (source instanceof DEntityType) {
			if (source.root !== t.root) {
				error("Transposed-entity rule must match domain-model root property", t.rule, TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
			}
		} else if (source !== null) {
			error("Transposed-entity rule must have a domain-model entity as its source", t.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def checkCorrespondingDDetailType(TDetailTypeTransposition t) {
		if (t.rule.source !== null && ! (t.rule.source instanceof DDetailType)) {
			error("Transposed-DetailType rule must have a domain-model DetailType as its source", t.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def checkRootPropertyForDetailType(TDetailTypeTransposition t) {
		val rule = t.rule
		if (rule instanceof TStructureChangingRule) {
			val setsRootProperty = rule.getRootEntity != TTristate.DONT_CARE
			if (setsRootProperty) {
				warning("Setting the root property for DetailTypes does not have any effect.", rule,
					TransposePackage.Literals.TSTRUCTURE_CHANGING_RULE__ROOT_ENTITY)
			}
		}
	}

	@Check
	def void checkTransposedFeaturesCombination(TComplexTypeTransposition t) {
		if (t.rule instanceof TGrabRule) {
			val featureRecipes = (t as DComplexType).features.filter(TFeatureTransposition)
			val hasDitchElements = featureRecipes.exists[getRule instanceof TDitchRule]
			val hasGrabElements = featureRecipes.exists[getRule instanceof TGrabRule]
			if (hasDitchElements && hasGrabElements) {
				error("Cannot use both grab rule and ditch rules together.", t.rule, TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
			}
		}
	}

	@Check
	def void checkComplexTypeExtensionChange(TStructureChangingRule r) {
		if (r.getExtendFrom !== null) {
			val container = r.eContainer
			if (container instanceof TComplexTypeTransposition) {
				if (container.baseImplClass != r.getExtendFrom.class) {
					error("New super type is not compatible with the subject of this rule", r,
						TransposePackage.Literals.TSTRUCTURE_CHANGING_RULE__EXTEND_FROM)
				}
			}
		}
	}

	@Check
	def void checkComplexTypeExtensionChange(TFuseRule r) {
		// TODO remove check after feature has been implemented
		if (! r.otherSources.empty) {
			error("Feature not implemented yet", r, TransposePackage.Literals.TFUSE_RULE__OTHER_SOURCES)
		}
	}

	@Check
	def void checkHasTransposedContainer(TFeatureTransposition f) {
		val container = f.eContainer
		if (!(container instanceof TComplexTypeTransposition || container instanceof TAggregateTransposition)) {
			error("Features can only have a transposition rule if the containing type or aggregate also has a transposition rule.", f.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def checkCorrespondingDAttributeType(TAttributeTransposition a) {
		if (a.rule.source !== null && ! (a.rule.source instanceof DAttribute)) {
			error("Transposed attribute rule must have a domain-model attribute as its source", a.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def checkCorrespondingDQueryType(TQueryTransposition q) {
		if (q.rule.source !== null && ! (q.rule.source instanceof DQuery)) {
			error("Transposed query rule must have a domain-model query as its source", q.rule, TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def checkCorrespondingDAssociationType(TAssociationTransposition a) {
		if (a.rule.source !== null && ! (a.rule.source instanceof DAssociation)) {
			error("Transposed association rule must have a domain-model association as its source", a.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	def void checkHasTransposedEnumeration(TLiteralTransposition literal) {
		val container = literal.eContainer
		if (! (container instanceof TEnumerationTransposition)) {
			error("Literals can only have a transposition rule if the containing enumeration also has a transposition rule.", literal.rule,
				TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE)
		}
	}

	@Check
	override checkEnumerationHasLiterals(DEnumeration e) {
		if (e instanceof ITransposition) {
			return
		}
		super.checkEnumerationHasLiterals(e)
	}

	override protected allTypes(DAggregate a) {
		if (a instanceof TAggregateTransposition) {
			val types = Lists.newArrayList
			types.addAll(a.types.filter[! (it instanceof ITransposition)])
			types.addAll(a.syntheticTypes)
			return types
		}
		return super.allTypes(a)
	}

	override checkFeatureTypeIsSet(DFeature f) {
		if (! (f instanceof ITransposition || f instanceof ISyntheticElement)) {
			super.checkFeatureTypeIsSet(f)
		}
	}

	@Check
	override checkAttributeIsValueType(DAttribute a) {
		if (a instanceof ITransposition) {
			return
		}
		if (! (a instanceof ISyntheticElement) && ! (a.getType instanceof IValueType)) {
			super.checkAttributeIsValueType(a)
		} else if (a instanceof ISyntheticElement) {
			if (a.type === null) {
				val recipe = a.recipe
				val source = recipe?.rule?.source as DAttribute
				val sourceType = source?.type
				errorOnStructuralElement(a,	getDescription(a) + ": " + noTypeMappingForDomainType(sourceType))
			} else if (! (a.getType instanceof IValueType)) {
				errorOnStructuralElement(a, getDescription(a) + ": attribute type must be a ValueType")
			}
		}
	}

	@Check
	override checkAssocitionToEntityType(DAssociation a) {
		if (a instanceof ITransposition) {
			return
		}
//		if (! a.synthetic && (! (a.getType instanceof DEntityType && (a.getType as DEntityType).root)))  {
//			super.checkAssocitionToRootType(a)
//		} else
		if (a instanceof ISyntheticElement) {
			if (a.type === null) {
				val recipe = a.recipe
				val source = recipe?.rule?.source as DAssociation
				val sourceType = source?.type
				errorOnStructuralElement(a,	getDescription(a) + ": " + noTypeMappingForDomainType(sourceType))
			} else if (! (a.getType instanceof IIdentityType)) {
				errorOnStructuralElement(a, getDescription(a) + ": association target must be an IdentityType")
			}
		}
	}

	override checkMemberType(DNavigableMember m) {
		if (m instanceof ITransposition) {
			return
		}
		if (m instanceof ISyntheticElement) {
			if (m.getType === null) {
				val source = m.recipe?.rule?.source
				var sourceType = source instanceof DNavigableMember ? source?.type : null
				errorOnStructuralElement(m, getDescription(m) + ": " + noTypeMappingForDomainType(sourceType))
			} else if (! m.isAllowedMemberType) {
				errorOnStructuralElement(m, getDescription(m) + ": " + ILLEGAL_MEMBER_TYPE_MSG)
			}
		} else {
			super.checkMemberType(m)
		}
	}

	/*
	 * Naming: Elements whose names should start with a CAPITAL
	 */
//	@Check
//	def void checkTypeNameStartsWithCapital(SInformationModel m) {
//		if (DEFAULT_IMPORT_TYPES == dm.name || DEFAULT_IMPORT_FUNCTIONS == m.name) {
//			return
//		}
//		checkNameStartsWithCapital(d)
//	}
	/* 
	 * Naming: Elements whose names should start with a LOWERCASE
	 * Naming: Elements whose names should be ALL UPPERCASE
	 */
	/*
	 * Warnings and Errors
	 */
	protected def String getDescription(EObject obj) {
		obj.simpleClassName + " " + transposedQualifiedNameProvider.getFullyQualifiedName(obj)
	}
	
	protected def String noTypeMappingForDomainType(DType sourceType) {
		val qualifiedName = dimQualifiedNameProvider.getFullyQualifiedName(sourceType)
		val name = qualifiedName !== null ? " " + qualifiedName.toString : ""
		return "no type mapping for domain type" + name + " --> check local imports and 'grab' clauses)"
	}

	protected def void warningOnStructuralElement(EObject e, String warningMsg) {
		if (e instanceof ISyntheticElement) {
			var recipe = e.recipe
			if (recipe instanceof TImplicitTransposition) {
				while (recipe instanceof TImplicitTransposition) {
					recipe = recipe.originalTransposition
				}
				warningOnStructuralElementImpl(recipe, warningMsg)
			} else {
				val container = e.eContainer
				if (container instanceof ITransposableElement) {
					warningOnStructuralElement(container, warningMsg) // recursion
				} else {
					warningOnStructuralElementImpl(container, warningMsg)
				}
			}

		} else if (e instanceof ITransposition) {
			warning(warningMsg, e, TransposePackage.Literals.ITRANSPOSITION__RULE)
		} else {
			warningOnStructuralElementImpl(e, warningMsg)
		}
	}

	protected def void warningOnStructuralElementImpl(EObject obj, String warningMsg) {
		if (obj instanceof DNamedElement) {
			warning(warningMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		} else {
			warning(warningMsg, obj, null)
		}
	}

	protected def void errorOnStructuralElement(EObject e, String errorMsg) {
		if (e instanceof ISyntheticElement) {
			var recipe = e.recipe
			if (recipe instanceof TImplicitTransposition) {
				while (recipe instanceof TImplicitTransposition) {
					recipe = recipe.originalTransposition
				}
				errorOnStructuralElementImpl(recipe, errorMsg)
			} else {
				val container = e.eContainer
				if (container instanceof ITransposableElement) {
					errorOnStructuralElement(container, errorMsg) // recursion
				} else {
					errorOnStructuralElementImpl(container, errorMsg)
				}
			}

		} else if (e instanceof ITransposition) {
			error(errorMsg, e, TransposePackage.Literals.ITRANSPOSITION__RULE)

		} else {
			errorOnStructuralElementImpl(e, errorMsg)
		}
	}

	protected def void errorOnStructuralElementImpl(EObject obj, String errorMsg) {
		if (obj instanceof DNamedElement) {
			error(errorMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		} else {
			error(errorMsg, obj, null)
		}
	}
}
