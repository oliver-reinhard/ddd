/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.dm.dms.validation

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DActor
import com.mimacom.ddd.dm.base.DAggregate
import com.mimacom.ddd.dm.base.DAssociation
import com.mimacom.ddd.dm.base.DAttribute
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DCondition
import com.mimacom.ddd.dm.base.DContext
import com.mimacom.ddd.dm.base.DDomain
import com.mimacom.ddd.dm.base.DDomainEvent
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DException
import com.mimacom.ddd.dm.base.DExistingApplication
import com.mimacom.ddd.dm.base.DFeature
import com.mimacom.ddd.dm.base.DIdentityType
import com.mimacom.ddd.dm.base.DLiteral
import com.mimacom.ddd.dm.base.DMultiplicity
import com.mimacom.ddd.dm.base.DNamedElement
import com.mimacom.ddd.dm.base.DNotification
import com.mimacom.ddd.dm.base.DQueryParameter
import com.mimacom.ddd.dm.base.DRelationship
import com.mimacom.ddd.dm.base.DRootType
import com.mimacom.ddd.dm.base.DServiceParameter
import com.mimacom.ddd.dm.base.DTime
import com.mimacom.ddd.dm.base.DType
import com.mimacom.ddd.dm.base.IValueType
import com.mimacom.ddd.dm.dms.DmsUtil
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class DmsValidator extends AbstractDmsValidator {

	@Inject extension DmsUtil

	@Check
	def checkDomainDeclaresOnlyValueTypes(DDomain d) {
		for (vt : d.types) {
			if(! (vt instanceof IValueType)) {
				error('Declared type is not a value type', vt, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			} else if(vt instanceof DComplexType) {
				val ct = vt as DComplexType
				for (f : ct.features) {
					if(f instanceof DAssociation) {
						error('Declared feature cannot be an association', f, BasePackage.Literals.DNAMED_ELEMENT__NAME)
					}
				}
			}
		}
	}

	@Check
	def checkAggregateHasSingleRoot(DAggregate a) {
		val roots = new BasicEList<DIdentityType>
		for (t : a.types) {
			if(t instanceof DIdentityType) {
				roots.add(t)
			}
		}
		if(roots.size > 1) {
			for (t : roots) {
				error('Aggregate can only declare a single root or relationship', t, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
		}
//		if(roots.size == 0) {
//			warning('Aggregate does not declare a root or a relationship', a, BasePackage.Literals.DAGGREGATE)
//		}
	}

// Types: restrictions on features and supertypes
	@Check
	def checkCyclicTypeHierarchy(DComplexType t) {
		if(t.typeHierarchy.contains(t)) {
			error('Type is part of a supertype cycle', t, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		}
	}

	@Check
	def checkSupertype(DComplexType t) {
		if(t.superType !== null) {
			if(t.superType.eClass !== t.eClass) {
				error('Supertype is not compatible', t, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
			val domain = t.eContainer.eContainer
			if(t.superType.eContainer.eContainer !== domain) {
				error('Supertype must be in same domain', t, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
		}
	}

	@Check
	def checkNoFeatureOverrides(DComplexType t) {
		val inherited = t.inheritedFeatureNames
		for (f : t.features) {
			if(inherited.contains(f.name)) {
				error('Feature cannot override inherited feature with same name', f, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
		}
	}

	@Check
	def checkRelationshipHasTwoAssociations(DRelationship r) {
		var count = 0;
		for (i : 0 ..< r.features.size) {
			if(r.features.get(i) instanceof DAssociation) count++
		}
		if(count < 2) {
			error('A relationship must declare at least 2 associations', r, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		}
	}

	@Check
	def checkEnumerationHasLiterals(DEnumeration e) {
		if(e.literals.size == 0) {
			warning('Enumeration does not declare literals', e, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		}
	}

	@Check
	def checkAttributeIsValueType(DAttribute a) {
		if(! (a.type instanceof IValueType)) {
			error('Refererenced type is not a ValueType', a, BasePackage.Literals.DTYPED_MEMBER__TYPE)
		}
	}

	@Check
	def checkAssocitionToRootType(DAssociation a) {
		if(! (a.type instanceof DRootType)) {
			error('Refererenced type is not a RootType', a, BasePackage.Literals.DTYPED_MEMBER__TYPE)
		}
	}

	@Check
	def checkAssociationMultiplicities(DMultiplicity m) {
		if(m.maxOccurs == 0) {
			error('Maximum targets cannot be 0', m, BasePackage.Literals.DMULTIPLICITY__MAX_OCCURS)
		}
	}

// // Parameters: restrictions on their types
	@Check
	def checkParameterIsValueType(DQueryParameter p) {
		if(! (p.type instanceof IValueType)) {
			error('Refererenced type is not a ValueType', p, BasePackage.Literals.DTYPED_MEMBER__TYPE)
		}
	}

	@Check
	def checkParameterIsValueType(DServiceParameter p) {
		if(! (p.type instanceof IValueType)) {
			error('Refererenced type is not a ValueType', p, BasePackage.Literals.DTYPED_MEMBER__TYPE)
		}
	}

// // Actors
	@Check
	def checkTimeCannotBeNotified(DNotification n) {
		if(n.notified instanceof DTime) {
			error("Time cannot be notified", n, BasePackage.Literals.DNOTIFICATION__NOTIFIED)
		}
	}

	// // Naming: Elements whose names should start with a CAPITAL
	def void checkNameStartsWithCapital(DNamedElement ne) {
		val name = ne.name
		if(name !== null && name.length > 0 && !Character::isUpperCase(name.charAt(0))) {
			warning("Name should start with a capital", ne, BasePackage.Literals::DNAMED_ELEMENT__NAME)
		}
	}

	@Check
	def void checkTypeNameStartsWithCapital(DDomain d) {
		checkNameStartsWithCapital(d)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DType t) {
		checkNameStartsWithCapital(t)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DCondition c) {
		checkNameStartsWithCapital(c)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DActor a) {
		checkNameStartsWithCapital(a)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DExistingApplication ea) {
		checkNameStartsWithCapital(ea)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DException e) {
		checkNameStartsWithCapital(e)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DDomainEvent de) {
		checkNameStartsWithCapital(de)
	}

	@Check
	def void checkTypeNameStartsWithCapital(DNotification n) {
		checkNameStartsWithCapital(n)
	}

// // Naming: Elements whose names should start with a LOWERCASE
	def void checkNameStartsWithLowercase(DNamedElement ne) {
		val first = ne.getName().charAt(0)
		val char underscore = '_'
		if(!Character::isLowerCase(first) && first !== underscore) {
			warning("Name should start with a lowercase or underscore", BasePackage.Literals::DNAMED_ELEMENT__NAME)
		}
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DFeature f) {
		checkNameStartsWithLowercase(f)
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DQueryParameter p) {
		checkNameStartsWithLowercase(p)
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DServiceParameter p) {
		checkNameStartsWithLowercase(p)
	}

	@Check
	def void checkFeatureNameStartsWithLowercase(DContext c) {
		checkNameStartsWithLowercase(c)
	}

// // Naming: Elements whose names should be ALL UPPERCASE
	@Check def void checkLiteralIsUppercase(DLiteral literal) {
		if(! literal.name.equals(literal.name.toUpperCase)) {
			warning("Name should be all upercase", BasePackage.Literals::DNAMED_ELEMENT__NAME)
		}
	}
}
