/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.formatting2;

import com.google.common.base.Objects;
import com.google.inject.Inject;
import com.mimacom.ddd.sm.sim.SAggregate;
import com.mimacom.ddd.sm.sim.SComplexType;
import com.mimacom.ddd.sm.sim.SCondition;
import com.mimacom.ddd.sm.sim.SEnumeration;
import com.mimacom.ddd.sm.sim.SFeature;
import com.mimacom.ddd.sm.sim.SImport;
import com.mimacom.ddd.sm.sim.SInformationModel;
import com.mimacom.ddd.sm.sim.SLiteral;
import com.mimacom.ddd.sm.sim.SMorphRule;
import com.mimacom.ddd.sm.sim.SMultiplicity;
import com.mimacom.ddd.sm.sim.SType;
import com.mimacom.ddd.sm.sim.services.SimGrammarAccess;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.formatting2.AbstractFormatter2;
import org.eclipse.xtext.formatting2.IFormattableDocument;
import org.eclipse.xtext.formatting2.IHiddenRegionFormatter;
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;

@SuppressWarnings("all")
public class SimFormatter extends AbstractFormatter2 {
  @Inject
  @Extension
  private SimGrammarAccess _simGrammarAccess;
  
  protected void _format(final SInformationModel model, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.append(this.textRegionExtensions.regionFor(model).assignment(this._simGrammarAccess.getSInformationModelAccess().getNameAssignment_4()), _function);
    EList<SImport> _imports = model.getImports();
    for (final SImport i : _imports) {
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
        SImport _last = IterableExtensions.<SImport>last(model.getImports());
        boolean _equals = Objects.equal(i, _last);
        if (_equals) {
          it.setNewLines(2);
        } else {
          it.newLine();
        }
      };
      document.<SImport>append(i, _function_1);
    }
    final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.<SImport>append(IterableExtensions.<SImport>last(model.getImports()), _function_2);
    EList<SType> _types = model.getTypes();
    for (final SType type : _types) {
      document.<SType>format(type);
    }
    EList<SAggregate> _aggregates = model.getAggregates();
    for (final SAggregate aggregate : _aggregates) {
      document.<SAggregate>format(aggregate);
    }
  }
  
  protected void _format(final SImport imp, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    document.<SImport>append(imp, _function);
  }
  
  protected void _format(final SMorphRule sMorphRule, @Extension final IFormattableDocument document) {
    document.<SMultiplicity>format(sMorphRule.getRemultiplyTo());
  }
  
  protected void _format(final SAggregate aggregate, @Extension final IFormattableDocument document) {
    final ISemanticRegion open = this.textRegionExtensions.regionFor(aggregate).keyword(this._simGrammarAccess.getSAggregateAccess().getLeftCurlyBracketKeyword_2());
    final ISemanticRegion close = this.textRegionExtensions.regionFor(aggregate).keyword(this._simGrammarAccess.getSAggregateAccess().getRightCurlyBracketKeyword_4());
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.append(open, _function);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<ISemanticRegion, ISemanticRegion>interior(open, close, _function_1);
    EList<SType> _types = aggregate.getTypes();
    for (final SType type : _types) {
      document.<SType>format(type);
    }
  }
  
  protected void _format(final SEnumeration en, @Extension final IFormattableDocument document) {
    int _size = en.getLiterals().size();
    boolean _greaterThan = (_size > 3);
    if (_greaterThan) {
      final ISemanticRegion open = this.textRegionExtensions.regionFor(en).keyword(this._simGrammarAccess.getSEnumerationAccess().getLeftCurlyBracketKeyword_1());
      final ISemanticRegion close = this.textRegionExtensions.regionFor(en).keyword(this._simGrammarAccess.getSEnumerationAccess().getRightCurlyBracketKeyword_4());
      final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
        it.newLine();
      };
      document.append(open, _function);
      final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
        it.indent();
      };
      document.<ISemanticRegion, ISemanticRegion>interior(open, close, _function_1);
      EList<SLiteral> _literals = en.getLiterals();
      for (final SLiteral literal : _literals) {
        final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
          it.noSpace();
        };
        document.surround(this.textRegionExtensions.regionFor(literal).assignment(this._simGrammarAccess.getSLiteralAccess().getNameAssignment_2()), _function_2);
      }
      List<ISemanticRegion> _keywords = this.textRegionExtensions.regionFor(en).keywords(this._simGrammarAccess.getSEnumerationAccess().getCommaKeyword_2_1_0());
      for (final ISemanticRegion comma : _keywords) {
        final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it) -> {
          it.newLine();
        };
        document.append(comma, _function_3);
      }
      final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it) -> {
        it.newLine();
      };
      document.<SLiteral>append(IterableExtensions.<SLiteral>last(en.getLiterals()), _function_4);
    }
    final Procedure1<IHiddenRegionFormatter> _function_5 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.<SEnumeration>append(en, _function_5);
  }
  
  protected void _format(final SComplexType type, @Extension final IFormattableDocument document) {
    final ISemanticRegion open = this.textRegionExtensions.regionFor(type).keyword(this._simGrammarAccess.getSComplexTypeFeaturesAccess().getLeftCurlyBracketKeyword_0());
    final ISemanticRegion close = this.textRegionExtensions.regionFor(type).keyword(this._simGrammarAccess.getSComplexTypeFeaturesAccess().getRightCurlyBracketKeyword_2());
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.newLine();
    };
    document.append(open, _function);
    final Procedure1<IHiddenRegionFormatter> _function_1 = (IHiddenRegionFormatter it) -> {
      it.indent();
    };
    document.<ISemanticRegion, ISemanticRegion>interior(open, close, _function_1);
    final Procedure1<IHiddenRegionFormatter> _function_2 = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.append(close, _function_2);
    EList<SFeature> _features = type.getFeatures();
    for (final SFeature feature : _features) {
      final Procedure1<IHiddenRegionFormatter> _function_3 = (IHiddenRegionFormatter it) -> {
        it.newLine();
      };
      document.<SFeature>append(feature, _function_3);
    }
    EList<SCondition> _constraints = type.getConstraints();
    for (final SCondition constraint : _constraints) {
      final Procedure1<IHiddenRegionFormatter> _function_4 = (IHiddenRegionFormatter it) -> {
        it.newLine();
      };
      document.<SCondition>append(constraint, _function_4);
    }
  }
  
  protected void _format(final SType type, @Extension final IFormattableDocument document) {
    final Procedure1<IHiddenRegionFormatter> _function = (IHiddenRegionFormatter it) -> {
      it.setNewLines(2);
    };
    document.<SType>append(type, _function);
  }
  
  public void format(final Object en, final IFormattableDocument document) {
    if (en instanceof SEnumeration) {
      _format((SEnumeration)en, document);
      return;
    } else if (en instanceof SComplexType) {
      _format((SComplexType)en, document);
      return;
    } else if (en instanceof SMorphRule) {
      _format((SMorphRule)en, document);
      return;
    } else if (en instanceof SType) {
      _format((SType)en, document);
      return;
    } else if (en instanceof XtextResource) {
      _format((XtextResource)en, document);
      return;
    } else if (en instanceof SAggregate) {
      _format((SAggregate)en, document);
      return;
    } else if (en instanceof SImport) {
      _format((SImport)en, document);
      return;
    } else if (en instanceof SInformationModel) {
      _format((SInformationModel)en, document);
      return;
    } else if (en instanceof EObject) {
      _format((EObject)en, document);
      return;
    } else if (en == null) {
      _format((Void)null, document);
      return;
    } else if (en != null) {
      _format(en, document);
      return;
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(en, document).toString());
    }
  }
}
