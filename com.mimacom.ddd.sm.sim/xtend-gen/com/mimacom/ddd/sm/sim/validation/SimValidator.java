/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Lists;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.base.BasePackage;
import com.mimacom.ddd.dm.base.base.DAggregate;
import com.mimacom.ddd.dm.base.base.DAssociation;
import com.mimacom.ddd.dm.base.base.DAttribute;
import com.mimacom.ddd.dm.base.base.DComplexType;
import com.mimacom.ddd.dm.base.base.DDetailType;
import com.mimacom.ddd.dm.base.base.DEntityType;
import com.mimacom.ddd.dm.base.base.DEnumeration;
import com.mimacom.ddd.dm.base.base.DFeature;
import com.mimacom.ddd.dm.base.base.DNamedElement;
import com.mimacom.ddd.dm.base.base.DNavigableMember;
import com.mimacom.ddd.dm.base.base.DQuery;
import com.mimacom.ddd.dm.base.base.DType;
import com.mimacom.ddd.dm.base.base.IIdentityType;
import com.mimacom.ddd.dm.base.base.IValueType;
import com.mimacom.ddd.dm.base.transpose.ISyntheticElement;
import com.mimacom.ddd.dm.base.transpose.ITransposableElement;
import com.mimacom.ddd.dm.base.transpose.ITransposition;
import com.mimacom.ddd.dm.base.transpose.TAggregateTransposition;
import com.mimacom.ddd.dm.base.transpose.TAssociationTransposition;
import com.mimacom.ddd.dm.base.transpose.TAttributeTransposition;
import com.mimacom.ddd.dm.base.transpose.TComplexTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TDetailTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TDitchRule;
import com.mimacom.ddd.dm.base.transpose.TEntityTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TEnumerationTransposition;
import com.mimacom.ddd.dm.base.transpose.TFeatureTransposition;
import com.mimacom.ddd.dm.base.transpose.TFuseRule;
import com.mimacom.ddd.dm.base.transpose.TGrabRule;
import com.mimacom.ddd.dm.base.transpose.TImplicitTransposition;
import com.mimacom.ddd.dm.base.transpose.TLiteralTransposition;
import com.mimacom.ddd.dm.base.transpose.TQueryTransposition;
import com.mimacom.ddd.dm.base.transpose.TStructureChangingRule;
import com.mimacom.ddd.dm.base.transpose.TTranspositionRule;
import com.mimacom.ddd.dm.base.transpose.TTristate;
import com.mimacom.ddd.dm.base.transpose.TTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TransposePackage;
import com.mimacom.ddd.dm.dim.validation.DimValidator;
import com.mimacom.ddd.sm.sim.SimUtil;
import com.mimacom.ddd.sm.sim.validation.AbstractSimValidator;
import java.util.ArrayList;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.naming.IQualifiedNameProvider;
import org.eclipse.xtext.naming.QualifiedName;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class SimValidator extends AbstractSimValidator {
  @Inject
  @Extension
  private SimUtil _simUtil;
  
  @Inject
  private IQualifiedNameProvider qualifiedNameProvider;
  
  @Check
  @Override
  public void checkAggregateHasSingleRootOrRootHiearchy(final DAggregate a) {
    final Function1<DEntityType, Boolean> _function = (DEntityType it) -> {
      return Boolean.valueOf(((!(it instanceof TEntityTypeTransposition)) && it.isRoot()));
    };
    final Iterable<DEntityType> roots = IterableExtensions.<DEntityType>filter(Iterables.<DEntityType>filter(a.getTypes(), DEntityType.class), _function);
    final Function1<DEntityType, Boolean> _function_1 = (DEntityType it) -> {
      DAggregate _aggregate = this._simUtil.aggregate(it.getSuperType());
      return Boolean.valueOf((!Objects.equal(_aggregate, a)));
    };
    final Iterable<DEntityType> topLevelRoots = IterableExtensions.<DEntityType>filter(roots, _function_1);
    int _size = IterableExtensions.size(topLevelRoots);
    boolean _greaterThan = (_size > 1);
    if (_greaterThan) {
      for (final DEntityType r : roots) {
        this.error("Aggregate can only declare a single root or relationship or a single hierarchy thereof", r, 
          BasePackage.Literals.DNAMED_ELEMENT__NAME);
      }
    }
  }
  
  @Check
  public void checkCorrespondingAggregateType(final TAggregateTransposition a) {
    if (((a.getRule().getSource() != null) && (!(a.getRule().getSource() instanceof DAggregate)))) {
      this.error("Deduced-aggregate rule must have a domain-model Aggregate as its source", a.getRule(), 
        TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkCorrespondingDEntityType(final TEntityTypeTransposition t) {
    final ITransposableElement source = t.getRule().getSource();
    if ((source instanceof DEntityType)) {
      boolean _isRoot = ((DEntityType)source).isRoot();
      boolean _isRoot_1 = t.isRoot();
      boolean _tripleNotEquals = (Boolean.valueOf(_isRoot) != Boolean.valueOf(_isRoot_1));
      if (_tripleNotEquals) {
        this.error("Deduced-entity rule must match domain-model root property", t.getRule(), 
          TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
      }
    } else {
      if ((source != null)) {
        this.error("Deduced-entity rule must have a domain-model entity as its source", t.getRule(), 
          TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
      }
    }
  }
  
  @Check
  public void checkCorrespondingDDetailType(final TDetailTypeTransposition t) {
    if (((t.getRule().getSource() != null) && (!(t.getRule().getSource() instanceof DDetailType)))) {
      this.error("Deduced-DetailType rule must have a domain-model DetailType as its source", t.getRule(), 
        TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkRootPropertyForDetailType(final TDetailTypeTransposition t) {
    final TTranspositionRule rule = t.getRule();
    if ((rule instanceof TStructureChangingRule)) {
      TTristate _rootEntity = ((TStructureChangingRule)rule).getRootEntity();
      final boolean setsRootProperty = (!Objects.equal(_rootEntity, TTristate.DONT_CARE));
      if (setsRootProperty) {
        this.warning("Setting the root property for DetailTypes does not have any effect.", rule, 
          TransposePackage.Literals.TSTRUCTURE_CHANGING_RULE__ROOT_ENTITY);
      }
    }
  }
  
  @Check
  public void checkDeducedFeaturesCombination(final TComplexTypeTransposition t) {
    TTranspositionRule _rule = t.getRule();
    if ((_rule instanceof TGrabRule)) {
      final Iterable<TFeatureTransposition> featureDeductionDefinitions = Iterables.<TFeatureTransposition>filter(((DComplexType) t).getFeatures(), TFeatureTransposition.class);
      final Function1<TFeatureTransposition, Boolean> _function = (TFeatureTransposition it) -> {
        TTranspositionRule _rule_1 = it.getRule();
        return Boolean.valueOf((_rule_1 instanceof TDitchRule));
      };
      final boolean hasDitchElements = IterableExtensions.<TFeatureTransposition>exists(featureDeductionDefinitions, _function);
      final Function1<TFeatureTransposition, Boolean> _function_1 = (TFeatureTransposition it) -> {
        TTranspositionRule _rule_1 = it.getRule();
        return Boolean.valueOf((_rule_1 instanceof TGrabRule));
      };
      final boolean hasGrabElements = IterableExtensions.<TFeatureTransposition>exists(featureDeductionDefinitions, _function_1);
      if ((hasDitchElements && hasGrabElements)) {
        this.error("Cannot use both grab rule and ditch rules together.", t.getRule(), 
          TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
      }
    }
  }
  
  @Check
  public void checkComplexTypeExtensionChange(final TStructureChangingRule r) {
    DType _extendFrom = r.getExtendFrom();
    boolean _tripleNotEquals = (_extendFrom != null);
    if (_tripleNotEquals) {
      final EObject container = r.eContainer();
      if ((container instanceof TComplexTypeTransposition)) {
        Class<? extends DType> _baseImplClass = this._simUtil.baseImplClass(((TTypeTransposition)container));
        Class<? extends DType> _class = r.getExtendFrom().getClass();
        boolean _notEquals = (!Objects.equal(_baseImplClass, _class));
        if (_notEquals) {
          this.error("New super type is not compatible with the subject of this rule", r, 
            TransposePackage.Literals.TSTRUCTURE_CHANGING_RULE__EXTEND_FROM);
        }
      }
    }
  }
  
  @Check
  public void checkComplexTypeExtensionChange(final TFuseRule r) {
    boolean _isEmpty = r.getOtherSources().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      this.error("Feature not implemented yet", r, TransposePackage.Literals.TFUSE_RULE__OTHER_SOURCES);
    }
  }
  
  @Check
  public void checkHasDeducedContainer(final TFeatureTransposition f) {
    final EObject container = f.eContainer();
    if ((!((container instanceof TComplexTypeTransposition) || (container instanceof TAggregateTransposition)))) {
      this.error(
        "Features can only have a deduction rule if the containing type or aggregate also has a deduction rule.", 
        f.getRule(), TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkCorrespondingDAttributeType(final TAttributeTransposition a) {
    if (((a.getRule().getSource() != null) && (!(a.getRule().getSource() instanceof DAttribute)))) {
      this.error("Deduced attribute rule must have a domain-model attribute as its source", a.getRule(), 
        TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkCorrespondingDQueryType(final TQueryTransposition q) {
    if (((q.getRule().getSource() != null) && (!(q.getRule().getSource() instanceof DQuery)))) {
      this.error("Deduced query rule must have a domain-model query as its source", q.getRule(), 
        TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkCorrespondingDAssociationType(final TAssociationTransposition a) {
    if (((a.getRule().getSource() != null) && (!(a.getRule().getSource() instanceof DAssociation)))) {
      this.error("Deduced association rule must have a domain-model association as its source", a.getRule(), 
        TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  public void checkHasDeducedEnumeration(final TLiteralTransposition literal) {
    final EObject container = literal.eContainer();
    if ((!(container instanceof TEnumerationTransposition))) {
      this.error("Literals can only have a deduction rule if the containing enumeration also has a deduction rule.", 
        literal.getRule(), TransposePackage.Literals.TTRANSPOSITION_RULE__SOURCE);
    }
  }
  
  @Check
  @Override
  public void checkEnumerationHasLiterals(final DEnumeration e) {
    if ((e instanceof ITransposition)) {
      return;
    }
    super.checkEnumerationHasLiterals(e);
  }
  
  @Override
  protected List<DType> allTypes(final DAggregate a) {
    if ((a instanceof TAggregateTransposition)) {
      final ArrayList<DType> types = Lists.<DType>newArrayList();
      final Function1<DType, Boolean> _function = (DType it) -> {
        return Boolean.valueOf((!(it instanceof ITransposition)));
      };
      Iterables.<DType>addAll(types, IterableExtensions.<DType>filter(((TAggregateTransposition)a).getTypes(), _function));
      types.addAll(this._simUtil.syntheticTypes(((TAggregateTransposition)a)));
      return types;
    }
    return super.allTypes(a);
  }
  
  @Override
  public void checkFeatureTypeIsSet(final DFeature f) {
    if ((!((f instanceof ITransposition) || (f instanceof ISyntheticElement)))) {
      super.checkFeatureTypeIsSet(f);
    }
  }
  
  @Check
  @Override
  public void checkAttributeIsValueType(final DAttribute a) {
    if ((a instanceof ITransposition)) {
      return;
    }
    if (((!(a instanceof ISyntheticElement)) && (!(a.getType() instanceof IValueType)))) {
      super.checkAttributeIsValueType(a);
    } else {
      if ((a instanceof ISyntheticElement)) {
        DType _type = a.getType();
        boolean _tripleEquals = (_type == null);
        if (_tripleEquals) {
          final ITransposition recipe = ((ISyntheticElement)a).getRecipe();
          TTranspositionRule _rule = null;
          if (recipe!=null) {
            _rule=recipe.getRule();
          }
          ITransposableElement _source = null;
          if (_rule!=null) {
            _source=_rule.getSource();
          }
          final DAttribute source = ((DAttribute) _source);
          DType _type_1 = null;
          if (source!=null) {
            _type_1=source.getType();
          }
          final DType sourceType = _type_1;
          String _description = this.getDescription(a);
          String _plus = (_description + ": no type mapping for domain type \'");
          String _name = null;
          if (sourceType!=null) {
            _name=sourceType.getName();
          }
          String _plus_1 = (_plus + _name);
          String _plus_2 = (_plus_1 + "\'");
          this.errorOnStructuralElement(a, _plus_2);
        } else {
          DType _type_2 = a.getType();
          boolean _not = (!(_type_2 instanceof IValueType));
          if (_not) {
            String _description_1 = this.getDescription(a);
            String _plus_3 = (_description_1 + ": attribute type must be a ValueType");
            this.errorOnStructuralElement(a, _plus_3);
          }
        }
      }
    }
  }
  
  @Check
  @Override
  public void checkAssocitionToEntityType(final DAssociation a) {
    if ((a instanceof ITransposition)) {
      return;
    }
    if ((a instanceof ISyntheticElement)) {
      DType _type = a.getType();
      boolean _tripleEquals = (_type == null);
      if (_tripleEquals) {
        final ITransposition recipe = ((ISyntheticElement)a).getRecipe();
        TTranspositionRule _rule = null;
        if (recipe!=null) {
          _rule=recipe.getRule();
        }
        ITransposableElement _source = null;
        if (_rule!=null) {
          _source=_rule.getSource();
        }
        final DAssociation source = ((DAssociation) _source);
        DType _type_1 = null;
        if (source!=null) {
          _type_1=source.getType();
        }
        final DType sourceType = _type_1;
        String _description = this.getDescription(a);
        String _plus = (_description + ": no type mapping for association-target domain type \'");
        String _name = null;
        if (sourceType!=null) {
          _name=sourceType.getName();
        }
        String _plus_1 = (_plus + _name);
        String _plus_2 = (_plus_1 + "\'");
        this.errorOnStructuralElement(a, _plus_2);
      } else {
        DType _type_2 = a.getType();
        boolean _not = (!(_type_2 instanceof IIdentityType));
        if (_not) {
          String _description_1 = this.getDescription(a);
          String _plus_3 = (_description_1 + ": association target must be an IdentityType");
          this.errorOnStructuralElement(a, _plus_3);
        }
      }
    }
  }
  
  @Override
  public void checkMemberType(final DNavigableMember p) {
    if ((p instanceof ITransposition)) {
      return;
    }
    if ((p instanceof ITransposableElement)) {
      if ((!(p instanceof ISyntheticElement))) {
        super.checkMemberType(p);
      } else {
        DType _type = p.getType();
        boolean _tripleEquals = (_type == null);
        if (_tripleEquals) {
          ITransposition _transposedBy = ((ITransposableElement)p).getTransposedBy();
          TTranspositionRule _rule = null;
          if (_transposedBy!=null) {
            _rule=_transposedBy.getRule();
          }
          ITransposableElement _source = null;
          if (_rule!=null) {
            _source=_rule.getSource();
          }
          final ITransposableElement source = _source;
          String sourceType = "";
          if ((source instanceof DNavigableMember)) {
            DType _type_1 = ((DNavigableMember)source).getType();
            boolean _tripleNotEquals = (_type_1 != null);
            if (_tripleNotEquals) {
              String _name = ((DNavigableMember)source).getType().getName();
              String _plus = (" \'" + _name);
              String _plus_1 = (_plus + "\'");
              sourceType = _plus_1;
            }
          }
          String _description = this.getDescription(p);
          String _plus_2 = (_description + ": no type mapping for domain type");
          String _plus_3 = (_plus_2 + sourceType);
          this.errorOnStructuralElement(p, _plus_3);
        } else {
          boolean _isAllowedMemberType = this.isAllowedMemberType(p);
          boolean _not = (!_isAllowedMemberType);
          if (_not) {
            String _description_1 = this.getDescription(p);
            String _plus_4 = (_description_1 + ": ");
            String _plus_5 = (_plus_4 + DimValidator.ILLEGAL_MEMBER_TYPE_MSG);
            this.errorOnStructuralElement(p, _plus_5);
          }
        }
      }
    }
  }
  
  protected String getDescription(final EObject obj) {
    String _xblockexpression = null;
    {
      String synthetic = "";
      if ((obj instanceof ITransposableElement)) {
        if ((obj instanceof ISyntheticElement)) {
          synthetic = "Synthetic ";
        }
      }
      String _simpleName = obj.getClass().getSimpleName();
      String _plus = (synthetic + _simpleName);
      String _plus_1 = (_plus + " ");
      QualifiedName _fullyQualifiedName = this.qualifiedNameProvider.getFullyQualifiedName(obj);
      _xblockexpression = (_plus_1 + _fullyQualifiedName);
    }
    return _xblockexpression;
  }
  
  protected void warningOnStructuralElement(final EObject e, final String warningMsg) {
    if ((e instanceof ITransposableElement)) {
      if ((e instanceof ISyntheticElement)) {
        ITransposition definition = ((ITransposableElement)e).getTransposedBy();
        if ((definition instanceof TImplicitTransposition)) {
          while ((definition instanceof TImplicitTransposition)) {
            definition = ((TImplicitTransposition)definition).getOriginalTransposition();
          }
          this.warningOnStructuralElementImpl(definition, warningMsg);
        } else {
          final EObject container = e.eContainer();
          if ((container instanceof ITransposableElement)) {
            this.warningOnStructuralElement(container, warningMsg);
          } else {
            this.warningOnStructuralElementImpl(container, warningMsg);
          }
        }
      } else {
        if ((e instanceof ITransposition)) {
          this.warning(warningMsg, e, TransposePackage.Literals.ITRANSPOSITION__RULE);
        } else {
          if ((!(e instanceof ISyntheticElement))) {
            this.warningOnStructuralElementImpl(e, warningMsg);
          }
        }
      }
    } else {
      this.warningOnStructuralElementImpl(e, warningMsg);
    }
  }
  
  protected void warningOnStructuralElementImpl(final EObject obj, final String warningMsg) {
    if ((obj instanceof DNamedElement)) {
      this.warning(warningMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME);
    } else {
      this.warning(warningMsg, obj, null);
    }
  }
  
  protected void errorOnStructuralElement(final EObject e, final String errorMsg) {
    if ((e instanceof ITransposableElement)) {
      if ((e instanceof ISyntheticElement)) {
        ITransposition definition = ((ITransposableElement)e).getTransposedBy();
        if ((definition instanceof TImplicitTransposition)) {
          while ((definition instanceof TImplicitTransposition)) {
            definition = ((TImplicitTransposition)definition).getOriginalTransposition();
          }
          this.errorOnStructuralElementImpl(definition, errorMsg);
        } else {
          final EObject container = e.eContainer();
          if ((container instanceof ITransposableElement)) {
            this.errorOnStructuralElement(container, errorMsg);
          } else {
            this.errorOnStructuralElementImpl(container, errorMsg);
          }
        }
      } else {
        if ((e instanceof ITransposition)) {
          this.error(errorMsg, e, TransposePackage.Literals.ITRANSPOSITION__RULE);
        } else {
          if ((!(e instanceof ISyntheticElement))) {
            this.errorOnStructuralElementImpl(e, errorMsg);
          }
        }
      }
    } else {
      this.errorOnStructuralElementImpl(e, errorMsg);
    }
  }
  
  protected void errorOnStructuralElementImpl(final EObject obj, final String errorMsg) {
    if ((obj instanceof DNamedElement)) {
      this.error(errorMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME);
    } else {
      this.error(errorMsg, obj, null);
    }
  }
}
