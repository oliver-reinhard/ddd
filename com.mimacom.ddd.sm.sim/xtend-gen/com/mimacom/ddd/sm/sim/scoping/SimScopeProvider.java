/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.BasePackage;
import com.mimacom.ddd.dm.base.DComplexType;
import com.mimacom.ddd.dm.base.DEnumeration;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DQuery;
import com.mimacom.ddd.sm.sim.SComplexType;
import com.mimacom.ddd.sm.sim.SDeductionRule;
import com.mimacom.ddd.sm.sim.SEnumeration;
import com.mimacom.ddd.sm.sim.SFeature;
import com.mimacom.ddd.sm.sim.SLiteral;
import com.mimacom.ddd.sm.sim.SQuery;
import com.mimacom.ddd.sm.sim.SQueryParameter;
import com.mimacom.ddd.sm.sim.SimPackage;
import com.mimacom.ddd.sm.sim.SimUtil;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.EcoreFactory;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider;
import org.eclipse.xtext.xbase.lib.Extension;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class SimScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
  @Inject
  @Extension
  private SimUtil _simUtil;
  
  private static final SimPackage epackage = SimPackage.eINSTANCE;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _xblockexpression = null;
    {
      EReference _sDeductionRule_Source = SimScopeProvider.epackage.getSDeductionRule_Source();
      boolean _equals = Objects.equal(reference, _sDeductionRule_Source);
      if (_equals) {
        final EObject container = context.eContainer();
        if ((context instanceof SLiteral)) {
          if ((container instanceof SEnumeration)) {
            SDeductionRule _deductionRule = ((SEnumeration)container).getDeductionRule();
            EObject _source = null;
            if (_deductionRule!=null) {
              _source=_deductionRule.getSource();
            }
            final EObject sourceType = _source;
            if ((sourceType instanceof DEnumeration)) {
              return Scopes.scopeFor(((DEnumeration)sourceType).getLiterals());
            }
          }
          return this.getDefaultScopeForType(context, BasePackage.eINSTANCE.getDLiteral());
        } else {
          if ((context instanceof SFeature)) {
            if ((container instanceof SComplexType)) {
              SDeductionRule _deductionRule_1 = ((SComplexType)container).getDeductionRule();
              EObject _source_1 = null;
              if (_deductionRule_1!=null) {
                _source_1=_deductionRule_1.getSource();
              }
              final EObject sourceType_1 = _source_1;
              if ((sourceType_1 instanceof DComplexType)) {
                final Class<? extends DFeature> requiredFeatureType = this._simUtil.baseClass(((SFeature)context));
                return this.getInheritedFeaturesScope(((DComplexType)sourceType_1), requiredFeatureType, IScope.NULLSCOPE);
              }
            }
            final EClass requiredFeatureType_1 = this._simUtil.baseEClass(((SFeature)context));
            return this.getDefaultScopeForType(context, requiredFeatureType_1);
          } else {
            if ((context instanceof SQueryParameter)) {
              if ((container instanceof SQuery)) {
                SDeductionRule _deductionRule_2 = ((SQuery)container).getDeductionRule();
                EObject _source_2 = null;
                if (_deductionRule_2!=null) {
                  _source_2=_deductionRule_2.getSource();
                }
                final EObject sourceType_2 = _source_2;
                if ((sourceType_2 instanceof DQuery)) {
                  return Scopes.scopeFor(((DQuery)sourceType_2).getParameters());
                }
              }
              return this.getDefaultScopeForType(context, BasePackage.eINSTANCE.getDQueryParameter());
            }
          }
        }
      }
      _xblockexpression = super.getScope(context, reference);
    }
    return _xblockexpression;
  }
  
  protected IScope getInheritedFeaturesScope(final DComplexType owner, final Class<? extends EObject> featureType, final IScope outerScope) {
    final Iterable<? extends EObject> features = Iterables.filter(owner.getFeatures(), featureType);
    DComplexType _superType = owner.getSuperType();
    boolean _tripleNotEquals = (_superType != null);
    if (_tripleNotEquals) {
      return Scopes.scopeFor(features, this.getInheritedFeaturesScope(owner.getSuperType(), featureType, outerScope));
    } else {
      return Scopes.scopeFor(features, outerScope);
    }
  }
  
  /**
   * Obtains the default scope for the given reference narrowed down to the given type.
   */
  public IScope getDefaultScopeForType(final EObject context, final EClass type) {
    final EReference reference = EcoreFactory.eINSTANCE.createEReference();
    reference.setEType(type);
    final IScope scope = super.getScope(context, reference);
    return scope;
  }
}
