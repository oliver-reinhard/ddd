/**
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.base.BasePackage;
import com.mimacom.ddd.dm.base.base.DAggregate;
import com.mimacom.ddd.dm.base.base.DComplexType;
import com.mimacom.ddd.dm.base.base.DEnumeration;
import com.mimacom.ddd.dm.base.base.DFeature;
import com.mimacom.ddd.dm.base.base.DQuery;
import com.mimacom.ddd.dm.base.base.DQueryParameter;
import com.mimacom.ddd.dm.base.base.DType;
import com.mimacom.ddd.dm.base.base.ITypeContainer;
import com.mimacom.ddd.dm.base.transpose.ITransposableElement;
import com.mimacom.ddd.dm.base.transpose.TAggregateTransposition;
import com.mimacom.ddd.dm.base.transpose.TComplexTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TDetailTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TEntityTypeTransposition;
import com.mimacom.ddd.dm.base.transpose.TEnumerationTransposition;
import com.mimacom.ddd.dm.base.transpose.TFeatureTransposition;
import com.mimacom.ddd.dm.base.transpose.TLiteralTransposition;
import com.mimacom.ddd.dm.base.transpose.TPrimitiveTransposition;
import com.mimacom.ddd.dm.base.transpose.TQueryParameterTransposition;
import com.mimacom.ddd.dm.base.transpose.TQueryTransposition;
import com.mimacom.ddd.dm.base.transpose.TTranspositionRule;
import com.mimacom.ddd.dm.base.transpose.TransposePackage;
import com.mimacom.ddd.sm.sim.SimUtil;
import com.mimacom.ddd.sm.sim.scoping.AbstractSimScopeProvider;
import java.util.List;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Extension;

@SuppressWarnings("all")
public class SimScopeProvider extends AbstractSimScopeProvider {
  @Inject
  @Extension
  private SimUtil _simUtil;
  
  private static final BasePackage BASE = BasePackage.eINSTANCE;
  
  private static final TransposePackage TRANSPOSE = TransposePackage.eINSTANCE;
  
  @Override
  public IScope getScope(final EObject context, final EReference reference) {
    IScope _xblockexpression = null;
    {
      EReference _tTranspositionRule_Source = SimScopeProvider.TRANSPOSE.getTTranspositionRule_Source();
      boolean _equals = Objects.equal(reference, _tTranspositionRule_Source);
      if (_equals) {
        EObject _xifexpression = null;
        if ((context instanceof TTranspositionRule)) {
          _xifexpression = ((TTranspositionRule)context).eContainer();
        } else {
          _xifexpression = context;
        }
        final EObject decduction = _xifexpression;
        final EObject container = decduction.eContainer();
        if ((decduction instanceof TAggregateTransposition)) {
          return this.getDefaultScopeOfType(decduction, SimScopeProvider.BASE.getDAggregate());
        } else {
          if ((decduction instanceof TPrimitiveTransposition)) {
            return this.getDefaultScopeOfType(decduction, SimScopeProvider.BASE.getDPrimitive());
          } else {
            if ((decduction instanceof TEntityTypeTransposition)) {
              return this.getDefaultScopeOfType(decduction, SimScopeProvider.BASE.getDEntityType());
            } else {
              if ((decduction instanceof TDetailTypeTransposition)) {
                return this.getDefaultScopeOfType(decduction, SimScopeProvider.BASE.getDDetailType());
              } else {
                if ((decduction instanceof TLiteralTransposition)) {
                  if ((container instanceof TEnumerationTransposition)) {
                    TTranspositionRule _rule = ((TEnumerationTransposition)container).getRule();
                    ITransposableElement _source = null;
                    if (_rule!=null) {
                      _source=_rule.getSource();
                    }
                    final ITransposableElement sourceType = _source;
                    if ((sourceType instanceof DEnumeration)) {
                      return Scopes.scopeFor(((DEnumeration)sourceType).getLiterals());
                    }
                  }
                  return IScope.NULLSCOPE;
                } else {
                  if ((decduction instanceof TFeatureTransposition)) {
                    if ((container instanceof TComplexTypeTransposition)) {
                      TTranspositionRule _rule_1 = ((TComplexTypeTransposition)container).getRule();
                      ITransposableElement _source_1 = null;
                      if (_rule_1!=null) {
                        _source_1=_rule_1.getSource();
                      }
                      final ITransposableElement sourceType_1 = _source_1;
                      if ((sourceType_1 instanceof DComplexType)) {
                        final Class<? extends DFeature> requiredFeatureType = this._simUtil.baseClass(((TFeatureTransposition)decduction));
                        return this.getInheritedFeaturesScope(((DComplexType)sourceType_1), requiredFeatureType, IScope.NULLSCOPE);
                      }
                    } else {
                      if ((container instanceof TAggregateTransposition)) {
                        TTranspositionRule _rule_2 = ((TAggregateTransposition)container).getRule();
                        ITransposableElement _source_2 = null;
                        if (_rule_2!=null) {
                          _source_2=_rule_2.getSource();
                        }
                        final ITransposableElement source = _source_2;
                        if ((source instanceof DAggregate)) {
                          return Scopes.scopeFor(Iterables.<DQuery>filter(((DAggregate)source).getFeatures(), DQuery.class));
                        }
                      }
                    }
                    return IScope.NULLSCOPE;
                  } else {
                    if ((decduction instanceof TQueryParameterTransposition)) {
                      if ((container instanceof TQueryTransposition)) {
                        TTranspositionRule _rule_3 = ((TQueryTransposition)container).getRule();
                        ITransposableElement _source_3 = null;
                        if (_rule_3!=null) {
                          _source_3=_rule_3.getSource();
                        }
                        final ITransposableElement source_1 = _source_3;
                        if ((source_1 instanceof DQuery)) {
                          return Scopes.scopeFor(((DQuery)source_1).getParameters());
                        }
                      }
                      return IScope.NULLSCOPE;
                    }
                  }
                }
              }
            }
          }
        }
      }
      _xblockexpression = super.getScope(context, reference);
    }
    return _xblockexpression;
  }
  
  @Override
  public IScope getDefaultScopeOfType(final EObject context, final EClass type) {
    if (((context instanceof DQuery) || (context instanceof DQueryParameter))) {
      final ITypeContainer container = EcoreUtil2.<ITypeContainer>getContainerOfType(context, ITypeContainer.class);
      if ((container instanceof TAggregateTransposition)) {
        final IScope outerScope = this.getDefaultScopeOfType(container, SimScopeProvider.BASE.getIValueType());
        final List<DType> syntheticTypes = this._simUtil.syntheticTypes(((TAggregateTransposition)container));
        boolean _isEmpty = syntheticTypes.isEmpty();
        boolean _not = (!_isEmpty);
        if (_not) {
          return Scopes.scopeFor(syntheticTypes, outerScope);
        }
        return outerScope;
      }
    }
    return super.getDefaultScopeOfType(context, type);
  }
  
  protected IScope getInheritedFeaturesScope(final DComplexType owner, final Class<? extends EObject> featureType, final IScope outerScope) {
    final Iterable<? extends EObject> features = Iterables.filter(owner.getFeatures(), featureType);
    DComplexType _superType = owner.getSuperType();
    boolean _tripleNotEquals = (_superType != null);
    if (_tripleNotEquals) {
      return Scopes.scopeFor(features, this.getInheritedFeaturesScope(owner.getSuperType(), featureType, outerScope));
    } else {
      return Scopes.scopeFor(features, outerScope);
    }
  }
}
