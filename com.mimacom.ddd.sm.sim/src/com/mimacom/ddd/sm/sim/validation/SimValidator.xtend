/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.validation

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DAggregate
import com.mimacom.ddd.dm.base.DAssociation
import com.mimacom.ddd.dm.base.DAttribute
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DDetailType
import com.mimacom.ddd.dm.base.DEntityType
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.dim.DimUtil
import com.mimacom.ddd.sm.sim.SAssociationDeduction
import com.mimacom.ddd.sm.sim.SAttributeDeduction
import com.mimacom.ddd.sm.sim.SComplexTypeDeduction
import com.mimacom.ddd.sm.sim.SDetailTypeDeduction
import com.mimacom.ddd.sm.sim.SDitchRule
import com.mimacom.ddd.sm.sim.SEntityTypeDeduction
import com.mimacom.ddd.sm.sim.SEnumerationDeduction
import com.mimacom.ddd.sm.sim.SFeatureDeduction
import com.mimacom.ddd.sm.sim.SFuseRule
import com.mimacom.ddd.sm.sim.SGrabRule
import com.mimacom.ddd.sm.sim.SLiteralDeduction
import com.mimacom.ddd.sm.sim.SQueryDeduction
import com.mimacom.ddd.sm.sim.SStructureChangingRule
import com.mimacom.ddd.sm.sim.STristate
import com.mimacom.ddd.sm.sim.SimPackage
import com.mimacom.ddd.sm.sim.SimUtil
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SimValidator extends AbstractSimValidator {

	@Inject extension DimUtil
	@Inject extension SimUtil
	
//	@Inject IQualifiedNameProvider qualifiedNameProvider

	@Check
	override checkAggregateHasSingleRootOrRootHiearchy(DAggregate a) {
		val roots = a.types.filter(DEntityType).filter[! (it instanceof SEntityTypeDeduction) && isRoot]
		// only one root hierarchy is allowed => top level is in same aggregate (superType == null) or in another aggregate
		val topLevelRoots =roots.filter[superType.aggregate != a]
		if(topLevelRoots.size > 1) {
			for (r: roots) {
				error('Aggregate can only declare a single root or relationship or a single hierarchy thereof', r, BasePackage.Literals.DNAMED_ELEMENT__NAME)
			}
		}
	}

// Types: restrictions on features and supertypes
	@Check
	def checkCorrespondingDEntityType(SEntityTypeDeduction t) {
			val source = t.deductionRule.source
			if (source instanceof DEntityType) {
				if (source.root !== t.root) {
					error("Deduced entity rule must match domain-model root property", t.deductionRule,
						BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
				}
			} else if (source !== null) {
			error("Deduced entity rule must have a domain-model entity as its source", t.deductionRule,
				BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}	
	}

	@Check
	def checkCorrespondingDDetailType(SDetailTypeDeduction t) {
			if(t.deductionRule.source !== null && ! (t.deductionRule.source instanceof DDetailType)) {
				error("Deduced DetailType rule must have a domain-model DetailType as its source", t.deductionRule,
					BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

	@Check
	def checkRootPropertyForDetailType(SDetailTypeDeduction t) {
			val rule = t.deductionRule
			if(rule  instanceof SStructureChangingRule) {
				val setsRootProperty = rule.rootEntity != STristate.DONT_CARE
				if(setsRootProperty) {
					warning("Setting the root property for DetailTypes does not have any effect.", rule,
						SimPackage.Literals.SSTRUCTURE_CHANGING_RULE__ROOT_ENTITY)
				}
			}
	}

	@Check
	def void checkDeducedFeaturesCombination(SComplexTypeDeduction t) {
			if(t.deductionRule instanceof SGrabRule) {
				val featureDeductionDefinitions = (t as DComplexType).features.filter(SFeatureDeduction)
				val hasDitchElements = featureDeductionDefinitions.exists[deductionRule instanceof SDitchRule]
				val hasGrabElements = featureDeductionDefinitions.exists[deductionRule instanceof SGrabRule]
				if(hasDitchElements && hasGrabElements) {
					error("Cannot use both grab rule and ditch rules together.", t.deductionRule,
						BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
				}
			}
	}
	
	@Check
	def void checkComplexTypeExtensionChange(SStructureChangingRule r) {
		if (r.extendFrom !== null) {
			val container = r.eContainer
			if (container instanceof SComplexTypeDeduction) {
				if (container.baseImplClass != r.extendFrom.class) {
					error("New super type is not compatible with the subject of this rule", r, SimPackage.Literals.SSTRUCTURE_CHANGING_RULE__EXTEND_FROM)
				}
			}
		}
	}
	
	@Check
	def void checkComplexTypeExtensionChange(SFuseRule r) {
		// TODO remove check after feature has been implemented
		if (! r.otherSources.empty) {
			error("Feature not implemented yet", r, SimPackage.Literals.SFUSE_RULE__OTHER_SOURCES)
		}
	}

	@Check
	def void checkHasDeducedContainer(SFeatureDeduction f) {
			val container = f.eContainer
			if(!(container instanceof SComplexTypeDeduction)) {
				error("Features can only have a deduction rule if the containing type also has a deduction rule.", f.deductionRule,
					BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

	@Check
	def checkCorrespondingDAttributeType(SAttributeDeduction a) {
			if(a.deductionRule.source !== null && ! (a.deductionRule.source instanceof DAttribute)) {
				error("Deduced attribute rule must have a domain-model attribute as its source", a.deductionRule,
					BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

	@Check
	def checkCorrespondingDQueryType(SQueryDeduction q) {
			if(q.deductionRule.source !== null && ! (q.deductionRule.source instanceof DQuery)) {
				error("Deduced query rule must have a domain-model attribute as its source", q.deductionRule,
					BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

	@Check
	def checkCorrespondingDAssociationType(SAssociationDeduction a) {
			if(a.deductionRule.source !== null && ! (a.deductionRule.source instanceof DAssociation)) {
				error("Deduced association rule must have a domain-model association as its source",
					BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

	@Check
	def void checkHasDeducedEnumeration(SLiteralDeduction literal) {
			val container = literal.eContainer
			if(! (container instanceof SEnumerationDeduction)) {
				error("Literals can only have a deduction rule if the containing enumeration also has a deduction rule.",
					literal.deductionRule, BasePackage.Literals.DDEDUCTION_RULE__SOURCE)
			}
	}

/*
	@Check
	def checkAttributeIsValueType(SAttributeDeduction a) {
		if(a.nature == GENUINE && ! (a.type instanceof IValueType)) {
			error('Referenced type is not a ValueType', a, SimPackage.Literals.SFEATURE__TYPE)
		} else if(a.nature == SYNTHETIC) {
			if(a.type === null) {
				errorOnStructuralElement(a,  getDescription(a) + ": no mapping rule for type")
			} else if(! (a.type instanceof SValueType)) {
				errorOnStructuralElement(a, getDescription(a) + ": referenced type is not a ValueType")
			}
		}
	}

	@Check
	def checkAssocitionToRootType(SAssociationDeduction a) {
		if (a.nature == GENUINE && (! (a.type instanceof SEntityTypeDeduction && (a.type as SEntityTypeDeduction).root)))  {
			error('Referenced type is not a RootType', a, SimPackage.Literals.SFEATURE__TYPE)
		} else if(a.nature == SYNTHETIC) {
			if(a.type === null) {
				errorOnStructuralElement(a,  getDescription(a) + ": no mapping rule for type")
			} else if(! (a.type instanceof SValueType)) {
				errorOnStructuralElement(a,  getDescription(a) + ": referenced type is not a RootType")
			}
		}
	}

// // Parameters: restrictions on their types
	@Check
	def checkParameterIsValueType(SQueryParameterDeduction p) {
		if(p.nature == GENUINE) {
			if(! (p.type instanceof SValueType || p.type == p.eContainer)) {
				error('Refererenced query-parameter type is neither a ValueType nor the query\'s own container', p,
					SimPackage.Literals.SQUERY_PARAMETER__TYPE)
			}
		} else if(p.nature == SYNTHETIC) {
			if(p.type === null) {
				errorOnStructuralElement(p,  getDescription(p) + ": no mapping rule for type")
			} else if(! (p.type instanceof SValueType || p.type == p.eContainer)) {
				errorOnStructuralElement(p, getDescription(p) + ": type is neither a ValueType nor the query\'s own container")
			}
		}
	}

	// // Naming: Elements whose names should start with a CAPITAL

//	@Check
//	def void checkTypeNameStartsWithCapital(SInformationModel m) {
//		if (DEFAULT_IMPORT_TYPES == dm.name || DEFAULT_IMPORT_FUNCTIONS == m.name) {
//			return
//		}
//		checkNameStartsWithCapital(d)
//	}

// // Naming: Elements whose names should start with a LOWERCASE


// // Naming: Elements whose names should be ALL UPPERCASE

// - only 1 SPrimitive can realize a given DPrimitive

	protected def String getDescription(EObject obj) {
		var synthetic = ""	
		if (obj instanceof IDeducibleElement) {
			if (obj.synthetic) synthetic = "Synthetic "
		}
		synthetic + obj.class.simpleName + " " + qualifiedNameProvider.getFullyQualifiedName(obj)
	}
	
	protected def void warningOnStructuralElement(EObject e, String warningMsg) {
		if(e instanceof IDeducibleElement) {
			if(e.synthetic) {
				val rule = e.deductionDefinition.deductionRule
				if(rule instanceof SSyntheticDeductionRule) {
					warningOnStructuralElementImpl(rule.elementWithRule, warningMsg)
				} else {
					val container = e.eContainer
					if(container instanceof IDeducibleElement) {
						warningOnStructuralElement(container, warningMsg) // recursion
					} else {
						warningOnStructuralElementImpl(container, warningMsg)
					}
				}

			} else if(e.nature == DEDUCTION_RULE) {
				warning(warningMsg, e, SimPackage.Literals.SDEDUCIBLE_ELEMENT__DEDUCTION_RULE)

			} else if(e.nature == GENUINE) {
				warningOnStructuralElementImpl(e, warningMsg)
			}
		} else {
			warningOnStructuralElementImpl(e, warningMsg)
		}
	}

	protected def void warningOnStructuralElementImpl(EObject obj, String warningMsg) {
		if(obj instanceof DNamedElement) {
			warning(warningMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		} else {
			warning(warningMsg, obj, null)
		}
	}

	protected def void errorOnStructuralElement(EObject e, String errorMsg) {
		if(e instanceof IDeducibleElement) {
			if(e.synthetic) {
				val rule = e.deductionDefinition.deductionRule
				if(rule instanceof SSyntheticDeductionRule) {
					errorOnStructuralElementImpl(rule.elementWithRule, errorMsg)
				} else {
					val container = e.eContainer
					if(container instanceof IDeducibleElement) {
						errorOnStructuralElement(container, errorMsg) // recursion
					} else {
						errorOnStructuralElementImpl(container, errorMsg)
					}
				}

			} else if(e.nature == DEDUCTION_RULE) {
				error(errorMsg, e, SimPackage.Literals.SDEDUCIBLE_ELEMENT__DEDUCTION_RULE)

			} else if(e.nature == GENUINE) {
				errorOnStructuralElementImpl(e, errorMsg)
			}
		} else {
			errorOnStructuralElementImpl(e, errorMsg)
		}
	}

	protected def void errorOnStructuralElementImpl(EObject obj, String errorMsg) {
		if(obj instanceof DNamedElement) {
			error(errorMsg, obj, BasePackage.Literals.DNAMED_ELEMENT__NAME)
		} else {
			error(errorMsg, obj, null)
		}
	}
	*/
}
