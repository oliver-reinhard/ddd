/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.generator

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.sm.sim.SDeducibleElement
import com.mimacom.ddd.sm.sim.SInformationModel
import java.io.CharArrayWriter
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.SaveOptions
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.serializer.ISerializer

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SimGenerator extends AbstractGenerator {

	@Inject ISerializer serializer;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		//
		// DEDUCED RESOURCES DO NOT CREATE EOBJECTDESCRIPTIONS => SERIALIZER CANNOT LINK !!!
		// 
//		val targetRS = new XtextResourceSet
//		EcoreUtil2.clone(targetRS, resource.resourceSet)
//		val resourceCopy = targetRS.getResource(resource.URI, false)
//		if (resourceCopy.removeTransformationItems) {
//			// if no synthetic members were present, then resource is already a generated file.
//			val writer = new CharArrayWriter(1000)
//			val  saveOptions = SaveOptions.getOptions(null)
//			serializer.serialize(resourceCopy.contents.head, writer, saveOptions)
//			fsa.generateFile("Deduced" + resource.URI.lastSegment.toFirstUpper, writer.toString)
//		}
	}
	
	def boolean removeTransformationItems(Resource resource) {
		var hadSyntheticItems = false
		val model = resource.contents.head
		if (model instanceof SInformationModel) {
			model.deduced = true
			val deducibles = resource.allContents.filter(SDeducibleElement)
			val elementsToRemove = Lists.newArrayList
			while (deducibles.hasNext) {
				val e = deducibles.next
				if (e.deductionRule !== null ) {
					elementsToRemove.add(e)
				} else {
					e.deductionRule = null
					hadSyntheticItems = hadSyntheticItems || (e.synthetic !== null && e.synthetic)
					e.unsetSynthetic
				}
			}
			for (e : elementsToRemove) {
				EcoreUtil.remove(e)
			}
		}
		return hadSyntheticItems
	}
}
