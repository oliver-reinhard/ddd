/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.generator

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.sm.sim.SDeducibleElement
import com.mimacom.ddd.sm.sim.SInformationModel
import java.io.CharArrayWriter
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.resource.SaveOptions
import org.eclipse.xtext.resource.XtextResourceSet
import org.eclipse.xtext.serializer.ISerializer

import static com.mimacom.ddd.sm.sim.SElementNature.*
import org.eclipse.xtext.resource.XtextResource

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SimGenerator extends AbstractGenerator {

	@Inject ISerializer serializer;
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val targetRS = new XtextResourceSet
		EcoreUtil2.clone(targetRS, resource.resourceSet)
		val resourceCopy = targetRS.getResource(resource.URI, true)
//		if (resourceCopy.removeTransformationItems) {
			// if no synthetic members were present, then resource is already a generated file.
			val model = resourceCopy.contents.head;
//			(resourceCopy as XtextResource).relink
			val writer = new CharArrayWriter(1000)
			val  saveOptions = SaveOptions.getOptions(null)
			serializer.serialize(model, writer, saveOptions)
			fsa.generateFile("Deduced" + resource.URI.lastSegment.toFirstUpper, writer.toString)
//		}
	}
	
	def boolean removeTransformationItems(Resource resource) {
		var hadSyntheticItems = false
		val model = resource.contents.head
		if (model instanceof SInformationModel) {
			model.deduced = true
			// change name space so index entries to avoid conflict with original Sim file:
			model.name = model.name + ".synthetic"
			val deducibles = resource.allContents.filter(SDeducibleElement)
			val elementsToRemove = Lists.newArrayList
			while (deducibles.hasNext) {
				val e = deducibles.next
				if (e.nature == DEDUCTION_RULE ) {
					elementsToRemove.add(e)
				} else {
					e.deductionRule = null
					hadSyntheticItems = hadSyntheticItems || (e.nature == SYNTHETIC)
					e.unsetSynthetic
				}
			}
			for (e : elementsToRemove) {
				EcoreUtil.remove(e)
			}
		}
		return hadSyntheticItems
	}
}
