/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.scoping

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.sm.sim.SComplexType
import com.mimacom.ddd.sm.sim.SEnumeration
import com.mimacom.ddd.sm.sim.SFeature
import com.mimacom.ddd.sm.sim.SLiteral
import com.mimacom.ddd.sm.sim.SQuery
import com.mimacom.ddd.sm.sim.SQueryParameter
import com.mimacom.ddd.sm.sim.SimPackage
import com.mimacom.ddd.sm.sim.SimUtil
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.EcoreFactory
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.ImportedNamespaceAwareLocalScopeProvider

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class SimScopeProvider extends ImportedNamespaceAwareLocalScopeProvider {
	
	@Inject extension SimUtil
	
	static val epackage = SimPackage.eINSTANCE
	
	override getScope(EObject context, EReference reference) {
		
		if (reference == epackage.SDeductionRule_Source) {
			val container = context.eContainer
			if (context instanceof SLiteral) {
				if (container instanceof 	SEnumeration) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DEnumeration) {
						return Scopes.scopeFor(sourceType.literals)
					}
				}
				return getDefaultScopeForType(context, BasePackage.eINSTANCE.DLiteral)
			} else if (context instanceof SFeature) {
				if (container instanceof 	SComplexType) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DComplexType) {
						val requiredFeatureType = context.baseClass
						return getInheritedFeaturesScope(sourceType, requiredFeatureType, IScope.NULLSCOPE)
					}
				}
				val requiredFeatureType = context.baseEClass
				return getDefaultScopeForType(context, requiredFeatureType)
			} else if (context instanceof SQueryParameter) {
				if (container instanceof 	SQuery) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DQuery) {
						return Scopes.scopeFor(sourceType.parameters)
					}
				}
				return getDefaultScopeForType(context, BasePackage.eINSTANCE.DQueryParameter)
			}
		}
		super.getScope(context, reference)
	}

	protected def IScope getInheritedFeaturesScope(DComplexType owner, Class<? extends EObject> featureType, IScope outerScope) {
		val features = owner.features.filter(featureType)
		if (owner.superType !== null) {
			return Scopes.scopeFor(features, getInheritedFeaturesScope(owner.superType, featureType, outerScope)) // recursion
		} else {
			return Scopes.scopeFor(features, outerScope)
		}
	}
	
	/*
	 * Obtains the default scope for the given reference narrowed down to the given type.
	 */
	def IScope getDefaultScopeForType(EObject context, EClass type) {
		val reference = EcoreFactory.eINSTANCE.createEReference
		// Default scoping only uses the EType field of the reference:
		reference.EType = type
		val scope = super.getScope(context, reference)
		return scope
	}
}
