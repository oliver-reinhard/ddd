/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.scoping

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DAggregate
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DDeductionRule
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.dm.base.DQueryParameter
import com.mimacom.ddd.dm.base.ITypeContainer
import com.mimacom.ddd.sm.sim.SAggregateDeduction
import com.mimacom.ddd.sm.sim.SComplexTypeDeduction
import com.mimacom.ddd.sm.sim.SDetailTypeDeduction
import com.mimacom.ddd.sm.sim.SEntityTypeDeduction
import com.mimacom.ddd.sm.sim.SEnumerationDeduction
import com.mimacom.ddd.sm.sim.SFeatureDeduction
import com.mimacom.ddd.sm.sim.SLiteralDeduction
import com.mimacom.ddd.sm.sim.SPrimitiveDeduction
import com.mimacom.ddd.sm.sim.SQueryDeduction
import com.mimacom.ddd.sm.sim.SQueryParameterDeduction
import com.mimacom.ddd.sm.sim.SimUtil
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

class SimScopeProvider extends AbstractSimScopeProvider {

	@Inject extension SimUtil

	static val BASE = BasePackage.eINSTANCE

	override getScope(EObject context, EReference reference) {

		if (reference == BASE.DDeductionRule_Source) {
			val decduction = context instanceof DDeductionRule ? context.eContainer : context
			val container = decduction.eContainer
			
			if (decduction instanceof SAggregateDeduction) {
				return getDefaultScopeOfType(decduction, BASE.DAggregate)

			} else if (decduction instanceof SPrimitiveDeduction) {
				return getDefaultScopeOfType(decduction, BASE.DPrimitive)

			} else if (decduction instanceof SEntityTypeDeduction) {
				return getDefaultScopeOfType(decduction, BASE.DEntityType)

			} else if (decduction instanceof SDetailTypeDeduction) {
				return getDefaultScopeOfType(decduction, BASE.DDetailType)

			} else if (decduction instanceof SLiteralDeduction) {
				if (container instanceof SEnumerationDeduction) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DEnumeration) {
						return Scopes.scopeFor(sourceType.literals)
					}
				}
				return IScope.NULLSCOPE

			} else if (decduction instanceof SFeatureDeduction) {
				if (container instanceof SComplexTypeDeduction) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DComplexType) {
						val requiredFeatureType = decduction.baseClass
						return getInheritedFeaturesScope(sourceType, requiredFeatureType, IScope.NULLSCOPE)
					}
				} else if (container instanceof SAggregateDeduction) {
					val source = container.deductionRule?.source
					if (source instanceof DAggregate) {
						return Scopes.scopeFor(source.features.filter(DQuery))
					}
				}
				return IScope.NULLSCOPE

			} else if (decduction instanceof SQueryParameterDeduction) {
				if (container instanceof SQueryDeduction) {
					val source = container.deductionRule?.source
					if (source instanceof DQuery) {
						return Scopes.scopeFor(source.parameters)
					}
				}
				return IScope.NULLSCOPE
			}
		}
		super.getScope(context, reference)
	}

	override getDefaultScopeOfType(EObject context, EClass type) {
		if (context instanceof DQuery || context instanceof DQueryParameter) {
			val container = EcoreUtil2.getContainerOfType(context, ITypeContainer)
			if (container instanceof SAggregateDeduction) {
				val outerScope = getDefaultScopeOfType(container, BASE.IValueType)
				val syntheticTypes = container.syntheticTypes
				if (! syntheticTypes.empty) {
					return Scopes.scopeFor(syntheticTypes, outerScope)
				}
				return outerScope
			}
		}
		return super.getDefaultScopeOfType(context, type)
	}

	protected def IScope getInheritedFeaturesScope(DComplexType owner, Class<? extends EObject> featureType,
		IScope outerScope) {
		val features = owner.features.filter(featureType)
		if (owner.superType !== null) {
			return Scopes.scopeFor(features, getInheritedFeaturesScope(owner.superType, featureType, outerScope)) // recursion
		} else {
			return Scopes.scopeFor(features, outerScope)
		}
	}
}
