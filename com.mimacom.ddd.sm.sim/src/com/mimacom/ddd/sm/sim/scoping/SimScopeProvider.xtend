/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.scoping

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DComplexType
import com.mimacom.ddd.dm.base.DEnumeration
import com.mimacom.ddd.dm.base.DQuery
import com.mimacom.ddd.sm.sim.SComplexTypeDeduction
import com.mimacom.ddd.sm.sim.SCoreQuery
import com.mimacom.ddd.sm.sim.SEnumerationDeduction
import com.mimacom.ddd.sm.sim.SFeatureDeduction
import com.mimacom.ddd.sm.sim.SLiteralDeduction
import com.mimacom.ddd.sm.sim.SQueryDeduction
import com.mimacom.ddd.sm.sim.SQueryParameterDeduction
import com.mimacom.ddd.sm.sim.SimUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes

/**
 * Timport com.mimacom.ddd.sm.sim.SFeatureDeduction

is class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class SimScopeProvider extends AbstractSimScopeProvider {
	
	@Inject extension SimUtil
	
	static val epackage = BasePackage.eINSTANCE
	
	override getScope(EObject context, EReference reference) {
		
		if (reference == epackage.DNavigableMember_Type) {
			
			 val IScope scope = switch context {	
				SCoreQuery: getDefaultScopeForType(context, epackage.DType)
				default:  getDefaultScopeForType(context, epackage.IValueType)
			}
			return scope
		}
		
		if (reference == epackage.DDeductionRule_Source) {
			val container = context.eContainer
			if (context instanceof SLiteralDeduction) {
				if (container instanceof 	SEnumerationDeduction) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DEnumeration) {
						return Scopes.scopeFor(sourceType.literals)
					}
				}
				return getDefaultScopeForType(context, BasePackage.eINSTANCE.DLiteral)
			} else if (context instanceof SFeatureDeduction) {
				if (container instanceof 	SComplexTypeDeduction) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DComplexType) {
						val requiredFeatureType = context.baseClass
						return getInheritedFeaturesScope(sourceType, requiredFeatureType, IScope.NULLSCOPE)
					}
				}
				val requiredFeatureType = context.baseEClass
				return getDefaultScopeForType(context, requiredFeatureType)
			} else if (context instanceof SQueryParameterDeduction) {
				if (container instanceof 	SQueryDeduction) {
					val sourceType = container.deductionRule?.source
					if (sourceType instanceof DQuery) {
						return Scopes.scopeFor(sourceType.parameters)
					}
				}
				return getDefaultScopeForType(context, BasePackage.eINSTANCE.DQueryParameter)
			}
		}
		super.getScope(context, reference)
	}

	protected def IScope getInheritedFeaturesScope(DComplexType owner, Class<? extends EObject> featureType, IScope outerScope) {
		val features = owner.features.filter(featureType)
		if (owner.superType !== null) {
			return Scopes.scopeFor(features, getInheritedFeaturesScope(owner.superType, featureType, outerScope)) // recursion
		} else {
			return Scopes.scopeFor(features, outerScope)
		}
	}
}
