/*
 * generated by Xtext 2.16.0
 */
package com.mimacom.ddd.sm.sim.formatting2

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.DComplexType
import com.mimacom.ddd.dm.base.base.DImport
import com.mimacom.ddd.dm.base.transpose.TAggregateTransposition
import com.mimacom.ddd.dm.base.transpose.TComplexTypeTransposition
import com.mimacom.ddd.dm.base.transpose.TEnumerationTransposition
import com.mimacom.ddd.dm.base.transpose.TMorphRule
import com.mimacom.ddd.dm.base.transpose.TTypeTransposition
import com.mimacom.ddd.sm.sim.SInformationModel
import com.mimacom.ddd.sm.sim.services.SimGrammarAccess
import org.eclipse.xtext.formatting2.AbstractFormatter2
import org.eclipse.xtext.formatting2.IFormattableDocument

class SimFormatter extends AbstractFormatter2 {

	@Inject extension SimGrammarAccess

	def dispatch void format(SInformationModel model, extension IFormattableDocument document) {
		model.regionFor.assignment(SInformationModelAccess.nameAssignment_1).append[newLines = 2]

		for (type : model.types) {
			type.format
		}
		for (aggregate : model.aggregates) {
			aggregate.format
		}
	}

	def dispatch void format(DImport imp, extension IFormattableDocument document) {
		imp.append[newLine]
	}

	def dispatch void format(TMorphRule sMorphRule, extension IFormattableDocument document) {
		// TODO: format HiddenRegions around keywords, attributes, cross references, etc. 
		sMorphRule.getRemultiplyTo.format
	}

	def dispatch void format(TAggregateTransposition aggregate, extension IFormattableDocument document) {
		val open = aggregate.regionFor.keyword(simAggregateTranspositionAccess.leftCurlyBracketKeyword_5_0)
		val close = aggregate.regionFor.keyword(simAggregateTranspositionAccess.rightCurlyBracketKeyword_5_3)
		open.append[newLines = 2]
		interior(open, close)[indent]

		for (type : aggregate.types) {
			type.format
		}
	}

	def dispatch void format(TEnumerationTransposition en, extension IFormattableDocument document) {
		if (en.literals.size > 3) {
			val open = en.regionFor.keyword(simEnumerationTranspositionAccess.leftCurlyBracketKeyword_3_0)
			val close = en.regionFor.keyword(simEnumerationTranspositionAccess.rightCurlyBracketKeyword_3_3)
			open.append[newLine]
			interior(open, close)[indent]

			for (literal : en.literals) {
				literal.regionFor.assignment(simEnumerationTranspositionAccess.literalsAssignment_3_1_0).surround[noSpace]
			}
			for (comma : en.regionFor.keywords(simEnumerationTranspositionAccess.commaKeyword_3_1_1_0)) {
				comma.append[newLine]
			}
			en.literals.last.append[newLine]
		}
		en.append[newLines = 2]
	}

	def dispatch void format(TComplexTypeTransposition type, extension IFormattableDocument document) {
		val open = type.regionFor.keyword(TComplexTypeFeaturesAccess.leftCurlyBracketKeyword_0)
		val close = type.regionFor.keyword(TComplexTypeFeaturesAccess.rightCurlyBracketKeyword_2)
		open.append[newLine]
		interior(open, close)[indent]
		close.append[newLines = 2]

		val dType = type as DComplexType
		for (feature : dType.features) {
			feature.append[newLine]
		}

		for (constraint : dType.constraints) {
			constraint.append[newLine]
		}
	}

	def dispatch void format(TTypeTransposition type, extension IFormattableDocument document) {
		type.append[newLines = 2]
	}
}
