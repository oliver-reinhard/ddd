grammar com.mimacom.ddd.sm.sim.Sim with com.mimacom.ddd.dm.dim.Dim

import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.mimacom.com/ddd/sm/sim"

SInformationModel:
	(imports+=DImport)*
	kind=SInformationModelKind 'information' 'model'
	name=DQualifiedName
	 (^generate?='generate')?
	(description=DRichText)?
	(queries+=SCoreQuery)*
	(types+=Type | aggregates+=Aggregate | domainProxies+=Domain)*;

enum SInformationModelKind:
	BASE='base' | INTERFACE='interface' | CORE='core';

/*
 * RULEs
 */

SGrabDomainRule:
	source=[DDomain|DQualifiedName];
		
SGrabAggregateRule:
	source=[DAggregate|DQualifiedName];
	
SGrabPrimitiveRule returns SGrabRule:
	source=[DPrimitive|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchPrimitiveRule returns SDitchRule:
	source=[DPrimitive|DQualifiedName];
	
SGrabEnumerationRule returns SGrabRule:
	source=[DEnumeration|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchEnumerationRule returns SDitchRule:
	source=[DEnumeration|DQualifiedName];

SGrabEnumerationLiteralRule returns SGrabRule:
	source=[DLiteral|ID]
	('as' renameTo=ID)?;
	
SDitchEnumerationLiteralRule returns SDitchRule:
	source=[DLiteral|ID];
	
SGrabComplexTypeRule returns SGrabRule:
	source=[DComplexType|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchComplexTypeRule returns SDitchRule:
	source=[DComplexType|DQualifiedName];
	
SMorphComplexTypeRule returns SMorphRule:
	source=[DComplexType|DQualifiedName]
	ChangeComplexType;
	
SFuseComplexTypeRule returns SFuseRule:
	source=[DComplexType|DQualifiedName]
	('and' otherSources+=[DComplexType|DQualifiedName])+
	ChangeComplexType;

fragment ChangeComplexType returns SStructureChangingRule:
	(	'to' 
		(abstract=SAbstractType)?
		(rootEntity=SRootEntity | detail=SDetailType)?
		(renameTo=ID)?
		('extends' extendFrom=[DComplexType|ID])?
	)?;

SGrabFeatureRule returns SGrabRule:
	source=[DFeature|ID]
	('as' renameTo=ID)?;
	
SMorphFeatureRule returns SMorphRule:
	source=[DFeature|ID]
	'to'
	(renameTo=ID ':')? 
	retypeTo=[DType|ID] (remultiplyTo=DMultiplicity)?;	

SDitchFeatureRule returns SDitchRule:
	source=[DFeature|ID];

enum SAbstractType returns STristate:
	FALSE='nonabstract' | TRUE='abstract';
	
enum SRootEntity returns STristate:
	FALSE='nonroot' | TRUE='root';
	
enum SDetailType returns STristate:
	FALSE='entity' | TRUE='detail';
	
Domain returns SDomainDeduction:
	{SDomainDeduction}
	'grab' 'domain' deductionRule=SGrabDomainRule;

Aggregate returns DAggregate:
	SAggregateDeduction | DAggregate;

SAggregateDeduction:
	{SAggregateDeduction}
	'grab' 'aggregate' deductionRule=SGrabAggregateRule
	(description=DRichText)?
	'{'
		( types+=Type)*
	'}';
		
@Override 
DAggregate:
	{DAggregate}
	'aggregate'
	(description=DRichText)?
	'{'
		( types+=Type)*
	'}';

/*
 * TYPES
 */
Type returns DType:
	SPrimitiveDeduction | DPrimitive
	| SEnumerationDeduction | DEnumeration
	| SEntityTypeDeduction | DEntityType
	| SDetailTypeDeduction | DDetailType;

SPrimitiveDeduction:
	{SPrimitiveDeduction}
	(	'grab' 'primitive' deductionRule=SGrabPrimitiveRule
	|	'ditch' 'primitive' deductionRule=SDitchPrimitiveRule
	)
	(description=DRichText)?
	'{'
		(constraints+=DConstraint)*
	'}';
	
SEnumerationDeduction:
	{SEnumerationDeduction} 
	(	'grab' 'enumeration' deductionRule=SGrabEnumerationRule
	|	'ditch' 'enumeration' deductionRule=SDitchEnumerationRule
	)
	(description=DRichText)?
	'{'
	 	(literals+=Literal (',' literals+=Literal)*)?
		(constraints+=DConstraint)*
	 '}';
	 
@Override 
DEnumeration:
	'enumeration'
	name=ID
	('alias' aliases+=ID)*
	(description=DRichText)?
	'{'
	 	(literals+=Literal (',' literals+=Literal)*)?
		(constraints+=DConstraint)*
	 '}';
	 
Literal returns DLiteral:
	SLiteralDeduction | DLiteral;
	
SLiteralDeduction:
	{SLiteralDeduction}
	(	 'grab' deductionRule=SGrabEnumerationLiteralRule
	|	 'ditch' deductionRule=SDitchEnumerationLiteralRule
	)
	(description=DRichText)?;

SEntityTypeDeduction:
	{SEntityTypeDeduction}
	(	'grab'(root?='root')? 'entity' deductionRule=SGrabComplexTypeRule
	|	'ditch' (root?='root')? 'entity' deductionRule=SDitchComplexTypeRule
	|	'morph' (root?='root')? 'entity' deductionRule=SMorphComplexTypeRule
	|	'fuse'(root?='root')?  'entity' deductionRule=SFuseComplexTypeRule
	)
	(description=DRichText)?
	SComplexTypeFeatures;

SDetailTypeDeduction:
	{SDetailTypeDeduction} 
	(	'grab' 'detail' deductionRule=SGrabComplexTypeRule
	|	'ditch' 'detail' deductionRule=SDitchComplexTypeRule
	|	'morph' 'detail' deductionRule=SMorphComplexTypeRule
	|	'fuse' 'detail' deductionRule=SFuseComplexTypeRule
	)
	(description=DRichText)?
	SComplexTypeFeatures;

fragment SComplexTypeFeatures returns DComplexType:
	'{'
		(features+=Feature | constraints+=DConstraint)*
	'}';

@Override 
DEntityType:
	(abstract?='abstract')?
	(root?='root')?
	'entity'
	DComplexType;
		
@Override 
fragment DComplexType:
	name=ID
	('alias' aliases+=ID)*
	('extends' superType=[DComplexType|ID])?
	(description=DRichText)?
	'{'
		(features+=Feature | constraints+=DConstraint)*
	'}';
	
/*
 * FEATURES
 */	
Feature returns DFeature:
	SAssociationDeduction | DAssociation
	| SAttributeDeduction | DAttribute
	| SQueryDeduction | DQuery;

SAssociationDeduction:
	{SAssociationDeduction} 
	(	'grab' ('reference' | 'composite') deductionRule=SGrabFeatureRule
	|	'morph' ('reference' | 'composite')deductionRule=SMorphFeatureRule
	|	'ditch' ('reference' | 'composite') deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;
	
SAttributeDeduction:
	{SAttributeDeduction} 
	(	'grab' ('attribute' | detail?='detail')? deductionRule=SGrabFeatureRule
	|	'morph' ('attribute' | detail?='detail')? deductionRule=SMorphFeatureRule
	|	'ditch' ('attribute' | detail?='detail')? deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;

SQueryDeduction:
	{SQueryDeduction} 
	(	(	'grab' 'query' deductionRule=SGrabFeatureRule
		|	'morph' 'query' deductionRule=SMorphFeatureRule
		)
		'('
		(	'*'
		|	(parameters+=QueryParameter ( ',' parameters+=QueryParameter)*)?
		)
		')'
	|	'ditch' 'query' deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;
	
@Override 
DQuery:
	name=ID
	('alias' aliases+=ID)*
	'(' (parameters+=QueryParameter ( "," parameters+=QueryParameter)*)? ')'
	':' 
	type=[DType|ID]  (multiplicity=DMultiplicity)?
	('returns' ^returns=DExpression)?
	(description=DRichText)?;
	
QueryParameter returns DQueryParameter:
	SQueryParameterDeduction | DQueryParameter;
	
SQueryParameterDeduction:
	{SQueryParameterDeduction} 
	(	'grab' deductionRule=SGrabFeatureRule
	|	'morph' deductionRule=SMorphFeatureRule
	|	'ditch' deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;
	
SCoreQuery:
	'query'
	name=ID
	('alias' aliases+=ID)*
	'(' (parameters+=DQueryParameter ( "," parameters+=DQueryParameter)*)? ')'
	':' 
	type=[DType|ID]  (multiplicity=DMultiplicity)?
	('returns' ^returns=DExpression)?
	(description=DRichText)?;
