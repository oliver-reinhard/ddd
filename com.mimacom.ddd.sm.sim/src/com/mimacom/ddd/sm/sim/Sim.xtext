grammar com.mimacom.ddd.sm.sim.Sim with com.mimacom.ddd.dm.dim.Dim

import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.mimacom.com/ddd/sm/sim"


@Override 
DNamespace:
	'system'
	name=DQualifiedName
	(imports+=DImport)*
	model=SInformationModel;
	
SInformationModel:
	(	kind=STypeModelKind 'type' 'model'
	|	kind=SInformationModelKind 'information' 'model'		
	)
	name=ID
	 (^generate?='generate')?
	(description=DRichText)?
	'{'
	(types+=SType | aggregates+=SAggregate)*
	'}';
	
enum STypeModelKind returns SInformationModelKind:
	BASE='base';
	
enum SInformationModelKind:
	INTERFACE='interface' | CORE='core';

/*
 * RULEs
 */
		
SGrabAggregateRule:
	source=[DAggregate|DQualifiedName]
	('as' renameTo=ID)?;
	
SGrabPrimitiveRule returns SGrabRule:
	source=[DPrimitive|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchPrimitiveRule returns SDitchRule:
	source=[DPrimitive|DQualifiedName];
	
SGrabEnumerationRule returns SGrabRule:
	source=[DEnumeration|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchEnumerationRule returns SDitchRule:
	source=[DEnumeration|DQualifiedName];

SGrabEnumerationLiteralRule returns SGrabRule:
	source=[DLiteral|ID]
	('as' renameTo=ID)?;
	
SDitchEnumerationLiteralRule returns SDitchRule:
	source=[DLiteral|ID];
	
SGrabComplexTypeRule returns SGrabRule:
	source=[DComplexType|DQualifiedName]
	('as' renameTo=ID)?;
	
SDitchComplexTypeRule returns SDitchRule:
	source=[DComplexType|DQualifiedName];
	
SMorphComplexTypeRule returns SMorphRule:
	source=[DComplexType|DQualifiedName]
	ChangeComplexType;
	
SFuseComplexTypeRule returns SFuseRule:
	source=[DComplexType|DQualifiedName]
	('and' otherSources+=[DComplexType|DQualifiedName])+
	ChangeComplexType;

fragment ChangeComplexType returns SStructureChangingRule:
	'to' 
	abstract=SAbstractType? 
	(	detail=SDetailType
	|	rootEntity=SRootEntity? detail=SEntityType
	)
	(renameTo=ID)?
	('extends' extendFrom=[DComplexType|ID])?;

SGrabFeatureRule returns SGrabRule:
	source=[DFeature|ID]
	('as' renameTo=ID)?;
	
SMorphFeatureRule returns SMorphRule:
	source=[DFeature|ID]
	'to'
	(renameTo=ID ':')? 
	retypeTo=[DType|ID] (remultiplyTo=DMultiplicity)?;	

SDitchFeatureRule returns SDitchRule:
	source=[DFeature|ID];
	
SGrabQueryParameterRule returns SGrabRule:
	source=[DQueryParameter|ID]
	('as' renameTo=ID)?;
	
SMorphQueryParameterRule returns SMorphRule:
	source=[DQueryParameter|ID]
	'to'
	(renameTo=ID ':')? 
	retypeTo=[DType|ID] (remultiplyTo=DMultiplicity)?;	

SDitchQueryParameterRule returns SDitchRule:
	source=[DQueryParameter|ID];

enum SAbstractType returns STristate:
	FALSE='nonabstract' | TRUE='abstract';
	
enum SRootEntity returns STristate:
	FALSE='nonroot' | TRUE='root';
	
enum SDetailType returns STristate:
	TRUE='detail';

enum SEntityType returns STristate:
	FALSE='entity';

SAggregate returns DAggregate:
	SAggregateDeduction | DAggregate;

SAggregateDeduction:
	{SAggregateDeduction}
	'grab' 'aggregate' deductionRule=SGrabAggregateRule
	(description=DRichText)?
	(	'{'
			(features+=SQueryDeduction | 'add' 'query' features+=DQuery)*
			( types+=SType)*
		'}'
	)?;
		
@Override 
DAggregateKeyword:
	'aggregate';  // replace DIM keyword 'component'

/*
 * TYPES
 */

@Override
DType:
	SPrimitiveDeduction | DPrimitive
	| SEnumerationDeduction | DEnumeration
	| SEntityTypeDeduction | DEntityType
	| SDetailTypeDeduction | DDetailType;
	
SType returns DType:
	SPrimitiveDeduction | 'add' DPrimitive
	| SEnumerationDeduction | 'add' DEnumeration
	| SEntityTypeDeduction | 'add' DEntityType
	| SDetailTypeDeduction | 'add' DDetailType;

SPrimitiveDeduction:
	{SPrimitiveDeduction}
	(	'grab' 'primitive' deductionRule=SGrabPrimitiveRule
	|	'ditch' 'primitive' deductionRule=SDitchPrimitiveRule
	)
	(description=DRichText)?
	(	'{'
		('add' constraints+=DConstraint)*
		'}'
	)?;
	
SEnumerationDeduction:
	{SEnumerationDeduction} 
	(	'grab' 'enumeration' deductionRule=SGrabEnumerationRule
	|	'ditch' 'enumeration' deductionRule=SDitchEnumerationRule
	)
	(description=DRichText)?
	(	'{'
		 	(literals+=SLiteral (',' literals+=SLiteral)*)?
			('add' constraints+=DConstraint)*
		 '}'
	)?;
	 
SLiteral returns DLiteral:
	SLiteralDeduction | 'add' DLiteral;
	
SLiteralDeduction:
	{SLiteralDeduction}
	(	 'grab' deductionRule=SGrabEnumerationLiteralRule
	|	 'ditch' deductionRule=SDitchEnumerationLiteralRule
	)
	(description=DRichText)?;

SEntityTypeDeduction:
	{SEntityTypeDeduction}
	(	'grab'(root?='root')? 'entity' deductionRule=SGrabComplexTypeRule
	|	'ditch' (root?='root')? 'entity' deductionRule=SDitchComplexTypeRule
	|	'morph' (root?='root')? 'entity' deductionRule=SMorphComplexTypeRule
	|	'fuse'(root?='root')?  'entity' deductionRule=SFuseComplexTypeRule
	)
	(description=DRichText)?
	SComplexTypeFeatures?;

SDetailTypeDeduction:
	{SDetailTypeDeduction} 
	(	'grab' 'detail' deductionRule=SGrabComplexTypeRule
	|	'ditch' 'detail' deductionRule=SDitchComplexTypeRule
	|	'morph' 'detail' deductionRule=SMorphComplexTypeRule
	|	'fuse' 'detail' deductionRule=SFuseComplexTypeRule
	)
	(description=DRichText)?
	SComplexTypeFeatures?;

fragment SComplexTypeFeatures returns DComplexType:
	'{'
			(features+=SFeature | 'add' constraints+=DConstraint)*
	'}';
	
/*
 * FEATURES
 */	
	
SFeature returns DFeature:
	SAssociationDeduction | 'add' DAssociation
	| SAttributeDeduction | 'add' DAttribute
	| SQueryDeduction | 'add' DQuery;

SAssociationDeduction:
	{SAssociationDeduction} 
	(	'grab' ('reference' | 'composite') deductionRule=SGrabFeatureRule
	|	'morph' ('reference' | 'composite')deductionRule=SMorphFeatureRule
	|	'ditch' ('reference' | 'composite') deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;
	
SAttributeDeduction:
	{SAttributeDeduction} 
	(	'grab' ('attribute' | detail?='detail')? deductionRule=SGrabFeatureRule
	|	'morph' ('attribute' | detail?='detail')? deductionRule=SMorphFeatureRule
	|	'ditch' ('attribute' | detail?='detail')? deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;

SQueryDeduction:
	{SQueryDeduction} 
	(	(	'grab' 'query' deductionRule=SGrabFeatureRule
		|	'morph' 'query' deductionRule=SMorphFeatureRule
		)
		'('
		(	'*'
		|	parameters+=SQueryParameter ( ',' parameters+=SQueryParameter)*
		)
		')'
	|	'ditch' 'query' deductionRule=SDitchFeatureRule
	)
	(description=DRichText)?;
		
SQueryParameter returns DQueryParameter:
	SQueryParameterDeduction | 'add' DQueryParameter;
	
SQueryParameterDeduction:
	{SQueryParameterDeduction} 
	(	'grab' deductionRule=SGrabQueryParameterRule
	|	'morph' deductionRule=SMorphQueryParameterRule
	|	'ditch' deductionRule=SDitchQueryParameterRule
	)
	(description=DRichText)?;
