grammar com.mimacom.ddd.sm.sim.Sim with org.eclipse.xtext.common.Terminals

import "http://www.mimacom.com/ddd/sm/sim/Sim"
import "http://www.mimacom.com/ddd/dm/base" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

SInformationModel:
	kind=SInformationModelKind 'information' 'model'
	name=SQualifiedName
	 (^generate?='generate')?
//	(description=DRichText)?
	(imports+=SImport)*
	(types+=SType |	aggregates+=SAggregate | grabDomainRules+=SGrabDomainRule)*;

enum SInformationModelKind:
	BASE='base' | INTERFACE='interface' | CORE='core';

SImport:
	'import' importedNamespace=SQualifiedNameWithWildcard;

// Transformation rules

SGrabDomainRule:
	'grab' 'domain' source=[DDomain|SQualifiedName];
		
SGrabAggregateRule:
	source=[DAggregate|SQualifiedName];
	
SGrabPrimitiveRule returns SGrabRule:
	source=[DPrimitive|SQualifiedName]
	('as' renameTo=ID)?;
	
SGrabEnumerationRule returns SGrabRule:
	source=[DEnumeration|SQualifiedName]
	('as' renameTo=ID)?;
	
SDitchEnumerationRule returns SDitchRule:
	source=[DEnumeration|ID];

SGrabEnumerationLiteralRule returns SGrabRule:
	source=[DLiteral|ID]
	('as' renameTo=ID)?;
	
SDitchEnumerationLiteralRule returns SDitchRule:
	source=[DLiteral|ID];
	
SGrabComplexTypeRule returns SGrabRule:
	source=[DComplexType|SQualifiedName]
	('as' renameTo=ID)?;
	
SDitchComplexTypeRule returns SDitchRule:
	source=[DEnumeration|ID];
	
SMorphComplexTypeRule returns SMorphRule:
	source=[DComplexType|SQualifiedName]
	('as' renameTo=ID)?
	('extends' '=' retypeTo=[SComplexType|ID])?;
	
SFuseComplexTypeRule returns SFuseRule:
	source=[DComplexType|SQualifiedName]
	('and' otherSources+=[DComplexType|SQualifiedName])+
	('as' renameTo=ID)?
	('extends' extendFrom=[SComplexType|ID])?;

SGrabFeatureRule returns SGrabRule:
	source=[DFeature|ID]
	('as' renameTo=ID)?;
	
SMorphFeatureRule returns SMorphRule:
	source=[DFeature|ID]
	('as' renameTo=ID)? 
	(':' retypeTo=[SType|ID] (remultiplyTo=SMultiplicity)?)?;	

SDitchFeatureRule returns SDitchRule:
	source=[DFeature|ID];
	
SAggregate:
	{SAggregate}
	(	'grab' 'aggregate' deductionRule=SGrabAggregateRule
	|	'aggregate'
	)
	//	(description=DRichText)?
	'{'
		( types+=SType)*
	'}';

/*
 * TYPES
 */
SType:
	SPrimitive | SEnumeration | SRootType | SDetailType;
	
SConstraint returns SCondition:
	'constraint'
	name=ID
	':'
	condition=SExpression;
//	(description=DRichText)?;

SPrimitive:
	( 	{SPrimitive} 'grab' 'primitive' deductionRule=SGrabPrimitiveRule
	|	'archetype'
		name=ID
	|	'primitive'
		name=ID
		'redefines' redefines=[SPrimitive]
	//(description=DRichText)?
	)
	'{'
		(constraints+=SConstraint)*
	'}';
	
SEnumeration:
	(	{SEnumeration} 'grab' 'enumeration' deductionRule=SGrabEnumerationRule
	|	{SEnumeration} 'ditch' 'enumeration' deductionRule=SDitchEnumerationRule
	|	'enumeration'
		name=ID
		//	(description=DRichText)?
	)
	'{'
	 	(literals+=SLiteral (',' literals+=SLiteral)*)?
		(constraints+=SConstraint)*
	 '}';

SLiteral:
	(	{SLiteral} 'grab' deductionRule=SGrabEnumerationLiteralRule
	|	{SLiteral} 'ditch' deductionRule=SDitchEnumerationLiteralRule
	| 	name=ID
	);
	//	(description=DRichText)?;

SRootType:
	(	{SRootType} 'grab' (abstract?='abstract')? 'root' deductionRule=SGrabComplexTypeRule
	|	{SRootType} 'ditch' (abstract?='abstract')? 'root' deductionRule=SDitchComplexTypeRule
	|	{SRootType} 'morph' (abstract?='abstract')? 'root' deductionRule=SMorphComplexTypeRule
	|	{SRootType} 'fuse' (abstract?='abstract')? 'root' deductionRule=SFuseComplexTypeRule
	|	(abstract?='abstract')? 'root'
		name=ID
		SComplexTypeExtends
	)
	SComplexTypeFeatures;

SDetailType:
	(	{SDetailType} 'grab' (abstract?='abstract')? 'detail' deductionRule=SGrabComplexTypeRule
	|	{SDetailType} 'ditch' (abstract?='abstract')? 'detail' deductionRule=SDitchComplexTypeRule
	|	{SDetailType} 'morph' (abstract?='abstract')? 'detail' deductionRule=SMorphComplexTypeRule
	|	{SDetailType} 'fuse' (abstract?='abstract')? 'detail' deductionRule=SFuseComplexTypeRule
	|	(abstract?='abstract')? 'detail'
		name=ID
		SComplexTypeExtends
	)
	SComplexTypeFeatures;

fragment SComplexTypeExtends returns SComplexType:
	('extends' superType=[SComplexType|ID])?
//	(description=DRichText)?
	;

fragment SComplexTypeFeatures returns SComplexType:
	'{'
		(features+=SFeature | constraints+=SConstraint)*
	'}';
	
SFeature:
	SAssociation |  SAttribute | SQuery;

SAssociation:
	(	{SAssociation} 'grab' ('reference' | 'composite') deductionRule=SGrabFeatureRule
	|	{SAssociation} 'morph' ('reference' | 'composite')deductionRule=SMorphFeatureRule
	|	{SAssociation} 'ditch' ('reference' | 'composite') deductionRule=SDitchFeatureRule
	|	(derived?='derived')? 
		(kind=SAssociationKind | (kind=SAssociationKindInverse 'composite'))
		name=ID
		':'
		type=[SRootType|ID]  (multiplicity=SMultiplicity)?
		//	(description=DRichText)?;
	);

enum SAssociationKind:
	REFERENCE='reference' | COMPOSITE='composite';

enum SAssociationKindInverse returns SAssociationKind:	
	 INVERSE_COMPOSITE='inverse';
	
SAttribute:
	(	{SAttribute} 'grab' ('attribute' | detail?='detail')? deductionRule=SGrabFeatureRule
	|	{SAttribute} 'morph' ('attribute' | detail?='detail')? deductionRule=SMorphFeatureRule
	|	{SAttribute} 'ditch' ('attribute' | detail?='detail')? deductionRule=SDitchFeatureRule
	|	(detail?='detail')?
		name=ID
		':'
		type=[SSimpleType|ID] 
		(multiplicity=SMultiplicity)?
		(key?='key')?
	);
	//	(description=DRichText)?;

SQuery:
	(	(	{SQuery} 'grab' 'query' deductionRule=SGrabFeatureRule
		|	{SQuery} 'morph' 'query' deductionRule=SMorphFeatureRule
		)
		'('
		(	'*'
		|	(parameters+=SQueryParameter ( ',' parameters+=SQueryParameter)*)?
		)
		')'
	|	'ditch' 'query' deductionRule=SDitchFeatureRule
	|	name=ID
		'(' (parameters+=SQueryParameter ( ',' parameters+=SQueryParameter)*)? ')'
		':' 
		type=[SType|ID]  (multiplicity=SMultiplicity)?
		('returns' ^returns=SExpression)?
	);
	//	(description=DRichText)?;

SQueryParameter:
	(	{SQueryParameter} 'grab' deductionRule=SGrabFeatureRule
	|	{SQueryParameter} 'morph' deductionRule=SMorphFeatureRule
	|	{SQueryParameter} 'ditch' deductionRule=SDitchFeatureRule
	|	name=ID 
		':' 
		type=[SType|ID]  (multiplicity=SMultiplicity)?
	);
	//	(description=DRichText)?;

SExpression:
	expr=STRING;

SQualifiedNameWithWildcard: 
	SQualifiedName '.*'?;

SQualifiedName:
	ID ('.' ID)*;
	
SMultiplicity:
	'(' minOccurs=INT '..' maxOccurs=MULTIPLICITY ')';
	
MULTIPLICITY returns ecore::EInt:
	INT | '*';
