/**
 * generated by Xtext 2.17.1
 */
package com.mimacom.ddd.dm.dom.ui.contentassist;

import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.DComplexType;
import com.mimacom.ddd.dm.base.DEnumeration;
import com.mimacom.ddd.dm.base.DFeature;
import com.mimacom.ddd.dm.base.DLiteral;
import com.mimacom.ddd.dm.base.DType;
import com.mimacom.ddd.dm.dmx.DmxBaseType;
import com.mimacom.ddd.dm.dmx.DmxUtil;
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeComputer;
import com.mimacom.ddd.dm.dom.DomDetailObject;
import com.mimacom.ddd.dm.dom.DomField;
import com.mimacom.ddd.dm.dom.ui.contentassist.AbstractDomProposalProvider;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
@SuppressWarnings("all")
public class DomProposalProvider extends AbstractDomProposalProvider {
  @Inject
  @Extension
  private DmxUtil _dmxUtil;
  
  @Inject
  private DmxTypeComputer typeComputer;
  
  private final SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm");
  
  @Override
  public void complete_DomField(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.complete_DomField(model, ruleCall, context, acceptor);
    this.proposeAllMandatoryFieldsNotPresentYet(model, false, acceptor, context);
    if ((model instanceof DomDetailObject)) {
      DComplexType _ref = ((DomDetailObject)model).getRef();
      boolean _tripleNotEquals = (_ref != null);
      if (_tripleNotEquals) {
        List<DFeature> _allFeatures = this._dmxUtil.allFeatures(((DomDetailObject)model).getRef());
        for (final DFeature feature : _allFeatures) {
          final Function1<DomField, DFeature> _function = (DomField it) -> {
            return it.getRef();
          };
          boolean _contains = ListExtensions.<DomField, DFeature>map(((DomDetailObject)model).getFields(), _function).contains(feature);
          boolean _not = (!_contains);
          if (_not) {
            String _name = feature.getName();
            final StringBuilder displayString = new StringBuilder(_name);
            DType _type = feature.getType();
            boolean _tripleNotEquals_1 = (_type != null);
            if (_tripleNotEquals_1) {
              displayString.append(" - ");
              displayString.append(feature.getType().getName());
            }
            boolean _isOptional = feature.isOptional();
            if (_isOptional) {
              displayString.append(" (optional)");
            }
            StringConcatenation _builder = new StringConcatenation();
            String _name_1 = feature.getName();
            _builder.append(_name_1);
            _builder.append(" = ");
            String _typedLiteral = this.typedLiteral(feature);
            _builder.append(_typedLiteral);
            final String proposal = _builder.toString();
            acceptor.accept(this.createCompletionProposal(proposal, displayString.toString(), null, context));
          }
        }
      }
    }
  }
  
  @Override
  public void complete_DomFieldListStartSymbol(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.complete_DomFieldListStartSymbol(model, ruleCall, context, acceptor);
    this.proposeAllMandatoryFieldsNotPresentYet(model, true, acceptor, context);
  }
  
  protected void proposeAllMandatoryFieldsNotPresentYet(final EObject model, final boolean surroundWithBraces, final ICompletionProposalAcceptor acceptor, final ContentAssistContext context) {
    if ((model instanceof DomDetailObject)) {
      DComplexType _ref = ((DomDetailObject)model).getRef();
      boolean _tripleNotEquals = (_ref != null);
      if (_tripleNotEquals) {
        final Function1<DFeature, Boolean> _function = (DFeature it) -> {
          return Boolean.valueOf((!(it.isOptional() || ListExtensions.<DomField, DFeature>map(((DomDetailObject)model).getFields(), ((Function1<DomField, DFeature>) (DomField it_1) -> {
            return it_1.getRef();
          })).contains(it))));
        };
        final Iterable<DFeature> features = IterableExtensions.<DFeature>filter(this._dmxUtil.allFeatures(((DomDetailObject)model).getRef()), _function);
        final StringBuilder proposal = new StringBuilder();
        if (surroundWithBraces) {
          proposal.append("{\n");
        }
        for (int i = 0; (i < IterableExtensions.size(features)); i++) {
          {
            final DFeature feature = ((DFeature[])Conversions.unwrapArray(features, DFeature.class))[i];
            StringConcatenation _builder = new StringConcatenation();
            {
              if (((i > 0) || surroundWithBraces)) {
                _builder.append("\t\t");
              }
            }
            String _name = feature.getName();
            _builder.append(_name);
            _builder.append(" = ");
            String _typedLiteral = this.typedLiteral(feature);
            _builder.append(_typedLiteral);
            _builder.newLineIfNotEmpty();
            final String field = _builder.toString();
            proposal.append(field);
          }
        }
        if (surroundWithBraces) {
          proposal.append("\t}\n");
        }
        acceptor.accept(this.createCompletionProposal(proposal.toString(), "All mandatory fields", null, context));
      }
    }
  }
  
  public String typedLiteral(final DFeature f) {
    String _xifexpression = null;
    DType _type = f.getType();
    boolean _tripleNotEquals = (_type != null);
    if (_tripleNotEquals) {
      String _xblockexpression = null;
      {
        final AbstractDmxTypeDescriptor<?> typeDescriptor = this.typeComputer.getTypeDescriptor(f.getType(), false);
        final DmxBaseType baseType = typeDescriptor.baseType();
        String _switchResult = null;
        if (baseType != null) {
          switch (baseType) {
            case BOOLEAN:
              _switchResult = "true";
              break;
            case ENUM:
              String _name = typeDescriptor.type().getName();
              String _plus = (_name + ".");
              DType _type_1 = typeDescriptor.type();
              String _name_1 = IterableExtensions.<DLiteral>head(((DEnumeration) _type_1).getLiterals()).getName();
              _switchResult = (_plus + _name_1);
              break;
            case IDENTIFIER:
              _switchResult = "someId";
              break;
            case NUMBER:
              _switchResult = "1";
              break;
            case TEXT:
              _switchResult = "\"\"";
              break;
            case TIMEPOINT:
              Date _date = new Date();
              String _format = this.formatter.format(_date);
              String _plus_1 = ("\"" + _format);
              _switchResult = (_plus_1 + "\"");
              break;
            case COMPLEX:
              String _name_2 = typeDescriptor.type().getName();
              _switchResult = (_name_2 + " ");
              break;
            default:
              _switchResult = "unknownType";
              break;
          }
        } else {
          _switchResult = "unknownType";
        }
        _xblockexpression = _switchResult;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
}
