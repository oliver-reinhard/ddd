/**
 * generated by Xtext 2.17.1
 */
package com.mimacom.ddd.dm.dom.ui.contentassist;

import com.google.common.collect.Sets;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.base.DAttribute;
import com.mimacom.ddd.dm.base.base.DEntityType;
import com.mimacom.ddd.dm.base.base.DEnumeration;
import com.mimacom.ddd.dm.base.base.DFeature;
import com.mimacom.ddd.dm.base.base.DLiteral;
import com.mimacom.ddd.dm.base.base.DQuery;
import com.mimacom.ddd.dm.base.base.DType;
import com.mimacom.ddd.dm.dmx.DmxBaseType;
import com.mimacom.ddd.dm.dmx.DmxComplexObject;
import com.mimacom.ddd.dm.dmx.DmxField;
import com.mimacom.ddd.dm.dmx.DmxUtil;
import com.mimacom.ddd.dm.dmx.typecomputer.AbstractDmxTypeDescriptor;
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider;
import com.mimacom.ddd.dm.dom.DomUtil;
import com.mimacom.ddd.dm.dom.ui.contentassist.AbstractDomProposalProvider;
import java.util.Date;
import java.util.HashSet;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext;
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
@SuppressWarnings("all")
public class DomProposalProvider extends AbstractDomProposalProvider {
  @Inject
  @Extension
  private DomUtil util;
  
  @Inject
  private DmxTypeDescriptorProvider typeDescriptorProvider;
  
  private static int idCurrent = 1;
  
  @Override
  public void completeDmxField_Feature(final EObject model, final Assignment assignment, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    this.buildProposals(model, false, acceptor, context);
  }
  
  @Override
  public void complete_DmxFieldListStartSymbol(final EObject model, final RuleCall ruleCall, final ContentAssistContext context, final ICompletionProposalAcceptor acceptor) {
    super.complete_DmxFieldListStartSymbol(model, ruleCall, context, acceptor);
    this.buildProposals(model, true, acceptor, context);
  }
  
  protected void buildProposals(final EObject model, final boolean surroundWithBraces, final ICompletionProposalAcceptor acceptor, final ContentAssistContext context) {
    final DmxComplexObject complexObject = EcoreUtil2.<DmxComplexObject>getContainerOfType(model, DmxComplexObject.class);
    if (((complexObject == null) || (complexObject.getType() == null))) {
      return;
    }
    this.proposeAllMandatoryFieldsNotYetPresent(complexObject, surroundWithBraces, acceptor, context);
    this.proposeIndividualFieldsNotYetPresent(complexObject, acceptor, context);
  }
  
  /**
   * Creates a single proposal named "All mandatory fields".
   */
  protected void proposeAllMandatoryFieldsNotYetPresent(final DmxComplexObject complexObject, final boolean surroundWithBraces, final ICompletionProposalAcceptor acceptor, final ContentAssistContext context) {
    final Function1<DFeature, Boolean> _function = (DFeature it) -> {
      return Boolean.valueOf((!((it.isOptional() || (it instanceof DQuery)) || ListExtensions.<DmxField, DFeature>map(complexObject.getFields(), ((Function1<DmxField, DFeature>) (DmxField it_1) -> {
        return it_1.getFeature();
      })).contains(it))));
    };
    final Iterable<DFeature> features = IterableExtensions.<DFeature>filter(this.util.allFeatures(complexObject.getType()), _function);
    boolean _isEmpty = IterableExtensions.isEmpty(features);
    if (_isEmpty) {
      return;
    }
    final StringBuilder proposal = new StringBuilder();
    if (surroundWithBraces) {
      proposal.append("{\n");
    }
    String indent = this.calcIndent(complexObject);
    for (int i = 0; (i < IterableExtensions.size(features)); i++) {
      {
        final DFeature feature = ((DFeature[])Conversions.unwrapArray(features, DFeature.class))[i];
        StringConcatenation _builder = new StringConcatenation();
        {
          if (((i > 0) || surroundWithBraces)) {
            _builder.append(indent);
            _builder.append("\t");
          }
        }
        String _name = feature.getName();
        _builder.append(_name);
        _builder.append(" = ");
        String _typedLiteral = this.typedLiteral(feature);
        _builder.append(_typedLiteral);
        _builder.newLineIfNotEmpty();
        final String field = _builder.toString();
        proposal.append(field);
      }
    }
    if (surroundWithBraces) {
      proposal.append(indent);
      proposal.append("}");
    }
    acceptor.accept(this.createCompletionProposal(proposal.toString(), "All mandatory fields", null, context));
  }
  
  /**
   * Creates a multiple proposals, one per field.
   */
  protected void proposeIndividualFieldsNotYetPresent(final DmxComplexObject complexObject, final ICompletionProposalAcceptor acceptor, final ContentAssistContext context) {
    final Function1<DFeature, Boolean> _function = (DFeature it) -> {
      return Boolean.valueOf((!(it instanceof DQuery)));
    };
    final HashSet<DFeature> featuresNotYetPresent = Sets.<DFeature>newHashSet(IterableExtensions.<DFeature>filter(this.util.allFeatures(complexObject.getType()), _function));
    final Function1<DmxField, DFeature> _function_1 = (DmxField it) -> {
      return it.getFeature();
    };
    featuresNotYetPresent.removeAll(ListExtensions.<DmxField, DFeature>map(complexObject.getFields(), _function_1));
    for (final DFeature f : featuresNotYetPresent) {
      final Function1<DmxField, DFeature> _function_2 = (DmxField it) -> {
        return it.getFeature();
      };
      boolean _contains = ListExtensions.<DmxField, DFeature>map(complexObject.getFields(), _function_2).contains(f);
      boolean _not = (!_contains);
      if (_not) {
        String _name = f.getName();
        final StringBuilder displayString = new StringBuilder(_name);
        DType _type = f.getType();
        boolean _tripleNotEquals = (_type != null);
        if (_tripleNotEquals) {
          displayString.append(" - ");
          DType _type_1 = f.getType();
          if ((_type_1 instanceof DEntityType)) {
            displayString.append("Reference to ");
          }
          displayString.append(f.getType().getName());
        }
        boolean _isOptional = f.isOptional();
        if (_isOptional) {
          displayString.append(" (optional)");
        }
        StringConcatenation _builder = new StringConcatenation();
        String _name_1 = f.getName();
        _builder.append(_name_1);
        _builder.append(" = ");
        String _typedLiteral = this.typedLiteral(f);
        _builder.append(_typedLiteral);
        final String proposal = _builder.toString();
        acceptor.accept(this.createCompletionProposal(proposal, displayString.toString(), null, context));
      }
    }
  }
  
  protected String calcIndent(final DmxComplexObject container) {
    String indent = "";
    EObject c = container;
    while (((c instanceof DmxComplexObject) || (c instanceof DmxField))) {
      {
        if ((c instanceof DmxComplexObject)) {
          String _indent = indent;
          indent = (_indent + "\t");
        }
        c = c.eContainer();
      }
    }
    return indent;
  }
  
  public String typedLiteral(final DFeature f) {
    String _xifexpression = null;
    DType _type = f.getType();
    boolean _tripleNotEquals = (_type != null);
    if (_tripleNotEquals) {
      String _xblockexpression = null;
      {
        final AbstractDmxTypeDescriptor<?> typeDescriptor = this.typeDescriptorProvider.getTypeDescriptor(f.getType(), false);
        final DmxBaseType baseType = typeDescriptor.baseType();
        String _switchResult = null;
        if (baseType != null) {
          switch (baseType) {
            case BOOLEAN:
              _switchResult = "true";
              break;
            case ENUM:
              String _name = typeDescriptor.type().getName();
              String _plus = (_name + ".");
              DType _type_1 = typeDescriptor.type();
              String _name_1 = IterableExtensions.<DLiteral>head(((DEnumeration) _type_1).getLiterals()).getName();
              _switchResult = (_plus + _name_1);
              break;
            case IDENTIFIER:
              _switchResult = this.nextId();
              break;
            case NUMBER:
              _switchResult = "1";
              break;
            case TEXT:
              _switchResult = "\"\"";
              break;
            case TIMEPOINT:
              Date _date = new Date();
              String _format = DmxUtil.TIMEPOINT_DATE_TIME_FORMAT.format(_date);
              String _plus_1 = ("\"" + _format);
              _switchResult = (_plus_1 + "\"");
              break;
            case COMPLEX:
              String _xifexpression_1 = null;
              if ((f instanceof DAttribute)) {
                String _name_2 = typeDescriptor.type().getName();
                String _plus_2 = ("detail " + _name_2);
                _xifexpression_1 = (_plus_2 + " { }");
              } else {
                _xifexpression_1 = "";
              }
              _switchResult = _xifexpression_1;
              break;
            default:
              _switchResult = "unknownType";
              break;
          }
        } else {
          _switchResult = "unknownType";
        }
        _xblockexpression = _switchResult;
      }
      _xifexpression = _xblockexpression;
    }
    return _xifexpression;
  }
  
  public String nextId() {
    DomProposalProvider.idCurrent++;
    return Integer.toString(DomProposalProvider.idCurrent);
  }
}
