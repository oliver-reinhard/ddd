/*
 * generated by Xtext 2.17.1
 */
package com.mimacom.ddd.dm.dom.ui.contentassist

import com.google.common.collect.Sets
import com.google.inject.Inject
import com.mimacom.ddd.dm.base.base.DAttribute
import com.mimacom.ddd.dm.base.base.DEntityType
import com.mimacom.ddd.dm.base.base.DEnumeration
import com.mimacom.ddd.dm.base.base.DFeature
import com.mimacom.ddd.dm.base.base.DQuery
import com.mimacom.ddd.dm.dmx.DmxComplexObject
import com.mimacom.ddd.dm.dmx.DmxField
import com.mimacom.ddd.dm.dmx.DmxUtil
import com.mimacom.ddd.dm.dmx.typecomputer.DmxTypeDescriptorProvider
import com.mimacom.ddd.dm.dom.DomUtil
import java.util.Date
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class DomProposalProvider extends AbstractDomProposalProvider {

	@Inject extension DomUtil util
	@Inject DmxTypeDescriptorProvider typeDescriptorProvider

	static var int idCurrent = 1
	
	override completeDmxField_Feature(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		buildProposals(model, false, acceptor, context)
	}
	
//	override completeDmxField_Value(EObject model, Assignment assignment, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
//		// super.completeDmxField_Value(model, assignment, context, acceptor)
//		TODO narrow proposals to expressions
//	}

	override complete_DmxFieldListStartSymbol(EObject model, RuleCall ruleCall, ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.complete_DmxFieldListStartSymbol(model, ruleCall, context, acceptor)
		buildProposals(model, true, acceptor, context)
	}
	
	protected def void buildProposals(EObject model, boolean surroundWithBraces, ICompletionProposalAcceptor acceptor, ContentAssistContext context) {
		val complexObject = EcoreUtil2.getContainerOfType(model, DmxComplexObject)
		if (complexObject === null || complexObject.type === null) {
			return
		}
		proposeAllMandatoryFieldsNotYetPresent(complexObject, surroundWithBraces, acceptor, context) 
		proposeIndividualFieldsNotYetPresent(complexObject, acceptor, context)
	}

	/*
	 * Creates a single proposal named "All mandatory fields".
	 */
	protected def void proposeAllMandatoryFieldsNotYetPresent(DmxComplexObject complexObject, boolean surroundWithBraces,
		ICompletionProposalAcceptor acceptor, ContentAssistContext context) {
		// exclude optional features and features already present in fields of this complex object:
		val features = complexObject.type.allFeatures.filter[! (optional || it instanceof DQuery || complexObject.fields.map[feature].contains(it))]
		if (features.empty) {
			return
		}
		val proposal = new StringBuilder()
		if (surroundWithBraces) {
			proposal.append("{\n")
		}
		var indent = calcIndent(complexObject)
		for (var i = 0; i < features.size; i++) {
			val feature = features.get(i)
			val field = '''«IF i>0 || surroundWithBraces»«indent»	«ENDIF»«feature.name» = «feature.typedLiteral»
			'''
			proposal.append(field)
		}
		if (surroundWithBraces) {
			proposal.append(indent)
			proposal.append("}")
		}
		acceptor.accept(createCompletionProposal(proposal.toString, "All mandatory fields", null, context))
	}
	/*
	 * Creates a multiple proposals, one per field.
	 */
	protected def void proposeIndividualFieldsNotYetPresent(DmxComplexObject complexObject, ICompletionProposalAcceptor acceptor, ContentAssistContext context) {
		val featuresNotYetPresent = Sets.newHashSet(complexObject.type.allFeatures.filter [! (it instanceof DQuery)])
		featuresNotYetPresent.removeAll(complexObject.fields.map[feature]) 
		for (f : featuresNotYetPresent) {
			if (! complexObject.fields.map[feature].contains(f)) {
				val displayString = new StringBuilder(f.name)
				if (f.type !== null) {
					displayString.append(" - ")
					if (f.type instanceof DEntityType) {
						displayString.append("Reference to ")
					}
					displayString.append(f.type.name)
				}
				if (f.optional) {
					displayString.append(" (optional)")
				}
				val proposal = '''«f.name» = «f.typedLiteral»'''
				acceptor.accept(createCompletionProposal(proposal, displayString.toString, null, context))
			}
		}
	}

	protected def String calcIndent(DmxComplexObject container) {
		var indent = ""
		var EObject c = container
		while (c instanceof DmxComplexObject || c instanceof DmxField) {
			if (c instanceof DmxComplexObject) {
				indent += "\t"
			}
			c = c.eContainer
		}
		return indent
	}

	def String typedLiteral(DFeature f) {
		if (f.type !== null) {
			val typeDescriptor = typeDescriptorProvider.getTypeDescriptor(f.type, false)
			val baseType = typeDescriptor.baseType
			switch baseType {
				case BOOLEAN: "true"
				case ENUM: typeDescriptor.type.name + "." + (typeDescriptor.type as DEnumeration).literals.head.name
				case IDENTIFIER: nextId
				case NUMBER: "1"
				case TEXT: "\"\""
				case TIMEPOINT: "\"" + DmxUtil::TIMEPOINT_DATE_TIME_FORMAT.format(new Date()) + "\""
				case COMPLEX: f instanceof DAttribute ? "detail " + typeDescriptor.type.name + " { }" : ""
				default: "unknownType"
			}
		}
	}

	def String nextId() {
		idCurrent++
		return Integer.toString(idCurrent)
	}
}
