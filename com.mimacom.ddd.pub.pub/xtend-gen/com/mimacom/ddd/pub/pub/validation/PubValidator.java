/**
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.pub.pub.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;
import com.google.inject.Inject;
import com.mimacom.ddd.dm.base.BasePackage;
import com.mimacom.ddd.dm.base.DRichText;
import com.mimacom.ddd.dm.base.DTextSegment;
import com.mimacom.ddd.dm.base.IRichTextSegment;
import com.mimacom.ddd.dm.dmx.DmxContextReference;
import com.mimacom.ddd.dm.dmx.DmxStaticReference;
import com.mimacom.ddd.pub.proto.PublicationClass;
import com.mimacom.ddd.pub.pub.Chapter;
import com.mimacom.ddd.pub.pub.CodeListing;
import com.mimacom.ddd.pub.pub.Component;
import com.mimacom.ddd.pub.pub.Division;
import com.mimacom.ddd.pub.pub.Document;
import com.mimacom.ddd.pub.pub.Figure;
import com.mimacom.ddd.pub.pub.ListItem;
import com.mimacom.ddd.pub.pub.ListStyle;
import com.mimacom.ddd.pub.pub.Part;
import com.mimacom.ddd.pub.pub.PubPackage;
import com.mimacom.ddd.pub.pub.PubUtil;
import com.mimacom.ddd.pub.pub.PublicationBody;
import com.mimacom.ddd.pub.pub.Section;
import com.mimacom.ddd.pub.pub.Subsection;
import com.mimacom.ddd.pub.pub.Subsubsection;
import com.mimacom.ddd.pub.pub.Table;
import com.mimacom.ddd.pub.pub.TableCell;
import com.mimacom.ddd.pub.pub.TableRow;
import com.mimacom.ddd.pub.pub.TitledBlock;
import com.mimacom.ddd.pub.pub.diagramProvider.DiagramProviderRegistry;
import com.mimacom.ddd.pub.pub.diagramProvider.DiagramRendererProxy;
import com.mimacom.ddd.pub.pub.generator.PubElementNames;
import com.mimacom.ddd.pub.pub.generator.PubNumberingUtil;
import com.mimacom.ddd.pub.pub.impl.PubConstants;
import com.mimacom.ddd.pub.pub.validation.AbstractPubValidator;
import java.util.HashSet;
import java.util.List;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.resource.XtextResource;
import org.eclipse.xtext.serializer.ISerializer;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.CheckType;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class PubValidator extends AbstractPubValidator {
  @Inject
  @Extension
  private PubUtil _pubUtil;
  
  @Inject
  @Extension
  private PubElementNames _pubElementNames;
  
  @Inject
  @Extension
  private PubNumberingUtil _pubNumberingUtil;
  
  @Inject
  private ISerializer serializer;
  
  @Inject
  private DiagramProviderRegistry registry;
  
  private static final BasePackage BASE = BasePackage.eINSTANCE;
  
  private static final PubPackage PUB = PubPackage.eINSTANCE;
  
  @Check
  public void publicationClass(final Document doc) {
    PublicationClass _publicationClass = doc.getPublicationClass();
    boolean _tripleEquals = (_publicationClass == null);
    if (_tripleEquals) {
      this.error("Document has no publication class.", PubValidator.PUB.getDocument_PublicationClass());
    }
  }
  
  @Check
  public void partsXorSections(final PublicationBody body) {
    Iterable<Part> parts = Iterables.<Part>filter(body.getDivisions(), Part.class);
    Iterable<Chapter> chapters = Iterables.<Chapter>filter(body.getDivisions(), Chapter.class);
    if (((!IterableExtensions.isEmpty(parts)) && (!IterableExtensions.isEmpty(chapters)))) {
      this.error("Cannot have both Parts and Chapters at the top level.", IterableExtensions.<Division>head(body.getDivisions()), PubValidator.PUB.getDivision_Title());
    }
  }
  
  @Check
  public void divisionStructuralIntegrity(final Division d) {
    Division _include = d.getInclude();
    boolean _tripleNotEquals = (_include != null);
    if (_tripleNotEquals) {
      boolean _isEmpty = d.getDivisions().isEmpty();
      boolean _not = (!_isEmpty);
      if (_not) {
        this.error("A division with an include cannot also contain divisions", PubValidator.PUB.getDivisionContainer_Divisions(), 0);
      }
      boolean _isEmpty_1 = d.getContents().isEmpty();
      boolean _not_1 = (!_isEmpty_1);
      if (_not_1) {
        this.error("A division with an include cannot also define contents", PubValidator.PUB.getBlockContainer_Contents(), 0);
      }
      Class<? extends Division> _class = d.getClass();
      Class<? extends Division> _class_1 = d.getInclude().getClass();
      boolean _notEquals = (!Objects.equal(_class, _class_1));
      if (_notEquals) {
        String _displayName = this._pubElementNames.displayName(d.getInclude());
        String _plus = ("Division include must be of the same type as the including division: " + _displayName);
        this.error(_plus, 
          PubValidator.PUB.getDivision_Include());
      }
    } else {
      boolean _isEmpty_2 = d.getDivisions().isEmpty();
      boolean _not_2 = (!_isEmpty_2);
      if (_not_2) {
        final Division head = IterableExtensions.<Division>head(d.getDivisions());
        final Class<? extends Division> clazz = head.getClass();
        boolean _matched = false;
        if (d instanceof Part) {
          _matched=true;
          boolean _isAssignableFrom = clazz.isAssignableFrom(Chapter.class);
          if (_isAssignableFrom) {
            this.error("A Part must contain subdivisions of type Chapter.", head, PubValidator.PUB.getDivision_Title());
          }
        }
        if (!_matched) {
          if (d instanceof Chapter) {
            _matched=true;
            boolean _isAssignableFrom = clazz.isAssignableFrom(Section.class);
            if (_isAssignableFrom) {
              this.error("A Chapter must contain subdivisions of type Section.", head, PubValidator.PUB.getDivision_Title());
            }
          }
        }
        if (!_matched) {
          if (d instanceof Section) {
            _matched=true;
            boolean _isAssignableFrom = clazz.isAssignableFrom(Subsection.class);
            if (_isAssignableFrom) {
              this.error("A Section must contain subdivisions of type Subsection.", head, PubValidator.PUB.getDivision_Title());
            }
          }
        }
        if (!_matched) {
          if (d instanceof Subsection) {
            _matched=true;
            boolean _isAssignableFrom = clazz.isAssignableFrom(Subsubsection.class);
            if (_isAssignableFrom) {
              this.error("A Subsection must contain subdivisions of type Subsubsection.", head, PubValidator.PUB.getDivision_Title());
            }
          }
        }
        if (!_matched) {
          if (d instanceof Subsubsection) {
            _matched=true;
            this.error("A Subsubsection cannot contain subdivisions.", head, PubValidator.PUB.getDivision_Title());
          }
        }
        EList<Division> _divisions = d.getDivisions();
        for (final Division subdiv : _divisions) {
          Class<? extends Division> _class_2 = subdiv.getClass();
          boolean _notEquals_1 = (!Objects.equal(_class_2, clazz));
          if (_notEquals_1) {
            final String msg = "A division can only contain subdivisions of the same type.";
            this.error(msg, head, PubValidator.PUB.getDivision_Title());
            this.error(msg, subdiv, PubValidator.PUB.getDivision_Title());
          }
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void divisionIsOnlyIncludedOnce(final Component compo) {
    final List<Division> allDivisionsInSequenceOfOccurrence = this._pubNumberingUtil.gatherAllDivisionsAndSetSequenceNumbers(compo);
    final HashSet<Division> divisionsSet = Sets.<Division>newHashSet();
    final String msg = "A division can only be included once and there can be no overlaps: ";
    for (final Division div : allDivisionsInSequenceOfOccurrence) {
      {
        boolean _add = divisionsSet.add(div);
        boolean _not = (!_add);
        if (_not) {
          this.error(msg, div, PubValidator.PUB.getDivision_Include());
        }
        if (((div.getInclude() != null) && (!divisionsSet.add(div.getInclude())))) {
          this.error(msg, div, PubValidator.PUB.getDivision_Include());
        }
      }
    }
  }
  
  @Check(CheckType.NORMAL)
  public void includedCodeSyntax(final CodeListing cl) {
    EObject _include = cl.getInclude();
    boolean _tripleNotEquals = (_include != null);
    if (_tripleNotEquals) {
      boolean hasErrors = false;
      final Resource res = cl.getInclude().eResource();
      if ((res instanceof XtextResource)) {
        hasErrors = ((XtextResource)res).getParseResult().hasSyntaxErrors();
      }
      if ((!hasErrors)) {
        try {
          this.serializer.serialize(cl.getInclude());
        } catch (final Throwable _t) {
          if (_t instanceof RuntimeException) {
            hasErrors = true;
          } else {
            throw Exceptions.sneakyThrow(_t);
          }
        }
      }
      if (hasErrors) {
        this.error("Code for the included expression has errors.", PubValidator.PUB.getCodeListing_Include());
      }
    }
  }
  
  @Check
  public void startNumberOnlyAtFirstDivision(final Division div) {
    if (((div.getSequenceNumber() > 0) && (div.getStartNumberingAt() != PubConstants.DIVISION_NUMBERING_DEFAULT_START_VALUE))) {
      this.error("The numbering start can only be defined by the first element at that level.", 
        PubValidator.PUB.getDivision_StartNumberingAt());
    }
  }
  
  @Check
  public void titleForTitledListItems(final ListItem item) {
    final ListStyle style = item.getList().getStyle();
    if ((Objects.equal(style, ListStyle.TITLE) && this._pubUtil.empty(item.getTitle()))) {
      String _literal = style.getLiteral();
      String _plus = ("Item title must be defined for list style \'" + _literal);
      String _plus_1 = (_plus + "\'.");
      this.error(_plus_1, item.getList(), PubValidator.PUB.getList_Items(), 
        item.getList().getItems().indexOf(item));
    } else {
      if (((!Objects.equal(style, ListStyle.TITLE)) && (!this._pubUtil.empty(item.getTitle())))) {
        String _literal_1 = style.getLiteral();
        String _plus_2 = ("Item cannot have a title for list style \'" + _literal_1);
        String _plus_3 = (_plus_2 + "\'.");
        this.error(_plus_3, PubValidator.PUB.getListItem_Title());
      }
    }
  }
  
  @Check
  public void includedDividionDoesNotInclude(final Division div) {
    if (((div.getInclude() != null) && (div.getInclude().getInclude() != null))) {
      this.error("Included division cannot itself include another division. Replace with non-transitive include.", 
        PubValidator.PUB.getDivision_Include());
    }
  }
  
  @Check
  public void titledBlockExpressionIsReference(final DRichText rt) {
    final EObject parent = rt.eContainer();
    if (((parent instanceof TitledBlock) || (parent instanceof Division))) {
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(rt.getSegments(), Object.class)).length); i++) {
        IRichTextSegment _get = rt.getSegments().get(i);
        boolean _matched = false;
        if (_get instanceof DTextSegment) {
          _matched=true;
        }
        if (!_matched) {
          if (_get instanceof DmxContextReference) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (_get instanceof DmxStaticReference) {
            _matched=true;
          }
        }
        if (!_matched) {
          this.error(
            "Titles can only contain expressions that are a direct reference to an external model element.", rt, PubValidator.BASE.getDRichText_Segments(), i);
        }
      }
    }
  }
  
  @Check
  public void tableHasRows(final Table t) {
    int _columns = t.getColumns();
    boolean _lessEqualsThan = (_columns <= 0);
    if (_lessEqualsThan) {
      this.error("Table must have 1 or more columns.", PubValidator.PUB.getTable_Columns());
      return;
    }
    boolean _isEmpty = t.getRows().isEmpty();
    if (_isEmpty) {
      this.warning("Table has no rows.", PubValidator.PUB.getTitledBlock_Title());
    }
  }
  
  @Check
  public void tableRowHasCells(final Table t) {
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(t.getRows(), Object.class)).length); i++) {
      boolean _isEmpty = t.getRows().get(i).getCells().isEmpty();
      if (_isEmpty) {
        this.warning("Table row has no cells.", PubValidator.PUB.getTable_Rows(), i);
      }
    }
  }
  
  @Check
  public void cellSizes(final TableRow row) {
    int _height = row.getHeight();
    boolean _lessEqualsThan = (_height <= 0);
    if (_lessEqualsThan) {
      this.error("Row height must be 1 or more.", PubValidator.PUB.getTableRow_Height());
      return;
    }
    boolean error = false;
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(row.getCells(), Object.class)).length); i++) {
      {
        final TableCell cell = row.getCells().get(i);
        if (((cell.getWidth() <= 0) || (cell.getHeight() <= 0))) {
          this.error("Cell height and width must be 1 or more.", PubValidator.PUB.getTableRow_Cells(), i);
          error = true;
        }
        int _height_1 = cell.getHeight();
        int _height_2 = row.getHeight();
        boolean _greaterThan = (_height_1 > _height_2);
        if (_greaterThan) {
          this.error("Cell height exceeds row height.", PubValidator.PUB.getTableRow_Cells(), i);
          error = true;
        }
      }
    }
    if (error) {
      return;
    }
    final int tableWidth = row.getTable().getColumns();
    int width = 0;
    int height = 0;
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(row.getCells(), Object.class)).length); i++) {
      {
        final TableCell cell = row.getCells().get(i);
        if ((height == 0)) {
          int _width = cell.getWidth();
          int _plus = (width + _width);
          width = _plus;
          if ((width > tableWidth)) {
            this.error("Cell causes row width to exceed declared number of table columns.", PubValidator.PUB.getTableRow_Cells(), i);
            error = true;
          }
        } else {
          if ((i > 0)) {
            final TableCell prevCell = row.getCells().get((i - 1));
            int _width_1 = cell.getWidth();
            int _width_2 = prevCell.getWidth();
            boolean _notEquals = (_width_1 != _width_2);
            if (_notEquals) {
              this.error("Cell width does not match width of cell above.", PubValidator.PUB.getTableRow_Cells(), i);
              error = true;
            }
          }
        }
        int _height_1 = cell.getHeight();
        int _plus_1 = (height + _height_1);
        height = _plus_1;
        int _height_2 = row.getHeight();
        boolean _greaterThan = (height > _height_2);
        if (_greaterThan) {
          this.error("Cell causes row height to exceed declared row height.", PubValidator.PUB.getTableRow_Cells(), i);
          error = true;
        } else {
          int _height_3 = row.getHeight();
          boolean _equals = (height == _height_3);
          if (_equals) {
            height = 0;
          }
        }
        if (error) {
          return;
        }
      }
    }
    if ((width < tableWidth)) {
      EReference _tableRow_Cells = PubValidator.PUB.getTableRow_Cells();
      int _length = ((Object[])Conversions.unwrapArray(row.getCells(), Object.class)).length;
      int _minus = (_length - 1);
      this.error("The cells of this row span less than the declared number of table columns.", _tableRow_Cells, _minus);
    }
    if (((height > 0) && (height < row.getHeight()))) {
      EReference _tableRow_Cells_1 = PubValidator.PUB.getTableRow_Cells();
      int _length_1 = ((Object[])Conversions.unwrapArray(row.getCells(), Object.class)).length;
      int _minus_1 = (_length_1 - 1);
      this.error("The cells of this row span less than the declared row height.", _tableRow_Cells_1, _minus_1);
    }
  }
  
  @Check(CheckType.NORMAL)
  public void diagramCanRender(final Figure f) {
    if ((((f.getDiagramRoot() != null) && (f.getRenderer() != null)) && (f.getRenderer().getName() != null))) {
      final DiagramRendererProxy provider = this.registry.getDiagramProvider(f.getRenderer().getName());
      boolean _canRender = provider.canRender(f.getDiagramRoot());
      boolean _not = (!_canRender);
      if (_not) {
        this.error("The referenced model does not provide content, the generated diagram will be empty", PubValidator.PUB.getFigure_DiagramRoot());
      }
    }
  }
}
