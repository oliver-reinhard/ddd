/*
 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.pub.pub.validation

import com.google.inject.Inject
import com.mimacom.ddd.dm.base.BasePackage
import com.mimacom.ddd.dm.base.DRichText
import com.mimacom.ddd.dm.base.DTextSegment
import com.mimacom.ddd.dm.dmx.DmxContextReference
import com.mimacom.ddd.dm.dmx.DmxStaticReference
import com.mimacom.ddd.pub.pub.Chapter
import com.mimacom.ddd.pub.pub.Division
import com.mimacom.ddd.pub.pub.ListItem
import com.mimacom.ddd.pub.pub.ListStyle
import com.mimacom.ddd.pub.pub.Part
import com.mimacom.ddd.pub.pub.PubPackage
import com.mimacom.ddd.pub.pub.PubUtil
import com.mimacom.ddd.pub.pub.PublicationBody
import com.mimacom.ddd.pub.pub.Table
import com.mimacom.ddd.pub.pub.TableRow
import com.mimacom.ddd.pub.pub.TitledBlock
import com.mimacom.ddd.pub.pub.impl.PublicationConstants
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PubValidator extends AbstractPubValidator {

	@Inject extension PubUtil

	static val BASE = BasePackage.eINSTANCE
	static val PUB = PubPackage.eINSTANCE

	@Check
	def partsXorSections(PublicationBody body) {
		var parts = body.divisions.filter(Part)
		var chapters = body.divisions.filter(Chapter)
		if (! parts.empty && ! chapters.empty) {
			error("Cannot have both Parts and Chapters at the top level.", body.divisions.head, PUB.division_Title) // flag first occurrence
		}
	}

	@Check
	def startNumberOnlyAtFirstDivision(Division div) {
		if (div.getSequenceNumber > 0 &&
			div.startNumberingAt != PublicationConstants.DIVISION_NUMBERING_DEFAULT_START_VALUE) {
			error("The numbering start can only be defined by the first element at that level.",
				PUB.division_StartNumberingAt)
		}
	}

	@Check
	def titleForTitledListItems(ListItem item) {
		val style = item.list.style
		if (style == ListStyle.TITLE && item.title.empty) {
			error("Item title must be defined for list style '" + style.literal + "'.", item.list, PUB.list_Items,
				item.list.items.indexOf(item))
		} else if (style != ListStyle.TITLE && ! (item.title.empty)) {
			error("Item cannot have a title for list style '" + style.literal + "'.", PUB.listItem_Title)
		}
	}

	@Check
	def titledBlockExpressionIsReference(DRichText rt) {
		val parent = rt.eContainer
		if (parent instanceof TitledBlock || parent instanceof Division) {
			for (var i = 0; i < rt.segments.length; i++) {
				// only check top-level expression elements
				switch rt.segments.get(i) {
					DTextSegment: {
					}
					DmxContextReference: {
					}
					DmxStaticReference: {
					}
					default:
						error(
							"Titles can only contain expressions that are a direct reference to an external model element.",
							rt, BASE.DRichText_Segments, i)
				}
			}
		}
	}

	//
	// Tables
	// 
	
	@Check
	def tableHasRows(Table t) {
		if (t.columns <= 0) {
			error("Table must have 1 or more columns.", PUB.table_Columns)
			return
		}
		if (t.rows.empty) {
			warning("Table has no rows.", PUB.titledBlock_Title)
		}
	}

	@Check
	def tableRowHasCells(Table t) {
		for (var i = 0; i < t.rows.length; i++) {
			if (t.rows.get(i).cells.empty) {
				warning("Table row has no cells.", PUB.table_Rows, i)
			}
		}
	}

	@Check
	def cellSizes(TableRow row) {
		if (row.height <= 0) {
			error("Row height must be 1 or more.", PUB.tableRow_Height)
			return
		}
		var error = false
		for (var i = 0; i < row.cells.length; i++) {
			val cell = row.cells.get(i)
			if (cell.width <= 0 || cell.height <= 0) {
				error("Cell height and width must be 1 or more.", PUB.tableRow_Cells, i)
				error = true
			}
			if (cell.height > row.height) {
				error("Cell height exceeds row height.", PUB.tableRow_Cells, i)
				error = true
			}
		}
		if (error) {
			return
		}
		val tableWidth = row.table.columns
		var width = 0
		var height = 0
		for (var i = 0; i < row.cells.length; i++) {
			val cell = row.cells.get(i)
			if (height == 0) {
				// this is a cell in the top line of the row
				width = width + cell.width
				if (width > tableWidth) {
					error("Cell causes row width to exceed declared number of table columns.", PUB.tableRow_Cells, i)
					error = true
				}
			} else if (i > 0) {
				val prevCell = row.cells.get(i - 1)
				if (cell.width != prevCell.width) {
					error("Cell width does not match width of cell above.", PUB.tableRow_Cells, i)
					error = true
				}
			}
			height = height + cell.height
			if (height > row.height) {
				error("Cell causes row height to exceed declared row height.", PUB.tableRow_Cells, i)
				error = true
			} else if (height == row.height) {
				height = 0
			}
			if (error) {
				return
			}
		}
		if (width < tableWidth) {
			error("The cells of this row span less than the declared number of table columns.", PUB.tableRow_Cells,
				row.cells.length - 1)
		}
		if (height > 0 && height < row.height) {
			error("The cells of this row span less than the declared row height.", PUB.tableRow_Cells,
				row.cells.length - 1)
		}
	}
}
