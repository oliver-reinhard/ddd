/*

 * generated by Xtext 2.19.0
 */
package com.mimacom.ddd.pub.pub.scoping

import com.google.common.collect.Lists
import com.google.inject.Inject
import com.mimacom.ddd.pub.pub.Document
import com.mimacom.ddd.pub.pub.ProvidedFigure
import com.mimacom.ddd.pub.pub.ProvidedTable
import com.mimacom.ddd.pub.pub.PubModel
import com.mimacom.ddd.pub.pub.PubPackage
import com.mimacom.ddd.pub.pub.Reference
import com.mimacom.ddd.pub.pub.diagramProvider.DiagramProviderRegistry
import com.mimacom.ddd.pub.pub.tableProvider.TableProviderRegistry
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.EcoreUtil2
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.EObjectDescription
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.SimpleScope

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
class PubScopeProvider extends AbstractPubScopeProvider {

	static val PUB = PubPackage.eINSTANCE

	@Inject IQualifiedNameProvider qualifiedNameProvider
	@Inject TableProviderRegistry tableProviderRegistry
	@Inject DiagramProviderRegistry diagramProviderRegistry

	override IScope getScope(EObject context, EReference reference) {

		if (reference == PUB.reference_Target && context instanceof Reference) {
			val targetScope = switch (context as Reference).scope {
				case DOCUMENT_SEGMENT: PUB.documentSegment
				case DIVISION: PUB.division
				case PART: PUB.part
				case APPENDIX: PUB.appendix
				case CHAPTER: PUB.chapter
				case SECTION: PUB.section
				case SUBSECTION: PUB.subsection
				case SUBSUBSECTION: PUB.subsubsection
				case FOOTNOTE:PUB.footnote
				case LIST_ITEM: PUB.listItem
				case TABLE: PUB.titledTable
				case FIGURE: PUB.titledFigure
				case EQUATION: PUB.equation
				case CODE_LISTING: PUB.titledCodeListing
				case ADMONITION: PUB.admonition
				case ABBREVIATION: PUB.abbreviation
				case GLOSSARY: PUB.glossaryEntry
				case BIBLIOGRAPHY: PUB.bibliographyEntry
				default: PUB.referenceTarget
			}
			return getDefaultScopeOfType(context, targetScope)

		} else if (reference == PUB.providedTable_TableType && context instanceof ProvidedTable) {
			val table = context as ProvidedTable
			val model = EcoreUtil2.getContainerOfType(context, PubModel)
			if (model !== null) {
				// model.tableRenderers are installed by ExtensionPointsScopeElementsDerivedStateComputer
				if (model.providedTableTypes.empty) {
					return IScope.NULLSCOPE
					
				} else if (table.diagramRoot !== null) {
					// limit table renderers to those providing for the class of the given diagram-root: 
					val tableRendererIds = tableProviderRegistry.getTableRenderers(table.diagramRoot.class).map[it.id].toList
					// Scopes.scopeFor does not use an IQualifiedNameProvider to compute the qualified name of the objects
					return createScopeWithQualifiedNames(model.providedTableTypes.filter[tableRendererIds.contains(it.name)])
				}
			}
		
		} else if (reference == PUB.providedFigure_DiagramType && context instanceof ProvidedFigure) {
			val figure = context as ProvidedFigure
			val model = EcoreUtil2.getContainerOfType(context, PubModel)
			if (model !== null) {
				// model.figureRenderers are installed by ExtensionPointsScopeElementsDerivedStateComputer
				if (model.providedDiagramTypes.empty) {
					return IScope.NULLSCOPE
					
				} else if (figure.diagramRoot !== null) {
					// limit diagram renderers to the diagram types supported for the class of the given diagram-root: 
					val diagramProviderIds = diagramProviderRegistry.getDiagramRenderers(figure.diagramRoot.class).map[it.diagramTypeID].toList
					// Scopes.scopeFor does not use an IQualifiedNameProvider to compute the qualified name of the objects
					return createScopeWithQualifiedNames(model.providedDiagramTypes.filter[diagramProviderIds.contains(it.name)])
				}
			}
		}
		return super.getScope(context, reference)
	}
	
	/*
	 * Add symbols to context-reference scope.
	 */
	override getContextReferenceScope(EObject context, IScope outerScope) {
		val scope = super.getContextReferenceScope(context, outerScope)
		val doc = EcoreUtil2.getContainerOfType(context, Document)
		if (doc !== null && ! doc.symbols.empty) {
			return Scopes.scopeFor(doc.symbols, scope)
		}
		return scope
	}

	protected def createScopeWithQualifiedNames(Iterable<? extends EObject> objects) {
		val List<IEObjectDescription> descriptions = Lists.newArrayList
		for (obj : objects) {
			descriptions.add(new EObjectDescription(qualifiedNameProvider.getFullyQualifiedName(obj), obj, null))
		}
		return new SimpleScope(descriptions)
	}
}
